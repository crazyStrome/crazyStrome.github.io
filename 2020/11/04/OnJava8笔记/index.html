<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>crazyStrome的博客 | crazyStrome的博客</title><meta name="author" content="crazyStrome"><meta name="copyright" content="crazyStrome"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="[TOC] CH14  流式编程流式编程就是把一系列对象看成是一条数据流，像是流水线一样，开发者可以在这条流水线上进行替换，读取，剔除等操作。 12345678910111213&#x2F;&#x2F; streams&#x2F;Randoms.javaimport java.util.*;public class Randoms &amp;#123;    public static void main(String[] args)">
<meta property="og:type" content="article">
<meta property="og:title" content="crazyStrome的博客">
<meta property="og:url" content="http://crazystrome.github.io/2020/11/04/OnJava8%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="crazyStrome的博客">
<meta property="og:description" content="[TOC] CH14  流式编程流式编程就是把一系列对象看成是一条数据流，像是流水线一样，开发者可以在这条流水线上进行替换，读取，剔除等操作。 12345678910111213&#x2F;&#x2F; streams&#x2F;Randoms.javaimport java.util.*;public class Randoms &amp;#123;    public static void main(String[] args)">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2020-11-04T10:24:59.231Z">
<meta property="article:modified_time" content="2020-05-20T05:36:34.000Z">
<meta property="article:author" content="crazyStrome">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://crazystrome.github.io/2020/11/04/OnJava8%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.2.0',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-05-20 13:36:34'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {
  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }

  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }
})()</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/null" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">40</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">2</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">1</div></a></div></div></div><hr/></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#CH14-%E6%B5%81%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">CH14  流式编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E6%94%AF%E6%8C%81"><span class="toc-number">1.1.</span> <span class="toc-text">流支持</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E5%88%9B%E5%BB%BA"><span class="toc-number">1.2.</span> <span class="toc-text">流创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%9A%84%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.</span> <span class="toc-text">流的建造者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Arrays"><span class="toc-number">1.4.</span> <span class="toc-text">Arrays</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.5.</span> <span class="toc-text">正则表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C"><span class="toc-number">1.6.</span> <span class="toc-text">中间操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%9F%E8%B8%AA%E5%92%8C%E8%B0%83%E8%AF%95"><span class="toc-number">1.6.1.</span> <span class="toc-text">跟踪和调试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E5%85%83%E7%B4%A0%E6%8E%92%E5%BA%8F"><span class="toc-number">1.6.2.</span> <span class="toc-text">流元素排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">1.6.3.</span> <span class="toc-text">移除元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%87%BD%E6%95%B0%E5%88%B0%E5%85%83%E7%B4%A0"><span class="toc-number">1.6.4.</span> <span class="toc-text">应用函数到元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8map-%E4%B8%AD%E7%BB%84%E5%90%88%E6%B5%81"><span class="toc-number">1.6.5.</span> <span class="toc-text">在map()中组合流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Optinal%E7%B1%BB"><span class="toc-number">1.7.</span> <span class="toc-text">Optinal类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%BF%E5%88%A9%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.1.</span> <span class="toc-text">便利函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAOptional"><span class="toc-number">1.7.2.</span> <span class="toc-text">创建Optional</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Optional%E5%AF%B9%E8%B1%A1%E6%93%8D%E4%BD%9C"><span class="toc-number">1.7.3.</span> <span class="toc-text">Optional对象操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%88%E7%AB%AF%E6%93%8D%E4%BD%9C"><span class="toc-number">1.8.</span> <span class="toc-text">终端操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.8.1.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.8.2.</span> <span class="toc-text">循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">1.8.3.</span> <span class="toc-text">集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88"><span class="toc-number">1.8.4.</span> <span class="toc-text">组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D"><span class="toc-number">1.8.5.</span> <span class="toc-text">匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE"><span class="toc-number">1.8.6.</span> <span class="toc-text">查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E6%81%AF"><span class="toc-number">1.8.7.</span> <span class="toc-text">信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E6%B5%81%E4%BF%A1%E6%81%AF"><span class="toc-number">1.8.8.</span> <span class="toc-text">数字流信息</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CH15-%E5%BC%82%E5%B8%B8"><span class="toc-number">2.</span> <span class="toc-text">CH15 异常</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">异常概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%BC%82%E5%B8%B8"><span class="toc-number">2.2.</span> <span class="toc-text">基本异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%8F%82%E6%95%B0"><span class="toc-number">2.3.</span> <span class="toc-text">异常参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7"><span class="toc-number">2.4.</span> <span class="toc-text">异常捕获</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#try%E8%AF%AD%E5%8F%A5%E5%9D%97"><span class="toc-number">2.4.1.</span> <span class="toc-text">try语句块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.4.2.</span> <span class="toc-text">异常处理程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E6%AD%A2%E4%B8%8E%E6%81%A2%E5%A4%8D"><span class="toc-number">2.4.3.</span> <span class="toc-text">终止与恢复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-number">2.5.</span> <span class="toc-text">自定义异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E4%B8%8E%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97"><span class="toc-number">2.5.1.</span> <span class="toc-text">异常与记录日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A3%B0%E6%98%8E"><span class="toc-number">2.5.2.</span> <span class="toc-text">异常声明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E6%89%80%E6%9C%89%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="toc-number">2.6.</span> <span class="toc-text">捕获所有的异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E6%8D%95%E8%8E%B7"><span class="toc-number">2.6.1.</span> <span class="toc-text">多重捕获</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E8%BD%A8%E8%BF%B9"><span class="toc-number">2.6.2.</span> <span class="toc-text">栈轨迹</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">2.6.3.</span> <span class="toc-text">重新抛出异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E9%93%BE"><span class="toc-number">2.6.4.</span> <span class="toc-text">异常链</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E6%A0%87%E5%87%86%E5%BC%82%E5%B8%B8"><span class="toc-number">2.7.</span> <span class="toc-text">Java标准异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8"><span class="toc-number">2.7.1.</span> <span class="toc-text">运行时异常</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Finally"><span class="toc-number">2.8.</span> <span class="toc-text">Finally</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8return%E4%B8%AD%E4%BD%BF%E7%94%A8finally"><span class="toc-number">2.8.1.</span> <span class="toc-text">在return中使用finally</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E9%99%90%E5%88%B6"><span class="toc-number">2.9.</span> <span class="toc-text">异常限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%82%E5%B8%B8"><span class="toc-number">2.10.</span> <span class="toc-text">构造器异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Try-With-Resource%E7%94%A8%E6%B3%95"><span class="toc-number">2.11.</span> <span class="toc-text">Try-With-Resource用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%AD%E7%A4%BA%E7%BB%86%E8%8A%82"><span class="toc-number">2.11.1.</span> <span class="toc-text">揭示细节</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CH16-%E4%BB%A3%E7%A0%81%E6%A0%A1%E9%AA%8C"><span class="toc-number">3.</span> <span class="toc-text">CH16  代码校验</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JUnit"><span class="toc-number">3.1.</span> <span class="toc-text">JUnit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.2.</span> <span class="toc-text">前置条件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%AD%E8%A8%80"><span class="toc-number">3.2.1.</span> <span class="toc-text">断言</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Ch17-%E6%96%87%E4%BB%B6"><span class="toc-number">4.</span> <span class="toc-text">Ch17 文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E8%B7%AF%E5%BE%84"><span class="toc-number">4.1.</span> <span class="toc-text">文件和目录路径</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E5%8F%96%E8%B7%AF%E5%BE%84%E9%83%A8%E5%88%86%E7%89%87%E6%AE%B5"><span class="toc-number">4.1.1.</span> <span class="toc-text">选取路径部分片段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E5%88%86%E6%9E%90"><span class="toc-number">4.1.2.</span> <span class="toc-text">路径分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Paths%E7%9A%84%E5%A2%9E%E5%88%A0%E4%BF%AE%E6%94%B9"><span class="toc-number">4.1.3.</span> <span class="toc-text">Paths的增删修改</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95"><span class="toc-number">4.2.</span> <span class="toc-text">目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.3.</span> <span class="toc-text">文件系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E7%9B%91%E5%90%AC"><span class="toc-number">4.4.</span> <span class="toc-text">路径监听</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE"><span class="toc-number">4.5.</span> <span class="toc-text">文件查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99"><span class="toc-number">4.6.</span> <span class="toc-text">文件读写</span></a></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">crazyStrome的博客</a></span><span id="menus"><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">无题</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-11-04T10:24:59.231Z" title="发表于 2020-11-04 18:24:59">2020-11-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-05-20T05:36:34.000Z" title="更新于 2020-05-20 13:36:34">2020-05-20</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>[TOC]</p>
<h1 id="CH14-流式编程"><a href="#CH14-流式编程" class="headerlink" title="CH14  流式编程"></a>CH14  流式编程</h1><p>流式编程就是把一系列对象看成是一条数据流，像是流水线一样，开发者可以在这条流水线上进行替换，读取，剔除等操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// streams/Randoms.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Randoms</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Random(<span class="number">47</span>)</span><br><span class="line">            .ints(<span class="number">5</span>, <span class="number">20</span>)</span><br><span class="line">            .distinct()</span><br><span class="line">            .limit(<span class="number">7</span>)</span><br><span class="line">            .sorted()</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>中间流操作：</p>
<ul>
<li>distinct()用来获取非重复的元素。</li>
<li>limit()方法获取一定数量的元素。</li>
<li>sorted()排序。</li>
<li>forEach()遍历对每个元素进行操作。</li>
</ul>
<p>流式编程使用内部迭代，这种机制使得编写的代码可读性更强。</p>
<p>流是懒加载的，这代表它只在绝对必要时才计算。</p>
<h2 id="流支持"><a href="#流支持" class="headerlink" title="流支持"></a>流支持</h2><p>接口增加默认方法的极具说服力的理由是它允许在不破坏已使用接口的代码的情况下，在接口中增加新的方法。默认方法有时也被称为<em>守卫方法</em>或<em>虚拟扩展方法</em>。</p>
<p>Java8在接口中添加被 <code>default</code>（<code>默认</code>）修饰的方法。通过这种方案，设计者们可以将流式（<em>stream</em>）方法平滑地嵌入到现有类中。</p>
<p>流操作的类型有三种：创建流、修改流（中间操作）、消费流操作。</p>
<h2 id="流创建"><a href="#流创建" class="headerlink" title="流创建"></a>流创建</h2><p>通过Stream.of()可以将一组元素转化为流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// streams/StreamOf.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamOf</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream.of(<span class="keyword">new</span> Bubble(<span class="number">1</span>), <span class="keyword">new</span> Bubble(<span class="number">2</span>), <span class="keyword">new</span> Bubble(<span class="number">3</span>))</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">        Stream.of(<span class="string">&quot;It&#x27;s &quot;</span>, <span class="string">&quot;a &quot;</span>, <span class="string">&quot;wonderful &quot;</span>, <span class="string">&quot;day &quot;</span>, <span class="string">&quot;for &quot;</span>, <span class="string">&quot;pie!&quot;</span>)</span><br><span class="line">            .forEach(System.out::print);</span><br><span class="line">        System.out.println();</span><br><span class="line">        Stream.of(<span class="number">3.14159</span>, <span class="number">2.718</span>, <span class="number">1.618</span>)</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>每个集合都可以通过调用stream()方法来产生一个流。</p>
<p><code>mapToInt()</code> 方法将一个对象流（object stream）转换成为包含整型数字的 <code>IntStream</code>。</p>
<p><code>boxed()</code> 流操作将会自动地把基本类型包装成为对应的装箱类型。</p>
<p><code>IntStream</code> 类提供了 <code>range()</code> 方法用于生成整型序列的流。编写循环时，这个方法会更加便利：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// streams/Ranges.java</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.IntStream.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ranges</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 传统方法:</span></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">            result += i;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="comment">// for-in 循环:</span></span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : range(<span class="number">10</span>, <span class="number">20</span>).toArray())</span><br><span class="line">            result += i;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="comment">// 使用流:</span></span><br><span class="line">        System.out.println(range(<span class="number">10</span>, <span class="number">20</span>).sum());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>generate()是用来生成一个序列的，需要传入一个Supplier<T>接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// streams/Generator.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generator</span> <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">char</span>[] letters = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>.toCharArray();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span> + letters[rand.nextInt(letters.length)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String word = Stream.generate(<span class="keyword">new</span> Generator())</span><br><span class="line">                            .limit(<span class="number">30</span>)</span><br><span class="line">                            .collect(Collectors.joining());</span><br><span class="line">        System.out.println(word);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>Stream.</strong><code>iterate()</code> 以种子（第一个参数）开头，并将其传给方法（第二个参数）。方法的结果将添加到流，并存储作为第一个参数用于下次调用 <code>iterate()</code></p>
<p><code>skip()</code> 操作根据参数丢弃指定数量的流元素。</p>
<h2 id="流的建造者模式"><a href="#流的建造者模式" class="headerlink" title="流的建造者模式"></a>流的建造者模式</h2><p>builder()可以构建一个stream</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// streams/FileToWordsBuilder.java</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileToWordsBuilder</span> </span>&#123;</span><br><span class="line">    Stream.Builder&lt;String&gt; builder = Stream.builder();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileToWordsBuilder</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Files.lines(Paths.get(filePath))</span><br><span class="line">             .skip(<span class="number">1</span>) <span class="comment">// 略过开头的注释行</span></span><br><span class="line">             .forEach(line -&gt; &#123;</span><br><span class="line">                  <span class="keyword">for</span> (String w : line.split(<span class="string">&quot;[ .?,]+&quot;</span>))</span><br><span class="line">                      builder.add(w);</span><br><span class="line">              &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Stream&lt;String&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> builder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> FileToWordsBuilder(<span class="string">&quot;Cheese.dat&quot;</span>)</span><br><span class="line">            .stream()</span><br><span class="line">            .limit(<span class="number">7</span>)</span><br><span class="line">            .map(w -&gt; w + <span class="string">&quot; &quot;</span>)</span><br><span class="line">            .forEach(System.out::print);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p><code>Arrays</code> 类中含有一个名为 <code>stream()</code> 的静态方法用于把数组转换成为流。</p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>Java 8 在 <code>java.util.regex.Pattern</code> 中增加了一个新的方法 <code>splitAsStream()</code>。这个方法可以根据传入的公式将字符序列转化为流。但是有一个限制，输入只能是 <strong>CharSequence</strong>，因此不能将流作为 <code>splitAsStream()</code> 的参数。</p>
<p>现在，当你调用 <code>stream()</code> 的时候，可以像往常一样获取一个流，但这次你可以多次调用 <code>stream()</code> 在已存储的字符串中创建一个新的流。这里有个限制，整个文件必须存储在内存中；在大多数情况下这并不是什么问题，但是这损失了流操作非常重要的优势：</p>
<ol>
<li>流“不需要存储”。当然它们需要一些内部存储，但是这只是序列的一小部分，和持有整个序列并不相同。</li>
<li>它们是懒加载计算的。</li>
</ol>
<h2 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h2><p>中间操作用于从一个流中获取对象，并将对象作为另一个流从后端输出，以连接到其他操作。</p>
<h3 id="跟踪和调试"><a href="#跟踪和调试" class="headerlink" title="跟踪和调试"></a>跟踪和调试</h3><p>peek()可以无修改地查看流中的元素。</p>
<h3 id="流元素排序"><a href="#流元素排序" class="headerlink" title="流元素排序"></a>流元素排序</h3><p>在sorted()中传入一个Comparator参数可以可以定义排序规则。</p>
<h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h3><p>distinct()用于消除重复的元素。</p>
<p>filter(Predicate)用来过滤结果为true的元素。</p>
<h3 id="应用函数到元素"><a href="#应用函数到元素" class="headerlink" title="应用函数到元素"></a>应用函数到元素</h3><ul>
<li><code>map(Function)</code>：将函数操作应用在输入流的元素中，并将返回值传递到输出流中。</li>
<li><code>mapToInt(ToIntFunction)</code>：操作同上，但结果是 <strong>IntStream</strong>。</li>
<li><code>mapToLong(ToLongFunction)</code>：操作同上，但结果是 <strong>LongStream</strong>。</li>
<li><code>mapToDouble(ToDoubleFunction)</code>：操作同上，但结果是 <strong>DoubleStream</strong>。</li>
</ul>
<h3 id="在map-中组合流"><a href="#在map-中组合流" class="headerlink" title="在map()中组合流"></a>在map()中组合流</h3><p>假设我们现在有了一个传入的元素流，并且打算对流元素使用 <code>map()</code> 函数。现在你已经找到了一些可爱并独一无二的函数功能，但是问题来了：这个函数功能是产生一个流。我们想要产生一个元素流，而实际却产生了一个元素流的流。</p>
<p><code>flatMap()</code> 做了两件事：将产生流的函数应用在每个元素上（与 <code>map()</code> 所做的相同），然后将每个流都扁平化为元素，因而最终产生的仅仅是元素。</p>
<p><code>flatMap(Function)</code>：当 <code>Function</code> 产生流时使用。</p>
<p><code>flatMapToInt(Function)</code>：当 <code>Function</code> 产生 <code>IntStream</code> 时使用。</p>
<p><code>flatMapToLong(Function)</code>：当 <code>Function</code> 产生 <code>LongStream</code> 时使用。</p>
<p><code>flatMapToDouble(Function)</code>：当 <code>Function</code> 产生 <code>DoubleStream</code> 时使用。</p>
<p>为了弄清它的工作原理，我们从传入一个刻意设计的函数给 <code>map()</code> 开始。该函数接受一个整数并产生一个字符串流：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// streams/StreamOfStreams.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamOfStreams</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">        .map(i -&gt; Stream.of(<span class="string">&quot;Gonzo&quot;</span>, <span class="string">&quot;Kermit&quot;</span>, <span class="string">&quot;Beaker&quot;</span>))</span><br><span class="line">        .map(e-&gt; e.getClass().getName())</span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java<span class="selector-class">.util</span><span class="selector-class">.stream</span>.ReferencePipeline<span class="variable">$Head</span></span><br><span class="line">java<span class="selector-class">.util</span><span class="selector-class">.stream</span>.ReferencePipeline<span class="variable">$Head</span></span><br><span class="line">java<span class="selector-class">.util</span><span class="selector-class">.stream</span>.ReferencePipeline<span class="variable">$Head</span></span><br></pre></td></tr></table></figure>

<p>使用flatMap()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// streams/FlatMap.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlatMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">        .flatMap(i -&gt; Stream.of(<span class="string">&quot;Gonzo&quot;</span>, <span class="string">&quot;Fozzie&quot;</span>, <span class="string">&quot;Beaker&quot;</span>))</span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Gonzo</span><br><span class="line">Fozzie</span><br><span class="line">Beaker</span><br><span class="line">Gonzo</span><br><span class="line">Fozzie</span><br><span class="line">Beaker</span><br><span class="line">Gonzo</span><br><span class="line">Fozzie</span><br><span class="line">Beaker</span><br></pre></td></tr></table></figure>

<p>IntStream.concat()以参数顺序组合两个流。</p>
<h2 id="Optinal类"><a href="#Optinal类" class="headerlink" title="Optinal类"></a>Optinal类</h2><p>Optinal类在流到达结尾时会提示。</p>
<ul>
<li><p><code>findFirst()</code> 返回一个包含第一个元素的 <strong>Optional</strong> 对象，如果流为空则返回 <strong>Optional.empty</strong></p>
</li>
<li><p><code>findAny()</code> 返回包含任意元素的 <strong>Optional</strong> 对象，如果流为空则返回 <strong>Optional.empty</strong></p>
</li>
<li><p><code>max()</code> 和 <code>min()</code> 返回一个包含最大值或者最小值的 <strong>Optional</strong> 对象，如果流为空则返回 <strong>Optional.empty</strong></p>
<p><code>reduce()</code> 不再以 <code>identity</code> 形式开头，而是将其返回值包装在 <strong>Optional</strong> 中。（<code>identity</code> 对象成为其他形式的 <code>reduce()</code> 的默认结果，因此不存在空结果的风险）</p>
</li>
</ul>
<p>对于数字流 <strong>IntStream</strong>、<strong>LongStream</strong> 和 <strong>DoubleStream</strong>，<code>average()</code> 会将结果包装在 <strong>Optional</strong> 以防止流为空。</p>
<h3 id="便利函数"><a href="#便利函数" class="headerlink" title="便利函数"></a>便利函数</h3><ul>
<li><code>ifPresent(Consumer)</code>：当值存在时调用 <strong>Consumer</strong>，否则什么也不做。</li>
<li><code>orElse(otherObject)</code>：如果值存在则直接返回，否则生成 <strong>otherObject</strong>。</li>
<li><code>orElseGet(Supplier)</code>：如果值存在则直接返回，否则使用 <strong>Supplier</strong> 函数生成一个可替代对象。</li>
<li><code>orElseThrow(Supplier)</code>：如果值存在直接返回，否则使用 <strong>Supplier</strong> 函数生成一个异常。</li>
</ul>
<h3 id="创建Optional"><a href="#创建Optional" class="headerlink" title="创建Optional"></a>创建Optional</h3><p>当我们在自己的代码中加入 <strong>Optional</strong> 时，可以使用下面 3 个静态方法：</p>
<ul>
<li><code>empty()</code>：生成一个空 <strong>Optional</strong>。</li>
<li><code>of(value)</code>：将一个非空值包装到 <strong>Optional</strong> 里。</li>
<li><code>ofNullable(value)</code>：针对一个可能为空的值，为空时自动生成 <strong>Optional.empty</strong>，否则将值包装在 <strong>Optional</strong> 中。</li>
</ul>
<h3 id="Optional对象操作"><a href="#Optional对象操作" class="headerlink" title="Optional对象操作"></a>Optional对象操作</h3><p>当我们的流管道生成了 <strong>Optional</strong> 对象，下面 3 个方法可使得 <strong>Optional</strong> 的后续能做更多的操作：</p>
<ul>
<li><code>filter(Predicate)</code>：将 <strong>Predicate</strong> 应用于 <strong>Optional</strong> 中的内容并返回结果。当 <strong>Optional</strong> 不满足 <strong>Predicate</strong> 时返回空。如果 <strong>Optional</strong> 为空，则直接返回。</li>
<li><code>map(Function)</code>：如果 <strong>Optional</strong> 不为空，应用 <strong>Function</strong> 于 <strong>Optional</strong> 中的内容，并返回结果。否则直接返回 <strong>Optional.empty</strong>。</li>
<li><code>flatMap(Function)</code>：同 <code>map()</code>，但是提供的映射函数将结果包装在 <strong>Optional</strong> 对象中，因此 <code>flatMap()</code> 不会在最后进行任何包装。</li>
</ul>
<p>以上方法都不适用于数值型 <strong>Optional</strong>。一般来说，流的 <code>filter()</code> 会在 <strong>Predicate</strong> 返回 <code>false</code> 时移除流元素。而 <code>Optional.filter()</code> 在失败时不会删除 <strong>Optional</strong>，而是将其保留下来，并转化为空。</p>
<h2 id="终端操作"><a href="#终端操作" class="headerlink" title="终端操作"></a>终端操作</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul>
<li><code>toArray()</code>：将流转换成适当类型的数组。</li>
<li><code>toArray(generator)</code>：在特殊情况下，生成自定义类型的数组。</li>
</ul>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><ul>
<li><code>forEach(Consumer)</code>常见如 <code>System.out::println</code> 作为 <strong>Consumer</strong> 函数。</li>
<li><code>forEachOrdered(Consumer)</code>： 保证 <code>forEach</code> 按照原始流顺序操作。</li>
</ul>
<p><code>parallel()</code>：可实现多处理器并行操作。实现原理为将流分割为多个（通常数目为 CPU 核心数）并在不同处理器上分别执行操作。</p>
<p>同时使用了 <code>parallel()</code> 和 <code>forEachOrdered()</code> 来强制保持原始流顺序。</p>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><ul>
<li><code>collect(Collector)</code>：使用 <strong>Collector</strong> 收集流元素到结果集合中。</li>
<li><code>collect(Supplier, BiConsumer, BiConsumer)</code>：同上，第一个参数 <strong>Supplier</strong> 创建了一个新结果集合，第二个参数 <strong>BiConsumer</strong> 将下一个元素包含到结果中，第三个参数 <strong>BiConsumer</strong> 用于将两个值组合起来。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// streams/TreeSetOfWords.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetOfWords</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">    main(String[] args) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Set&lt;String&gt; words2 =</span><br><span class="line">                Files.lines(Paths.get(<span class="string">&quot;TreeSetOfWords.java&quot;</span>))</span><br><span class="line">                        .flatMap(s -&gt; Arrays.stream(s.split(<span class="string">&quot;\\W+&quot;</span>)))</span><br><span class="line">                        .filter(s -&gt; !s.matches(<span class="string">&quot;\\d+&quot;</span>)) <span class="comment">// No numbers</span></span><br><span class="line">                        .map(String::trim)</span><br><span class="line">                        .filter(s -&gt; s.length() &gt; <span class="number">2</span>)</span><br><span class="line">                        .limit(<span class="number">100</span>)</span><br><span class="line">                        .collect(Collectors.toCollection(TreeSet::<span class="keyword">new</span>));</span><br><span class="line">        System.out.println(words2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// streams/MapCollector.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Character c;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Integer i;</span><br><span class="line">    Pair(Character c, Integer i) &#123;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Character <span class="title">getC</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getI</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Pair(&quot;</span> + c + <span class="string">&quot;, &quot;</span> + i + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomPair</span> </span>&#123;</span><br><span class="line">    Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="comment">// An infinite iterator of random capital letters:</span></span><br><span class="line">    Iterator&lt;Character&gt; capChars = rand.ints(<span class="number">65</span>,<span class="number">91</span>)</span><br><span class="line">            .mapToObj(i -&gt; (<span class="keyword">char</span>)i)</span><br><span class="line">            .iterator();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Stream&lt;Pair&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rand.ints(<span class="number">100</span>, <span class="number">1000</span>).distinct()</span><br><span class="line">                .mapToObj(i -&gt; <span class="keyword">new</span> Pair(capChars.next(), i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapCollector</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Character&gt; map =</span><br><span class="line">                <span class="keyword">new</span> RandomPair().stream()</span><br><span class="line">                        .limit(<span class="number">8</span>)</span><br><span class="line">                        .collect(</span><br><span class="line">                                Collectors.toMap(Pair::getI, Pair::getC));</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><ul>
<li><code>reduce(BinaryOperator)</code>：使用 <strong>BinaryOperator</strong> 来组合所有流中的元素。因为流可能为空，其返回值为 <strong>Optional</strong>。</li>
<li><code>reduce(identity, BinaryOperator)</code>：功能同上，但是使用 <strong>identity</strong> 作为其组合的初始值。因此如果流为空，<strong>identity</strong> 就是结果。</li>
<li><code>reduce(identity, BiFunction, BinaryOperator)</code>：更复杂的使用形式（暂不介绍），这里把它包含在内，因为它可以提高效率。通常，我们可以显式地组合 <code>map()</code> 和 <code>reduce()</code> 来更简单的表达它。</li>
</ul>
<h3 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h3><ul>
<li><code>allMatch(Predicate)</code> ：如果流的每个元素根据提供的 <strong>Predicate</strong> 都返回 true 时，结果返回为 true。在第一个 false 时，则停止执行计算。</li>
<li><code>anyMatch(Predicate)</code>：如果流中的任意一个元素根据提供的 <strong>Predicate</strong> 返回 true 时，结果返回为 true。在第一个 false 是停止执行计算。</li>
<li><code>noneMatch(Predicate)</code>：如果流的每个元素根据提供的 <strong>Predicate</strong> 都返回 false 时，结果返回为 true。在第一个 true 时停止执行计算。</li>
</ul>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><ul>
<li><code>findFirst()</code>：返回第一个流元素的 <strong>Optional</strong>，如果流为空返回 <strong>Optional.empty</strong>。</li>
<li><code>findAny(</code>：返回含有任意流元素的 <strong>Optional</strong>，如果流为空返回 <strong>Optional.empty</strong></li>
</ul>
<h3 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h3><ul>
<li><code>count()</code>：流中的元素个数。</li>
<li><code>max(Comparator)</code>：根据所传入的 <strong>Comparator</strong> 所决定的“最大”元素。</li>
<li><code>min(Comparator)</code>：根据所传入的 <strong>Comparator</strong> 所决定的“最小”元素。</li>
</ul>
<h3 id="数字流信息"><a href="#数字流信息" class="headerlink" title="数字流信息"></a>数字流信息</h3><ul>
<li><code>average()</code> ：求取流元素平均值。</li>
<li><code>max()</code> 和 <code>min()</code>：数值流操作无需 <strong>Comparator</strong>。</li>
<li><code>sum()</code>：对所有流元素进行求和。</li>
<li><code>summaryStatistics()</code>：生成可能有用的数据。目前并不太清楚这个方法存在的必要性，因为我们其实可以用更直接的方法获得需要的数据。</li>
</ul>
<h1 id="CH15-异常"><a href="#CH15-异常" class="headerlink" title="CH15 异常"></a>CH15 异常</h1><h2 id="异常概念"><a href="#异常概念" class="headerlink" title="异常概念"></a>异常概念</h2><p>异常有助于程序的健壮性。</p>
<h2 id="基本异常"><a href="#基本异常" class="headerlink" title="基本异常"></a>基本异常</h2><p>异常情形（exceptional condition）是指阻止当前方法或作用域继续执行的问题。</p>
<h2 id="异常参数"><a href="#异常参数" class="headerlink" title="异常参数"></a>异常参数</h2><p>所有标准异常类都有两个构造器：一个是无参构造器；另一个是接受字符串作为参数，以便能把相关信息放入异常对象的构造器</p>
<p><strong>Throwable</strong> 对象，它是异常类型的根类。</p>
<h2 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h2><p>监控区域：一段可能产生异常的代码，并且后面跟着处理这些异常的代码。</p>
<h3 id="try语句块"><a href="#try语句块" class="headerlink" title="try语句块"></a>try语句块</h3><h3 id="异常处理程序"><a href="#异常处理程序" class="headerlink" title="异常处理程序"></a>异常处理程序</h3><p>catch</p>
<h3 id="终止与恢复"><a href="#终止与恢复" class="headerlink" title="终止与恢复"></a>终止与恢复</h3><p>Java 支持终止模型（它是 Java 和 C++所支持的模型）。在这种模型中，将假设错误非常严重，以至于程序无法返回到异常发生的地方继续执行。一旦异常被抛出，就表明错误已无法挽回，也不能回来继续执行。</p>
<p>另一种称为恢复模型。意思是异常处理程序的工作是修正错误，然后重新尝试调用出问题的方法，并认为第二次能成功。对于恢复模型，通常希望异常被处理之后能继续执行程序。如果想要用 Java 实现类似恢复的行为，那么在遇见错误时就不能抛出异常，而是调用方法来修正该错误。或者，把 try 块放在 while 循环里，这样就不断地进入 try 块，直到得到满意的结果。</p>
<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>要自己定义异常类，必须从已有的异常类继承，最好是选择意思相近的异常类继承（不过这样的异常并不容易找）。</p>
<p>继承Exception类或者子类</p>
<h3 id="异常与记录日志"><a href="#异常与记录日志" class="headerlink" title="异常与记录日志"></a>异常与记录日志</h3><p>静态的 Logger.getLogger() 方法创建了一个 String 参数相关联的 Logger 对象（通常与错误相关的包名和类名），这个 Logger 对象会将其输出发送到 System.err。</p>
<h3 id="异常声明"><a href="#异常声明" class="headerlink" title="异常声明"></a>异常声明</h3><p>异常说明使用了附加的关键字 throws，后面接一个所有潜在异常类型的列表</p>
<h2 id="捕获所有的异常"><a href="#捕获所有的异常" class="headerlink" title="捕获所有的异常"></a>捕获所有的异常</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exceptions/ExceptionMethods.java</span></span><br><span class="line"><span class="comment">// Demonstrating the Exception Methods</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionMethods</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;My Exception&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Caught Exception&quot;</span>);</span><br><span class="line">            System.out.println(</span><br><span class="line">                    <span class="string">&quot;getMessage():&quot;</span> + e.getMessage());</span><br><span class="line">            System.out.println(<span class="string">&quot;getLocalizedMessage():&quot;</span> +</span><br><span class="line">                    e.getLocalizedMessage());</span><br><span class="line">            System.out.println(<span class="string">&quot;toString():&quot;</span> + e);</span><br><span class="line">            System.out.println(<span class="string">&quot;printStackTrace():&quot;</span>);</span><br><span class="line">            e.printStackTrace(System.out);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多重捕获"><a href="#多重捕获" class="headerlink" title="多重捕获"></a>多重捕获</h3><p>使用多个catch语句，不过包括的异常要从小到大。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exceptions/MultiCatch.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiCatch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">x</span><span class="params">()</span> <span class="keyword">throws</span> Except1, Except2, Except3, Except4 </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            x();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span>(Except1 | Except2 | Except3 | Except4 e) &#123;</span><br><span class="line">            process();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="栈轨迹"><a href="#栈轨迹" class="headerlink" title="栈轨迹"></a>栈轨迹</h3><p>printStackTrace() 方法所提供的信息可以通过 getStackTrace() 方法来直接访问，这个方法将返回一个由栈轨迹中的元素所构成的数组，其中每一个元素都表示栈中的一桢。元素 0 是栈顶元素，并且是调用序列中的最后一个方法调用（这个 Throwable 被创建和抛出之处）。数组中的最后一个元素和栈底是调用序列中的第一个方法调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exceptions/WhoCalled.java</span></span><br><span class="line"><span class="comment">// Programmatic access to stack trace information</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhoCalled</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// Generate an exception to fill in the stack trace</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            <span class="keyword">for</span>(StackTraceElement ste : e.getStackTrace())</span><br><span class="line">                System.out.println(ste.getMethodName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; f(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123; g(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        f();</span><br><span class="line">        System.out.println(<span class="string">&quot;*******&quot;</span>);</span><br><span class="line">        g();</span><br><span class="line">        System.out.println(<span class="string">&quot;*******&quot;</span>);</span><br><span class="line">        h();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重新抛出异常"><a href="#重新抛出异常" class="headerlink" title="重新抛出异常"></a>重新抛出异常</h3><p>如果只是把当前异常对象重新抛出，那么 printStackTrace() 方法显示的将是原来异常抛出点的调用栈信息，而并非重新抛出点的信息。要想更新这个信息，可以调用 filInStackTrace() 方法，这将返回一个 Throwable 对象，它是通过把当前调用栈信息填入原来那个异常对象而建立的</p>
<p>调用 fillInStackTrace() 的那一行就成了异常的新发生地了。</p>
<h3 id="异常链"><a href="#异常链" class="headerlink" title="异常链"></a>异常链</h3><p>常常会想要在捕获一个异常后抛出另一个异常，并且希望把原始异常的信息保存下来，这被称为异常链。</p>
<p>在 JDK1.4 以前，程序员必须自己编写代码来保存原始异常的信息。现在所有 Throwable 的子类在构造器中都可以接受一个 cause（因由）对象作为参数。这个 cause 就用来表示原始异常，这样通过把原始异常传递给新的异常，使得即使在当前位置创建并抛出了新的异常，也能通过这个异常链追踪到异常最初发生的位置。</p>
<p>有趣的是，在 Throwable 的子类中，只有三种基本的异常类提供了带 cause 参数的构造器。它们是 Error（用于 Java 虚拟机报告系统错误）、Exception 以及 RuntimeException。</p>
<h2 id="Java标准异常"><a href="#Java标准异常" class="headerlink" title="Java标准异常"></a>Java标准异常</h2><p>Throwable 这个 Java 类被用来表示任何可以作为异常被抛出的类。Throwable 对象可分为两种类型（指从 Throwable 继承而得到的类型）：Error 用来表示编译时和系统错误（除特殊情况外，一般不用你关心）；Exception 是可以被抛出的基本类型，在 Java 类库、用户方法以及运行时故障中都可能抛出 Exception 型异常。所以 Java 程序员关心的基类型通常是 Exception。</p>
<h3 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h3><p>RuntimeException 代表的是编程错误：</p>
<ol>
<li>无法预料的错误。比如从你控制范围之外传递进来的 null 引用。</li>
<li>作为程序员，应该在代码中进行检查的错误。（比如对于 ArrayIndexOutOfBoundsException，就得注意一下数组的大小了。）在一个地方发生的异常，常常会在另一个地方导致错误。</li>
</ol>
<h2 id="Finally"><a href="#Finally" class="headerlink" title="Finally"></a>Finally</h2><p>有一些代码片段，可能会希望无论 try 块中的异常是否抛出，它们都能得到执行。这通常适用于内存回收之外的情况（因为回收由垃圾回收器完成），为了达到这个效果，可以在异常处理程序后面加上 finally 子句。</p>
<h3 id="在return中使用finally"><a href="#在return中使用finally" class="headerlink" title="在return中使用finally"></a>在return中使用finally</h3><p>因为 finally 子句总是会执行，所以可以从一个方法内的多个点返回，仍然能保证重要的清理工作会执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exceptions/MultipleReturns.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultipleReturns</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        System.out.println(</span><br><span class="line">                <span class="string">&quot;Initialization that requires cleanup&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Point 1&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;Point 2&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;Point 3&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">3</span>) <span class="keyword">return</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;End&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Performing cleanup&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++)</span><br><span class="line">            f(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异常限制"><a href="#异常限制" class="headerlink" title="异常限制"></a>异常限制</h2><p>当覆盖方法的时候，只能抛出在基类方法的异常说明里列出的那些异常。这个限制很有用，因为这意味着，若当基类使用的代码应用到其派生类对象的时候，一样能够工作（当然，这是面向对象的基本概念），异常也不例外。</p>
<h2 id="构造器异常"><a href="#构造器异常" class="headerlink" title="构造器异常"></a>构造器异常</h2><h2 id="Try-With-Resource用法"><a href="#Try-With-Resource用法" class="headerlink" title="Try-With-Resource用法"></a>Try-With-Resource用法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exceptions/TryWithResources.java</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryWithResources</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">                InputStream in = <span class="keyword">new</span> FileInputStream(</span><br><span class="line">                        <span class="keyword">new</span> File(<span class="string">&quot;TryWithResources.java&quot;</span>))</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">int</span> contents = in.read();</span><br><span class="line">            <span class="comment">// Process contents</span></span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">            <span class="comment">// Handle the error</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 try-with-resources 定义子句中创建的对象（在括号内）必须实现 java.lang.AutoCloseable 接口，这个接口有一个方法：close()。当在 Java 7 中引入 AutoCloseable 时，许多接口和类被修改以实现它；</p>
<h3 id="揭示细节"><a href="#揭示细节" class="headerlink" title="揭示细节"></a>揭示细节</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exceptions/AutoCloseableDetails.java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reporter</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line">    String name = getClass().getSimpleName();</span><br><span class="line">    Reporter() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Creating &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Closing &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">First</span> <span class="keyword">extends</span> <span class="title">Reporter</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Second</span> <span class="keyword">extends</span> <span class="title">Reporter</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoCloseableDetails</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">                First f = <span class="keyword">new</span> First();</span><br><span class="line">                Second s = <span class="keyword">new</span> Second()</span><br><span class="line">        ) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Creating <span class="built_in">First</span></span><br><span class="line">Creating <span class="built_in">Second</span></span><br><span class="line">Closing <span class="built_in">Second</span></span><br><span class="line">Closing <span class="built_in">First</span></span><br></pre></td></tr></table></figure>

<p>退出 try 块会调用两个对象的 close() 方法，并以与创建顺序相反的顺序关闭它们。</p>
<h1 id="CH16-代码校验"><a href="#CH16-代码校验" class="headerlink" title="CH16  代码校验"></a>CH16  代码校验</h1><h2 id="JUnit"><a href="#JUnit" class="headerlink" title="JUnit"></a>JUnit</h2><p>在 JUnit 最简单的使用中，使用 <strong>@Test</strong> 注解标记表示测试的每个方法。JUnit 将这些方法标识为单独的测试，并一次设置和运行一个测试，采取措施避免测试之间的副作用。</p>
<p><strong>@BeforeAll</strong> 注解是在任何其他测试操作之前运行一次的方法。 <strong>@AfterAll</strong> 是所有其他测试操作之后只运行一次的方法。两个方法都必须是静态的。</p>
<p><strong>@BeforeEach</strong>注解是通常用于创建和初始化公共对象的方法，并在每次测试前运行。可以将所有这样的初始化放在测试类的构造函数中，尽管我认为 <strong>@BeforeEach</strong> 更加清晰。JUnit为每个测试创建一个对象，确保测试运行之间没有副作用。然而，所有测试的所有对象都是同时创建的(而不是在测试之前创建对象)，所以使用 <strong>@BeforeEach</strong> 和构造函数之间的唯一区别是 <strong>@BeforeEach</strong> 在测试前直接调用。在大多数情况下，这不是问题，如果你愿意，可以使用构造函数方法。</p>
<p>如果你必须在每次测试后执行清理（如果修改了需要恢复的静态文件，打开文件需要关闭，打开数据库或者网络连接，etc），那就用注解 <strong>@AfterEach</strong>。</p>
<p>每个测试创建一个新的 <strong>CountedListTest</strong> 对象，任何非静态成员变量也会在同一时间创建。然后为每个测试调用 <strong>initialize()</strong> ，于是 list 被赋值为一个新的用字符串“0”、“1” 和 “2” 初始化的 <strong>CountedList</strong> 对象。观察 <strong>@BeforeEach</strong> 和 <strong>@AfterEach</strong> 的行为，这些方法在初始化和清理测试时显示有关测试的信息。</p>
<h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><p>前置条件的概念来自于契约式设计(<strong>Design By Contract, DbC</strong>), 利用断言机制实现。</p>
<h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>断言通过验证在程序执行期间满足某些条件，从而增加了程序的健壮性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// validating/Assert1.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Non-informative style of assert</span></span><br><span class="line"><span class="comment">// Must run using -ea flag:</span></span><br><span class="line"><span class="comment">// &#123;java -ea Assert1&#125;</span></span><br><span class="line"><span class="comment">// &#123;ThrowsException&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Assert1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">___[ Error Output ]___</span></span><br><span class="line"><span class="comment">Exception in thread &quot;main&quot; java.lang.AssertionError</span></span><br><span class="line"><span class="comment">at Assert1.main(Assert1.java:9)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>如果你正常运行程序，没有任何特殊的断言标志，则不会发生任何事情。你需要在运行程序时显式启用断言。一种简单的方法是使用 <strong>-ea</strong> 标志， 它也可以表示为: <strong>-enableassertion</strong>， 这将运行程序并执行任何断言语句。</p>
<p>输出中并没有包含多少有用的信息。另一方面，如果你使用 <strong>information-expression</strong> ， 将生成一条有用的消息作为异常堆栈跟踪的一部分。最有用的 <strong>information-expression</strong> 通常是一串针对程序员的文本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// validating/Assert2.java</span></span><br><span class="line"><span class="comment">// Assert with an information-expression</span></span><br><span class="line"><span class="comment">// &#123;java Assert2 -ea&#125;</span></span><br><span class="line"><span class="comment">// &#123;ThrowsException&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Assert2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> <span class="keyword">false</span>:</span><br><span class="line">    <span class="string">&quot;Here&#x27;s a message saying what happened&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">___[ Error Output ]___</span></span><br><span class="line"><span class="comment">Exception in thread &quot;main&quot; java.lang.AssertionError:</span></span><br><span class="line"><span class="comment">Here&#x27;s a message saying what happened</span></span><br><span class="line"><span class="comment">at Assert2.main(Assert2.java:8)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="Ch17-文件"><a href="#Ch17-文件" class="headerlink" title="Ch17 文件"></a>Ch17 文件</h1><p>我们将看一下文件操作的两个基本组件：</p>
<ol>
<li>文件或者目录的路径；</li>
<li>文件本身。</li>
</ol>
<h2 id="文件和目录路径"><a href="#文件和目录路径" class="headerlink" title="文件和目录路径"></a>文件和目录路径</h2><p>一个 <strong>Path</strong> 对象表示一个文件或者目录的路径，是一个跨操作系统（OS）和文件系统的抽象，目的是在构造路径时不必关注底层操作系统，代码可以在不进行修改的情况下运行在不同的操作系统上。<strong>java.nio.file.Paths</strong> 类包含一个重载方法 <strong>static get()**，该方法接受一系列 **String</strong> 字符串或一个<em>统一资源标识符</em>(URI)作为参数，并且进行转换返回一个 <strong>Path</strong> 对象</p>
<h3 id="选取路径部分片段"><a href="#选取路径部分片段" class="headerlink" title="选取路径部分片段"></a>选取路径部分片段</h3><p>可以通过 <strong>getName()</strong> 来索引 <strong>Path</strong> 的各个部分，直到达到上限 <strong>getNameCount()**。</strong>Path** 也实现了 <strong>Iterable</strong> 接口，因此我们也可以通过增强的 for-each 进行遍历。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Paths.get(<span class="string">&quot;src/main/text.txt&quot;</span>).toAbsolutePath()</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line"><span class="comment">//        System.out.println(path.toString());</span></span><br><span class="line"><span class="comment">//        Files.readAllLines(path).forEach(System.out::println);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="路径分析"><a href="#路径分析" class="headerlink" title="路径分析"></a>路径分析</h3><p><strong>Files</strong> 工具类包含一系列完整的方法用于获得 <strong>Path</strong> 相关的信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// files/PathAnalysis.java</span></span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathAnalysis</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String id, Object result)</span> </span>&#123;</span><br><span class="line">        System.out.print(id + <span class="string">&quot;: &quot;</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(System.getProperty(<span class="string">&quot;os.name&quot;</span>));</span><br><span class="line">        Path p = Paths.get(<span class="string">&quot;PathAnalysis.java&quot;</span>).toAbsolutePath();</span><br><span class="line">        say(<span class="string">&quot;Exists&quot;</span>, Files.exists(p));</span><br><span class="line">        say(<span class="string">&quot;Directory&quot;</span>, Files.isDirectory(p));</span><br><span class="line">        say(<span class="string">&quot;Executable&quot;</span>, Files.isExecutable(p));</span><br><span class="line">        say(<span class="string">&quot;Readable&quot;</span>, Files.isReadable(p));</span><br><span class="line">        say(<span class="string">&quot;RegularFile&quot;</span>, Files.isRegularFile(p));</span><br><span class="line">        say(<span class="string">&quot;Writable&quot;</span>, Files.isWritable(p));</span><br><span class="line">        say(<span class="string">&quot;notExists&quot;</span>, Files.notExists(p));</span><br><span class="line">        say(<span class="string">&quot;Hidden&quot;</span>, Files.isHidden(p));</span><br><span class="line">        say(<span class="string">&quot;size&quot;</span>, Files.size(p));</span><br><span class="line">        say(<span class="string">&quot;FileStore&quot;</span>, Files.getFileStore(p));</span><br><span class="line">        say(<span class="string">&quot;LastModified: &quot;</span>, Files.getLastModifiedTime(p));</span><br><span class="line">        say(<span class="string">&quot;Owner&quot;</span>, Files.getOwner(p));</span><br><span class="line">        say(<span class="string">&quot;ContentType&quot;</span>, Files.probeContentType(p));</span><br><span class="line">        say(<span class="string">&quot;SymbolicLink&quot;</span>, Files.isSymbolicLink(p));</span><br><span class="line">        <span class="keyword">if</span>(Files.isSymbolicLink(p))</span><br><span class="line">            say(<span class="string">&quot;SymbolicLink&quot;</span>, Files.readSymbolicLink(p));</span><br><span class="line">        <span class="keyword">if</span>(FileSystems.getDefault().supportedFileAttributeViews().contains(<span class="string">&quot;posix&quot;</span>))</span><br><span class="line">            say(<span class="string">&quot;PosixFilePermissions&quot;</span>,</span><br><span class="line">        Files.getPosixFilePermissions(p));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出:</span></span><br><span class="line"><span class="comment">Windows 10</span></span><br><span class="line"><span class="comment">Exists: true</span></span><br><span class="line"><span class="comment">Directory: false</span></span><br><span class="line"><span class="comment">Executable: true</span></span><br><span class="line"><span class="comment">Readable: true</span></span><br><span class="line"><span class="comment">RegularFile: true</span></span><br><span class="line"><span class="comment">Writable: true</span></span><br><span class="line"><span class="comment">notExists: false</span></span><br><span class="line"><span class="comment">Hidden: false</span></span><br><span class="line"><span class="comment">size: 1631</span></span><br><span class="line"><span class="comment">FileStore: SSD (C:)</span></span><br><span class="line"><span class="comment">LastModified: : 2017-05-09T12:07:00.428366Z</span></span><br><span class="line"><span class="comment">Owner: MINDVIEWTOSHIBA\Bruce (User)</span></span><br><span class="line"><span class="comment">ContentType: null</span></span><br><span class="line"><span class="comment">SymbolicLink: false</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="Paths的增删修改"><a href="#Paths的增删修改" class="headerlink" title="Paths的增删修改"></a>Paths的增删修改</h3><p>我们必须能通过对 <strong>Path</strong> 对象增加或者删除一部分来构造一个新的 <strong>Path</strong> 对象。我们使用 <strong>relativize()</strong> 移除 <strong>Path</strong> 的根路径，使用 <strong>resolve()</strong> 添加 <strong>Path</strong> 的尾路径(不一定是“可发现”的名称)。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>删除目录树：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/RmDir.java</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.attribute.BasicFileAttributes;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RmDir</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rmdir</span><span class="params">(Path dir)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Files.walkFileTree(dir, <span class="keyword">new</span> SimpleFileVisitor&lt;Path&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                Files.delete(file);</span><br><span class="line">                <span class="keyword">return</span> FileVisitResult.CONTINUE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">postVisitDirectory</span><span class="params">(Path dir, IOException exc)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                Files.delete(dir);</span><br><span class="line">                <span class="keyword">return</span> FileVisitResult.CONTINUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除目录树的方法实现依赖于 <strong>Files.walkFileTree()*<em>，”walking” 目录树意味着遍历每个子目录和文件。</em>Visitor* 设计模式提供了一种标准机制来访问集合中的每个对象，然后你需要提供在每个对象上执行的操作。 此操作的定义取决于实现的 **FileVisitor</strong> 的四个抽象方法，包括：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>  **preVisitDirectory()**：在访问目录中条目之前在目录上运行。 </span><br><span class="line"><span class="number">2.</span>  **visitFile()**：运行目录中的每一个文件。  </span><br><span class="line"><span class="number">3.</span>  **visitFileFailed()**：调用无法访问的文件。   </span><br><span class="line"><span class="number">4.</span>  **postVisitDirectory()**：在访问目录中条目之后在目录上运行，包括所有的子目录</span><br></pre></td></tr></table></figure>

<p>为了简化，<strong>java.nio.file.SimpleFileVisitor</strong> 提供了所有方法的默认实现。这样，在我们的匿名内部类中，我们只需要重写非标准行为的方法：<strong>visitFile()</strong> 和 <strong>postVisitDirectory()</strong> 实现删除文件和删除目录。两者都应该返回标志位决定是否继续访问(这样就可以继续访问，直到找到所需要的)。</p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>为了完整起见，我们需要一种方法查找文件系统相关的其他信息。在这里，我们使用静态的 <strong>FileSystems</strong> 工具类获取”默认”的文件系统，但你同样也可以在 <strong>Path</strong> 对象上调用 <strong>getFileSystem()</strong> 以获取创建该 <strong>Path</strong> 的文件系统。你可以获得给定 <em>URI</em> 的文件系统，还可以构建新的文件系统(对于支持它的操作系统)。</p>
<p>一个 <strong>FileSystem</strong> 对象也能生成 <strong>WatchService</strong> 和 <strong>PathMatcher</strong> 对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// files/FileSystemDemo.java</span></span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSystemDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String id, Object o)</span> </span>&#123;</span><br><span class="line">        System.out.println(id + <span class="string">&quot;: &quot;</span> + o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(System.getProperty(<span class="string">&quot;os.name&quot;</span>));</span><br><span class="line">        FileSystem fsys = FileSystems.getDefault();</span><br><span class="line">        <span class="keyword">for</span>(FileStore fs : fsys.getFileStores())</span><br><span class="line">            show(<span class="string">&quot;File Store&quot;</span>, fs);</span><br><span class="line">        <span class="keyword">for</span>(Path rd : fsys.getRootDirectories())</span><br><span class="line">            show(<span class="string">&quot;Root Directory&quot;</span>, rd);</span><br><span class="line">        show(<span class="string">&quot;Separator&quot;</span>, fsys.getSeparator());</span><br><span class="line">        show(<span class="string">&quot;UserPrincipalLookupService&quot;</span>,</span><br><span class="line">            fsys.getUserPrincipalLookupService());</span><br><span class="line">        show(<span class="string">&quot;isOpen&quot;</span>, fsys.isOpen());</span><br><span class="line">        show(<span class="string">&quot;isReadOnly&quot;</span>, fsys.isReadOnly());</span><br><span class="line">        show(<span class="string">&quot;FileSystemProvider&quot;</span>, fsys.provider());</span><br><span class="line">        show(<span class="string">&quot;File Attribute Views&quot;</span>,</span><br><span class="line">        fsys.supportedFileAttributeViews());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出:</span></span><br><span class="line"><span class="comment">Windows 10</span></span><br><span class="line"><span class="comment">File Store: SSD (C:)</span></span><br><span class="line"><span class="comment">Root Directory: C:\</span></span><br><span class="line"><span class="comment">Root Directory: D:\</span></span><br><span class="line"><span class="comment">Separator: \</span></span><br><span class="line"><span class="comment">UserPrincipalLookupService:</span></span><br><span class="line"><span class="comment">sun.nio.fs.WindowsFileSystem$LookupService$1@15db9742</span></span><br><span class="line"><span class="comment">isOpen: true</span></span><br><span class="line"><span class="comment">isReadOnly: false</span></span><br><span class="line"><span class="comment">FileSystemProvider:</span></span><br><span class="line"><span class="comment">sun.nio.fs.WindowsFileSystemProvider@6d06d69c</span></span><br><span class="line"><span class="comment">File Attribute Views: [owner, dos, acl, basic, user]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="路径监听"><a href="#路径监听" class="headerlink" title="路径监听"></a>路径监听</h2><p>通过 <strong>WatchService</strong> 可以设置一个进程对目录中的更改做出响应。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException</span>&#123;</span><br><span class="line">        Path path = Paths.get(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        WatchService service = FileSystems.getDefault().newWatchService();</span><br><span class="line">        path.register(service, StandardWatchEventKinds.ENTRY_CREATE);</span><br><span class="line">        WatchKey key = service.take();</span><br><span class="line">        <span class="keyword">for</span> (WatchEvent event: key.pollEvents()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;event.context(): &quot;</span> + event.context()</span><br><span class="line">            + <span class="string">&quot;\nevent.count(): &quot;</span> + event.count()</span><br><span class="line">            + <span class="string">&quot;\nevent.kind(): &quot;</span> + event.kind());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只会监视给定的目录，而不是下面的所有内容。如果需要监视整个树目录，必须在整个树的每个子目录上放置一个 <strong>Watchservice</strong>。</p>
<h2 id="文件查找"><a href="#文件查找" class="headerlink" title="文件查找"></a>文件查找</h2><p>通过在 <code>FileSystem</code> 对象上调用 <code>getPathMatcher()</code> 获得一个 <code>PathMatcher</code>，然后传入您感兴趣的模式。模式有两个选项：<code>glob</code> 和 <code>regex</code>。<code>glob</code> 比较简单，实际上功能非常强大，因此您可以使用 <code>glob</code> 解决许多问题。如果您的问题更复杂，可以使用 <code>regex</code>，这将在接下来的 <code>Strings</code> 一章中解释。</p>
<p>在这里，我们使用 <code>glob</code> 查找以 <code>.java 或 </code>.txt<code>结尾的所有</code>Path`：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> Demo &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) throws IOException, InterruptedException&#123;</span><br><span class="line">        <span class="keyword">Path</span> <span class="keyword">path</span> = Paths.<span class="keyword">get</span>(&quot;.&quot;);</span><br><span class="line">        PathMatcher matcher = FileSystems.getDefault()</span><br><span class="line">                .getPathMatcher(&quot;glob:**/*.&#123;java,txt&#125;&quot;);</span><br><span class="line">        Files.walk(<span class="type">path</span>)</span><br><span class="line">                .<span class="keyword">filter</span>(matcher::matches)</span><br><span class="line">                .<span class="keyword">forEach</span>(<span class="keyword">System</span>.<span class="keyword">out</span>::println);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>matcher</code> 中，<code>glob</code> 表达式开头的 <code>**/</code> 表示“当前目录及所有子目录”，这在当你不仅仅要匹配当前目录下特定结尾的 <code>Path</code> 时非常有用。单 <code>*</code> 表示“任何东西”，然后是一个点，然后大括号表示一系列的可能性</p>
<h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><p>此时，我们可以对路径和目录做任何事情。 现在让我们看一下操纵文件本身的内容。</p>
<p>如果一个文件很“小”，也就是说“它运行得足够快且占用内存小”，那么 <code>java.nio.file.Files</code> 类中的实用程序将帮助你轻松读写文本和二进制文件。</p>
<p><code>Files.readAllLines()</code> 一次读取整个文件（因此，“小”文件很有必要），产生一个<code>List</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// files/ListOfLines.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListOfLines</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Files.readAllLines(</span><br><span class="line">        Paths.get(<span class="string">&quot;../streams/Cheese.dat&quot;</span>))</span><br><span class="line">        .stream()</span><br><span class="line">        .filter(line -&gt; !line.startsWith(<span class="string">&quot;//&quot;</span>))</span><br><span class="line">        .map(line -&gt;</span><br><span class="line">            line.substring(<span class="number">0</span>, line.length()/<span class="number">2</span>))</span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Not much of a cheese</span></span><br><span class="line"><span class="comment">Finest in the</span></span><br><span class="line"><span class="comment">And what leads you</span></span><br><span class="line"><span class="comment">Well, it&#x27;s</span></span><br><span class="line"><span class="comment">It&#x27;s certainly uncon</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><code>Files.write()</code> 被重载以写入 <code>byte</code> 数组或任何 <code>Iterable</code> 对象（它也有 <code>Charset</code> 选项）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// files/Writing.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Writing</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// Write bytes to a file:</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[SIZE];</span><br><span class="line">        rand.nextBytes(bytes);</span><br><span class="line">        Files.write(Paths.get(<span class="string">&quot;bytes.dat&quot;</span>), bytes);</span><br><span class="line">        System.out.println(<span class="string">&quot;bytes.dat: &quot;</span> + Files.size(Paths.get(<span class="string">&quot;bytes.dat&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write an iterable to a file:</span></span><br><span class="line">        List&lt;String&gt; lines = Files.readAllLines(</span><br><span class="line">          Paths.get(<span class="string">&quot;../streams/Cheese.dat&quot;</span>));</span><br><span class="line">        Files.write(Paths.get(<span class="string">&quot;Cheese.txt&quot;</span>), lines);</span><br><span class="line">        System.out.println(<span class="string">&quot;Cheese.txt: &quot;</span> + Files.size(Paths.get(<span class="string">&quot;Cheese.txt&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">bytes.dat: 1000</span></span><br><span class="line"><span class="comment">Cheese.txt: 199</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>如果文件大小有问题怎么办？ 比如说：</p>
<ol>
<li>文件太大，如果你一次性读完整个文件，你可能会耗尽内存。</li>
<li>您只需要在文件的中途工作以获得所需的结果，因此读取整个文件会浪费时间。</li>
</ol>
<p><code>Files.lines()</code> 方便地将文件转换为行的 <code>Stream</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// files/ReadLineStream.java</span></span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLineStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Files.lines(Paths.get(<span class="string">&quot;PathInfo.java&quot;</span>))</span><br><span class="line">          .skip(<span class="number">13</span>)</span><br><span class="line">          .findFirst()</span><br><span class="line">          .ifPresent(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">    show(&quot;RegularFile&quot;, Files.isRegularFile(p));</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">crazyStrome</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://crazystrome.github.io/2020/11/04/OnJava8%E7%AC%94%E8%AE%B0/">http://crazystrome.github.io/2020/11/04/OnJava8%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://crazyStrome.github.io" target="_blank">crazyStrome的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/11/04/Redis%E8%BF%90%E7%BB%B4-%E6%8C%81%E4%B9%85%E5%8C%96/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info"></div></div></a></div><div class="next-post pull-right"><a href="/2020/11/04/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info"></div></div></a></div></nav></article></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 By crazyStrome</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>