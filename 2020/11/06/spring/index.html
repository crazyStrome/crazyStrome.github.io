<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Spring官方文档笔记 | crazyStrome的博客</title><meta name="keywords" content="Java,笔记,Spring"><meta name="author" content="crazyStrome"><meta name="copyright" content="crazyStrome"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="1.  IoC容器1.1.  Spring IoC容器和Beans简介控制反转也称为依赖注入。它是一个process，其中object仅通过构造函数arguments，工厂方法的arguments或者属性的properties来定义它们的依赖项。 org.springframework.beans和org.springframework.context包是 Spring Framework 的 I">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring官方文档笔记">
<meta property="og:url" content="http://crazystrome.github.io/2020/11/06/spring/index.html">
<meta property="og:site_name" content="crazyStrome的博客">
<meta property="og:description" content="1.  IoC容器1.1.  Spring IoC容器和Beans简介控制反转也称为依赖注入。它是一个process，其中object仅通过构造函数arguments，工厂方法的arguments或者属性的properties来定义它们的依赖项。 org.springframework.beans和org.springframework.context包是 Spring Framework 的 I">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://dzone.com/storage/temp/12434118-spring-boot-logo.png">
<meta property="article:published_time" content="2020-11-06T02:40:51.725Z">
<meta property="article:modified_time" content="2020-10-14T16:00:00.000Z">
<meta property="article:author" content="crazyStrome">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="笔记">
<meta property="article:tag" content="Spring">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://dzone.com/storage/temp/12434118-spring-boot-logo.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://crazystrome.github.io/2020/11/06/spring/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.2.0',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isSidebar: true,
  postUpdate: '2020-10-15 00:00:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {
  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }

  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }
})()</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://avatars2.githubusercontent.com/u/24493607?s=460&amp;u=ae13dfdaed519e38912080c57dd919504d032754&amp;v=4" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">32</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">18</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-IoC%E5%AE%B9%E5%99%A8"><span class="toc-number">1.</span> <span class="toc-text">1.  IoC容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-Spring-IoC%E5%AE%B9%E5%99%A8%E5%92%8CBeans%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">1.1.  Spring IoC容器和Beans简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.</span> <span class="toc-text">1.2.  容器概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-Configuration%E5%85%83%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.2.1.  Configuration元数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AE%B9%E5%99%A8"><span class="toc-number">1.2.2.</span> <span class="toc-text">1.2.2.  实例化容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-3-%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8"><span class="toc-number">1.2.3.</span> <span class="toc-text">1.2.3.  使用容器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-Bean%E6%A6%82%E8%BF%B0"><span class="toc-number">1.3.</span> <span class="toc-text">1.3.  Bean概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-%E5%91%BD%E5%90%8DBeans"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.3.1.  命名Beans</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-%E5%AE%9E%E4%BE%8B%E5%8C%96Beans"><span class="toc-number">1.3.2.</span> <span class="toc-text">1.3.2.  实例化Beans</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E4%BE%9D%E8%B5%96"><span class="toc-number">1.4.</span> <span class="toc-text">1.4.  依赖</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-1-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.4.1.  依赖注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-3-%E4%BD%BF%E7%94%A8depends-on"><span class="toc-number">1.4.2.</span> <span class="toc-text">1.4.3.  使用depends-on</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-4-Lazy-initialized-Beans"><span class="toc-number">1.4.3.</span> <span class="toc-text">1.4.4.  Lazy-initialized Beans</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-5-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D"><span class="toc-number">1.4.4.</span> <span class="toc-text">1.4.5.  自动装配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-6-%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5"><span class="toc-number">1.4.5.</span> <span class="toc-text">1.4.6.  方法注入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">查找方法注入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E6%96%B9%E6%B3%95%E6%9B%BF%E6%8D%A2"><span class="toc-number">1.4.5.2.</span> <span class="toc-text">任意方法替换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-Bean%E8%8C%83%E5%9B%B4"><span class="toc-number">1.5.</span> <span class="toc-text">1.5.  Bean范围</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-1-Singleton%E8%8C%83%E5%9B%B4"><span class="toc-number">1.5.1.</span> <span class="toc-text">1.5.1.  Singleton范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-2-prototype%E8%8C%83%E5%9B%B4"><span class="toc-number">1.5.2.</span> <span class="toc-text">1.5.2.  prototype范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-3-%E5%B8%A6%E6%9C%89prototype-bean%E4%BE%9D%E8%B5%96%E7%9A%84%E5%8D%95%E4%BE%8Bbean"><span class="toc-number">1.5.3.</span> <span class="toc-text">1.5.3.  带有prototype-bean依赖的单例bean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-4-Request%EF%BC%8CSession%EF%BC%8CApplication-%E5%92%8C-WebSocket-Scopes"><span class="toc-number">1.5.4.</span> <span class="toc-text">1.5.4.  Request，Session，Application 和 WebSocket Scopes</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Request"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">Request</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Session"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">Session</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Application"><span class="toc-number">1.5.4.3.</span> <span class="toc-text">Application</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-5-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%8C%83%E5%9B%B4"><span class="toc-number">1.5.5.</span> <span class="toc-text">1.5.5.  自定义范围</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-%E8%87%AA%E5%AE%9A%E4%B9%89Bean%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">1.6.</span> <span class="toc-text">1.6.  自定义Bean的性质</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-1-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%9E%E8%B0%83"><span class="toc-number">1.6.1.</span> <span class="toc-text">1.6.1.  生命周期回调</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9B%9E%E8%B0%83"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">初始化回调</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%80%E6%AF%81%E5%9B%9E%E8%B0%83"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">销毁回调</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%92%8C%E5%85%B3%E9%97%AD%E5%9B%9E%E8%B0%83%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.1.3.</span> <span class="toc-text">启动和关闭回调方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-2-ApplicationContextAware%E5%92%8CBeanNameAware"><span class="toc-number">1.6.2.</span> <span class="toc-text">1.6.2.  ApplicationContextAware和BeanNameAware</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-Bean%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF"><span class="toc-number">1.7.</span> <span class="toc-text">1.7.  Bean定义继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-8-%E9%9B%86%E8%A3%85%E7%AE%B1%E6%89%A9%E5%BB%BA%E7%82%B9"><span class="toc-number">1.8.</span> <span class="toc-text">1.8.  集装箱扩建点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-1-%E4%BD%BF%E7%94%A8-BeanPostProcessor-%E8%87%AA%E5%AE%9A%E4%B9%89-Beans"><span class="toc-number">1.8.1.</span> <span class="toc-text">1.8.1.  使用 BeanPostProcessor 自定义 Beans</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-9-Annotation-based-Container-Configuration"><span class="toc-number">1.9.</span> <span class="toc-text">1.9.  Annotation-based Container Configuration</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-9-1-Required"><span class="toc-number">1.9.1.</span> <span class="toc-text">1.9.1.  @Required</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-9-2-%E4%BD%BF%E7%94%A8-Autowired"><span class="toc-number">1.9.2.</span> <span class="toc-text">1.9.2.  使用@Autowired</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-9-5-%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E4%BD%9C%E4%B8%BA%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-number">1.9.3.</span> <span class="toc-text">1.9.5.  使用泛型作为自动装配限定符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-9-6-%E4%BD%BF%E7%94%A8-CustomAutowireConfigurer"><span class="toc-number">1.9.4.</span> <span class="toc-text">1.9.6. 使用 CustomAutowireConfigurer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-9-7-%E6%B3%A8%E5%B0%84-Resource"><span class="toc-number">1.9.5.</span> <span class="toc-text">1.9.7.  注射@Resource</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-9-8-%E4%BD%BF%E7%94%A8-PostConstruct%E5%92%8C-PreDestory"><span class="toc-number">1.9.6.</span> <span class="toc-text">1.9.8.  使用@PostConstruct和@PreDestory</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-10-Classpath%E6%89%AB%E6%8F%8F%E5%92%8C%E6%89%98%E7%AE%A1%E7%BB%84%E4%BB%B6"><span class="toc-number">1.10.</span> <span class="toc-text">1.10.  Classpath扫描和托管组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-10-1-Component%E5%92%8C%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%9A%84%E5%88%BB%E6%9D%BF%E5%8D%B0%E8%B1%A1%E6%B3%A8%E9%87%8A"><span class="toc-number">1.10.1.</span> <span class="toc-text">1.10.1.  @Component和进一步的刻板印象注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-10-2-%E4%BD%BF%E7%94%A8-Meta-annotations-%E5%92%8C-Composed-Annotations"><span class="toc-number">1.10.2.</span> <span class="toc-text">1.10.2.  使用 Meta-annotations 和 Composed Annotations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-10-3-%E8%87%AA%E5%8A%A8%E6%A3%80%E6%B5%8B-Classes-%E5%B9%B6%E6%B3%A8%E5%86%8C-Bean-%E5%AE%9A%E4%B9%89"><span class="toc-number">1.10.3.</span> <span class="toc-text">1.10.3.  自动检测 Classes 并注册 Bean 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-10-4-%E4%BD%BF%E7%94%A8%E8%BF%87%E6%BB%A4%E5%99%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%89%AB%E6%8F%8F"><span class="toc-number">1.10.4.</span> <span class="toc-text">1.10.4.  使用过滤器自定义扫描</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-10-5-%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%AD%E5%AE%9A%E4%B9%89-Bean-%E5%85%83%E6%95%B0%E6%8D%AE"><span class="toc-number">1.10.5.</span> <span class="toc-text">1.10.5.  在组件中定义 Bean 元数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-10-6-%E8%87%AA%E5%8A%A8%E6%A3%80%E6%B5%8B%E5%91%BD%E5%90%8D%E7%9A%84%E7%BB%84%E4%BB%B6"><span class="toc-number">1.10.6.</span> <span class="toc-text">1.10.6.  自动检测命名的组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-10-7-%E4%B8%BA%E8%87%AA%E5%8A%A8%E6%A3%80%E6%B5%8B%E7%BB%84%E4%BB%B6%E6%8F%90%E4%BE%9Bscope"><span class="toc-number">1.10.7.</span> <span class="toc-text">1.10.7.  为自动检测组件提供scope</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-10-8-%E4%BD%BF%E7%94%A8-Annotations-%E6%8F%90%E4%BE%9B%E9%99%90%E5%AE%9A%E7%AC%A6%E5%85%83%E6%95%B0%E6%8D%AE"><span class="toc-number">1.10.8.</span> <span class="toc-text">1.10.8.  使用 Annotations 提供限定符元数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-10-9-%E7%94%9F%E6%88%90%E5%80%99%E9%80%89%E7%BB%84%E4%BB%B6%E7%B4%A2%E5%BC%95"><span class="toc-number">1.10.9.</span> <span class="toc-text">1.10.9.  生成候选组件索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-12-%E4%BD%BF%E7%94%A8java%E7%9A%84%E5%AE%B9%E5%99%A8%E9%85%8D%E7%BD%AE"><span class="toc-number">1.11.</span> <span class="toc-text">1.12.  使用java的容器配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-12-1-Bean%E5%92%8C-Configuration"><span class="toc-number">1.11.1.</span> <span class="toc-text">1.12.1.  @Bean和@Configuration</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-12-2-%E4%BD%BF%E7%94%A8-AnnotationConfigApplicationContext-%E5%AE%9E%E4%BE%8B%E5%8C%96-Spring-%E5%AE%B9%E5%99%A8"><span class="toc-number">1.11.2.</span> <span class="toc-text">1.12.2.  使用 AnnotationConfigApplicationContext 实例化 Spring 容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%9E%84%E9%80%A0"><span class="toc-number">1.11.2.1.</span> <span class="toc-text">简单构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8register%E6%9E%84%E9%80%A0"><span class="toc-number">1.11.2.2.</span> <span class="toc-text">使用register构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8scan%EF%BC%9A%E5%90%AF%E7%94%A8Component%E6%89%AB%E6%8F%8F"><span class="toc-number">1.11.2.3.</span> <span class="toc-text">使用scan：启用Component扫描</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-12-3-%E4%BD%BF%E7%94%A8-Bean%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.11.3.</span> <span class="toc-text">1.12.3.  使用@Bean注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8EBean"><span class="toc-number">1.11.3.1.</span> <span class="toc-text">声明Bean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bean%E4%BE%9D%E8%B5%96%E9%A1%B9"><span class="toc-number">1.11.3.2.</span> <span class="toc-text">Bean依赖项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%9E%E8%B0%83"><span class="toc-number">1.11.3.3.</span> <span class="toc-text">接收生命周期回调</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%AE%9ABean%E8%8C%83%E5%9B%B4"><span class="toc-number">1.11.3.4.</span> <span class="toc-text">指定Bean范围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lt-aop-scoped-proxy-gt"><span class="toc-number">1.11.3.5.</span> <span class="toc-text">&lt;aop:scoped-proxy&#x2F;&gt;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89Bean%E5%91%BD%E5%90%8D"><span class="toc-number">1.11.3.6.</span> <span class="toc-text">自定义Bean命名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bean%E5%88%AB%E5%90%8D"><span class="toc-number">1.11.3.7.</span> <span class="toc-text">Bean别名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bean%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.11.3.8.</span> <span class="toc-text">Bean描述</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-12-4-%E4%BD%BF%E7%94%A8-Configuration%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.11.4.</span> <span class="toc-text">1.12.4.  使用@Configuration注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%85%A5Inter-bean%E4%BE%9D%E8%B5%96%E9%A1%B9"><span class="toc-number">1.11.4.1.</span> <span class="toc-text">注入Inter-bean依赖项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#look-up%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5"><span class="toc-number">1.11.4.2.</span> <span class="toc-text">look-up方法注入</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-12-5-%E6%92%B0%E5%86%99Java-based%E9%85%8D%E7%BD%AE"><span class="toc-number">1.11.5.</span> <span class="toc-text">1.12.5.  撰写Java-based配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#import"><span class="toc-number">1.11.5.1.</span> <span class="toc-text">@import</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E5%AF%BC%E5%85%A5%E7%9A%84-Bean-%E5%AE%9A%E4%B9%89%E4%B8%8A%E6%B3%A8%E5%85%A5%E4%BE%9D%E8%B5%96%E9%A1%B9"><span class="toc-number">1.11.5.2.</span> <span class="toc-text">在导入的 @Bean 定义上注入依赖项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E5%90%88-Java-%E5%92%8C-XML-Configuration"><span class="toc-number">1.11.5.3.</span> <span class="toc-text">结合 Java 和 XML Configuration</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-13-%E7%8E%AF%E5%A2%83%E6%8A%BD%E8%B1%A1"><span class="toc-number">1.12.</span> <span class="toc-text">1.13.  环境抽象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-13-1-Bean%E5%AE%9A%E4%B9%89Profile"><span class="toc-number">1.12.1.</span> <span class="toc-text">1.13.1.  Bean定义Profile</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Profile"><span class="toc-number">1.12.1.1.</span> <span class="toc-text">使用@Profile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BF%80%E6%B4%BBProfile"><span class="toc-number">1.12.1.2.</span> <span class="toc-text">激活Profile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4Profile"><span class="toc-number">1.12.1.3.</span> <span class="toc-text">默认Profile</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-13-2-PropertySource%E6%8A%BD%E8%B1%A1"><span class="toc-number">1.12.2.</span> <span class="toc-text">1.13.2.  PropertySource抽象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-13-3-%E4%BD%BF%E7%94%A8-PropertySource"><span class="toc-number">1.12.3.</span> <span class="toc-text">1.13.3.  使用@PropertySource</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-13-4-Statements-%E4%B8%AD%E7%9A%84%E5%8D%A0%E4%BD%8D%E7%AC%A6%E8%A7%A3%E6%9E%90"><span class="toc-number">1.12.4.</span> <span class="toc-text">1.13.4.  Statements 中的占位符解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-14-%E6%B3%A8%E5%86%8C-LoadTimeWeaver"><span class="toc-number">1.13.</span> <span class="toc-text">1.14.  注册 LoadTimeWeaver</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-15-ApplicationContext-%E7%9A%84%E9%99%84%E5%8A%A0%E5%8A%9F%E8%83%BD"><span class="toc-number">1.14.</span> <span class="toc-text">1.15.  ApplicationContext 的附加功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-15-1-%E4%BD%BF%E7%94%A8-MessageSource-%E8%BF%9B%E8%A1%8C%E5%9B%BD%E9%99%85%E5%8C%96"><span class="toc-number">1.14.1.</span> <span class="toc-text">1.15.1.  使用 MessageSource 进行国际化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-15-2-%E6%A0%87%E5%87%86%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.14.2.</span> <span class="toc-text">1.15.2.  标准和自定义事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%97%B6%E9%97%B4%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">1.14.2.1.</span> <span class="toc-text">基于注解的时间监听器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5Listeners"><span class="toc-number">1.14.2.2.</span> <span class="toc-text">异步Listeners</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%99listener%E5%AE%9A%E4%B9%89%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.14.2.3.</span> <span class="toc-text">给listener定义顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E5%8C%96Events"><span class="toc-number">1.14.2.4.</span> <span class="toc-text">泛型化Events</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-15-3-%E6%96%B9%E4%BE%BF%E7%9A%84%E8%AE%BF%E9%97%AELow-level%E8%B5%84%E6%BA%90"><span class="toc-number">1.14.3.</span> <span class="toc-text">1.15.3.  方便的访问Low-level资源</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-16-BeanFactory"><span class="toc-number">1.15.</span> <span class="toc-text">1.16.  BeanFactory</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-16-1-BeanFactory%E6%88%96ApplicationContext"><span class="toc-number">1.15.1.</span> <span class="toc-text">1.16.1.  BeanFactory或ApplicationContext</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E8%B5%84%E6%BA%90"><span class="toc-number">2.</span> <span class="toc-text">2.资源</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.1.</span> <span class="toc-text">2.1.  介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E8%B5%84%E6%BA%90%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.2.</span> <span class="toc-text">2.2.  资源接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%86%85%E5%BB%BAResource%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">2.3.</span> <span class="toc-text">2.3.  内建Resource的实现类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-UrlResource%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.3.1.  UrlResource对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E4%BD%BF%E7%94%A8ClassPathResource"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.3.2.  使用ClassPathResource</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-FileSystemResource"><span class="toc-number">2.3.3.</span> <span class="toc-text">2.3.3.  FileSystemResource</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-4-ServletContext"><span class="toc-number">2.3.4.</span> <span class="toc-text">2.3.4.  ServletContext</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-5-InputStreamResource"><span class="toc-number">2.3.5.</span> <span class="toc-text">2.3.5.  InputStreamResource</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-6-ByteArrayResource"><span class="toc-number">2.3.6.</span> <span class="toc-text">2.3.6.  ByteArrayResource</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-ResourceLoader"><span class="toc-number">2.4.</span> <span class="toc-text">2.4.  ResourceLoader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-ResourceLoaderAware%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.5.</span> <span class="toc-text">2.5.  ResourceLoaderAware接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E8%B5%84%E6%BA%90%E4%BD%9C%E4%B8%BA%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="toc-number">2.6.</span> <span class="toc-text">2.6.  资源作为依赖关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-Application-Contexts%E5%92%8CResource-Paths"><span class="toc-number">2.7.</span> <span class="toc-text">2.7.  Application Contexts和Resource Paths</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-1-%E6%9E%84%E5%BB%BAApplicationContext"><span class="toc-number">2.7.1.</span> <span class="toc-text">2.7.1.  构建ApplicationContext</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0-ClassPathXmlApplicationContext-%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.7.1.1.</span> <span class="toc-text">构造 ClassPathXmlApplicationContext 实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-2-ApplicationContext%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B5%84%E6%BA%90Paths%E4%B8%AD%E7%9A%84%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">2.7.2.</span> <span class="toc-text">2.7.2.  ApplicationContext构造函数资源Paths中的通配符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Ant-style%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.7.2.1.</span> <span class="toc-text">Ant-style模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#classpath-%E5%89%8D%E7%BC%80"><span class="toc-number">2.7.2.2.</span> <span class="toc-text">classpath*:前缀</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-3-FileSystemResource%E8%AD%A6%E5%91%8A"><span class="toc-number">2.7.3.</span> <span class="toc-text">2.7.3.  FileSystemResource警告</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E9%AA%8C%E8%AF%81%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.</span> <span class="toc-text">3.  验证、数据绑定和类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E4%BD%BF%E7%94%A8Spring%E7%9A%84%E9%AA%8C%E8%AF%81%E5%99%A8%E6%8E%A5%E5%8F%A3%E8%BF%9B%E8%A1%8C%E9%AA%8C%E8%AF%81"><span class="toc-number">3.1.</span> <span class="toc-text">3.1.  使用Spring的验证器接口进行验证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%B0%86%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%BA%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF"><span class="toc-number">3.2.</span> <span class="toc-text">3.2.  将代码解析为错误信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-Bean-%E6%93%8D%E4%BD%9C%E5%92%8C-BeanWrapper"><span class="toc-number">3.3.</span> <span class="toc-text">3.3.  Bean 操作和 BeanWrapper</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-%E8%AE%BE%E7%BD%AE%E5%92%8C%E8%8E%B7%E5%8F%96%E5%9F%BA%E6%9C%AC%E5%92%8C%E5%B5%8C%E5%A5%97%E7%9A%84Properties"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.3.1.  设置和获取基本和嵌套的Properties</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-%E5%86%85%E5%BB%BA%E7%9A%84PropertyEditor%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.3.2.  内建的PropertyEditor实现类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-Spring%E7%B1%BB%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.4.</span> <span class="toc-text">3.4.  Spring类转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-%E8%BD%AC%E6%8D%A2%E5%99%A8SPI"><span class="toc-number">3.4.1.</span> <span class="toc-text">3.4.1.  转换器SPI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-%E4%BD%BF%E7%94%A8ConverterFactory"><span class="toc-number">3.4.2.</span> <span class="toc-text">3.4.2.  使用ConverterFactory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-%E4%BD%BF%E7%94%A8GenericConverter"><span class="toc-number">3.4.3.</span> <span class="toc-text">3.4.2.  使用GenericConverter</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-Spring%E9%AA%8C%E8%AF%81"><span class="toc-number">3.5.</span> <span class="toc-text">3.7.  Spring验证</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-1-JSR-303-Bean-Validation-API-%E6%A6%82%E8%BF%B0"><span class="toc-number">3.5.1.</span> <span class="toc-text">3.7.1.  JSR-303 Bean Validation API 概述</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Spring%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E8%A8%80%EF%BC%88%EF%BC%89SpEL"><span class="toc-number">4.</span> <span class="toc-text">4.Spring表达式语言（）SpEL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-Evaluation"><span class="toc-number">4.1.</span> <span class="toc-text">4.1.  Evaluation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-%E4%BA%86%E8%A7%A3EvaluationContext"><span class="toc-number">4.1.1.</span> <span class="toc-text">4.1.1.  了解EvaluationContext</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-Bean%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">4.2.</span> <span class="toc-text">4.2.  Bean中定义的表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-XML-Configuration"><span class="toc-number">4.2.1.</span> <span class="toc-text">4.2.1.  XML Configuration</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E4%BD%BF%E7%94%A8Spring%E8%BF%9B%E8%A1%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">5.  使用Spring进行面向对象编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-AOP%E6%A6%82%E5%BF%B5"><span class="toc-number">5.1.</span> <span class="toc-text">5.1.  AOP概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-Spring-AOP%E8%83%BD%E5%8A%9B%E5%92%8C%E7%9B%AE%E6%A0%87"><span class="toc-number">5.2.</span> <span class="toc-text">5.2.  Spring AOP能力和目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-AOP%E4%BB%A3%E7%90%86"><span class="toc-number">5.3.</span> <span class="toc-text">5.3.  AOP代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-AspectJ%E6%94%AF%E6%8C%81"><span class="toc-number">5.4.</span> <span class="toc-text">5.4.  @AspectJ支持</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-1-%E5%90%AF%E7%94%A8-AspectJ%E6%94%AF%E6%8C%81"><span class="toc-number">5.4.1.</span> <span class="toc-text">5.4.1.  启用@AspectJ支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-2-%E5%A3%B0%E6%98%8EAspect"><span class="toc-number">5.4.2.</span> <span class="toc-text">5.4.2. 声明Aspect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-3-%E5%A3%B0%E6%98%8E%E5%88%87%E5%85%A5%E7%82%B9"><span class="toc-number">5.4.3.</span> <span class="toc-text">5.4.3.  声明切入点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-4-%E5%A3%B0%E6%98%8E%E9%80%9A%E7%9F%A5"><span class="toc-number">5.4.4.</span> <span class="toc-text">5.4.4.  声明通知</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E8%BF%9E%E6%8E%A5%E7%82%B9%E4%B9%8B%E5%89%8D%E9%80%9A%E7%9F%A5"><span class="toc-number">5.4.4.1.</span> <span class="toc-text">在连接点之前通知</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E7%BB%99%E9%80%9A%E7%9F%A5"><span class="toc-number">5.4.4.2.</span> <span class="toc-text">将参数传递给通知</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E8%AE%AE%E5%8F%82%E6%95%B0%E5%92%8C%E6%B3%9B%E5%9E%8B"><span class="toc-number">5.4.4.3.</span> <span class="toc-text">建议参数和泛型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E5%8F%82%E6%95%B0%E5%90%8D%E7%A7%B0"><span class="toc-number">5.4.4.4.</span> <span class="toc-text">确定参数名称</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#proceed%E5%8F%82%E6%95%B0"><span class="toc-number">5.4.4.5.</span> <span class="toc-text">proceed参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E7%9F%A5%E9%A1%BA%E5%BA%8F"><span class="toc-number">5.4.4.6.</span> <span class="toc-text">通知顺序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-5-%E5%BC%95%E5%85%A5"><span class="toc-number">5.4.5.</span> <span class="toc-text">5.4.5.  引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-6-Aspect-Instantiation-Models"><span class="toc-number">5.4.6.</span> <span class="toc-text">5.4.6.  Aspect Instantiation Models</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-7-AOP-Example"><span class="toc-number">5.4.7.</span> <span class="toc-text">5.4.7.  AOP Example</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-Schema-based-AOP%E6%94%AF%E6%8C%81"><span class="toc-number">5.5.</span> <span class="toc-text">5.5.  Schema-based AOP支持</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-1-%E5%A3%B0%E6%98%8EAspect"><span class="toc-number">5.5.1.</span> <span class="toc-text">5.5.1.  声明Aspect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-2-%E5%A3%B0%E6%98%8E%E5%88%87%E5%85%A5%E7%82%B9"><span class="toc-number">5.5.2.</span> <span class="toc-text">5.5.2.  声明切入点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-3-%E5%A3%B0%E6%98%8E%E9%80%9A%E7%9F%A5"><span class="toc-number">5.5.3.</span> <span class="toc-text">5.5.3.  声明通知</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-4-%E5%BC%95%E5%85%A5"><span class="toc-number">5.5.4.</span> <span class="toc-text">5.5.4.  引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-5-Aspect-Instantiation-Models"><span class="toc-number">5.5.5.</span> <span class="toc-text">5.5.5.  Aspect Instantiation Models</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-6-Advisor"><span class="toc-number">5.5.6.</span> <span class="toc-text">5.5.6.  Advisor</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-8-%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">5.6.</span> <span class="toc-text">5.8.  代理机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8-1-%E4%BA%86%E8%A7%A3AOP%E4%BB%A3%E7%90%86"><span class="toc-number">5.6.1.</span> <span class="toc-text">5.8.1.  了解AOP代理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-9-%E7%A8%8B%E5%BA%8F%E5%8C%96%E5%88%9B%E5%BB%BA-AspectJ%E4%BB%A3%E7%90%86"><span class="toc-number">5.7.</span> <span class="toc-text">5.9.  程序化创建@AspectJ代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-10-%E5%B0%86AspectJ%E4%B8%8ESpring-Applicaitons%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8"><span class="toc-number">5.8.</span> <span class="toc-text">5.10.  将AspectJ与Spring Applicaitons一起使用</span></a></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://dzone.com/storage/temp/12434118-spring-boot-logo.png)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">crazyStrome的博客</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Spring官方文档笔记</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-11-06T02:40:51.725Z" title="发表于 2020-11-06 10:40:51">2020-11-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-10-14T16:00:00.000Z" title="更新于 2020-10-15 00:00:00">2020-10-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Spring/">Spring</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="1-IoC容器"><a href="#1-IoC容器" class="headerlink" title="1.  IoC容器"></a>1.  IoC容器</h1><h2 id="1-1-Spring-IoC容器和Beans简介"><a href="#1-1-Spring-IoC容器和Beans简介" class="headerlink" title="1.1.  Spring IoC容器和Beans简介"></a>1.1.  Spring IoC容器和Beans简介</h2><p>控制反转也称为依赖注入。它是一个process，其中object仅通过构造函数arguments，工厂方法的arguments或者属性的properties来定义它们的依赖项。</p>
<p><code>org.springframework.beans</code>和<code>org.springframework.context</code>包是 Spring Framework 的 IoC 容器的基础。</p>
<p>在 Spring 中，构成 application 主干并由 Spring IoC 容器管理的 objects 称为 beans。</p>
<h2 id="1-2-容器概述"><a href="#1-2-容器概述" class="headerlink" title="1.2.  容器概述"></a>1.2.  容器概述</h2><p><code>org.springframework.context.ApplicationContext</code>接口表示 Spring IoC 容器，负责实例化，配置和组装 beans。容器通过读取 configuration 元数据获取有关 objects 实例化，配置和汇编的指令。 configuration 元数据以 XML，Java annotations 或 Java code 表示。</p>
<h3 id="1-2-1-Configuration元数据"><a href="#1-2-1-Configuration元数据" class="headerlink" title="1.2.1.  Configuration元数据"></a>1.2.1.  Configuration元数据</h3><p>Spring IoC 容器使用一种 configuration 元数据。此 configuration 元数据表示作为 application 开发人员如何告诉 Spring 容器在 application 中实例化，配置和组装 objects。</p>
<ul>
<li><p>Configuration 元数据传统上以简单直观的 XML 格式提供。</p>
</li>
<li><p>Spring 2.5 引入了对 annotation-based configuration 元数据的支持。</p>
</li>
<li><p>从 Spring 3.0 开始，Spring JavaConfig 项目提供的许多 features 成为 Spring Framework 核心的一部分</p>
</li>
</ul>
<p>Spring 配置方式至少包含一种并且通常容器必须管理多个 bean 定义。 基于 XML 配置的元数据将 beans 配置为 top-level <beans/>元素内的<bean/>元素。 Java 配置通常在<code>@Configuration</code> 标记的类中使用<code>@Bean</code> 注释的方法。</p>
<p>这些 bean 定义对应于构成应用的实际对象.</p>
<p>以下示例展示了基于 XML 配置的元数据的基本结构：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span>  (1) (2)</span><br><span class="line">        <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- more bean definitions go here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>id属性用于标识单个bean定义。</p>
<p>class属性定义bean的类型并需要使用完全限定的类名，就是完全路径。</p>
<h3 id="1-2-2-实例化容器"><a href="#1-2-2-实例化容器" class="headerlink" title="1.2.2.  实例化容器"></a>1.2.2.  实例化容器</h3><p>提供给<code>ApplicationContext</code>构造函数的一个或多个字符串类型的位置路径，它允许容器从各种外部资源(例如本地文件系统，Java <code>CLASSPATH</code>等)加载 configuration 元数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;services.xml&quot;</span>, <span class="string">&quot;daos.xml&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>property name</code>元素引用 JavaBean property 的 name，<code>ref</code>元素引用另一个 bean 定义的 name。</p>
<p>使用一个或多个<import/>元素来从一个文件或多个文件加载 bean 定义。以下示例显示了如何执行此操作：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;services.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;resources/messageSource.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;/resources/themeSource.xml&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-3-使用容器"><a href="#1-2-3-使用容器" class="headerlink" title="1.2.3.  使用容器"></a>1.2.3.  使用容器</h3><p><code>ApplicationContext</code>是高级工厂的接口，能够维护不同 beans 及其依赖项的注册表。通过使用方法<code>T getBean(String name, Class requiredType)</code>，可以检索 beans 的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create and configure beans</span></span><br><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;services.xml&quot;</span>, <span class="string">&quot;daos.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// retrieve configured instance</span></span><br><span class="line">PetStoreService service = context.getBean(<span class="string">&quot;petStore&quot;</span>, PetStoreService.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// use configured instance</span></span><br><span class="line">List&lt;String&gt; userList = service.getUsernameList();</span><br></pre></td></tr></table></figure>

<h2 id="1-3-Bean概述"><a href="#1-3-Bean概述" class="headerlink" title="1.3.  Bean概述"></a>1.3.  Bean概述</h2><p>Spring IoC 容器管理一个或多个 beans。</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">解释在……</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Class</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-class">实例化 Beans</a></td>
</tr>
<tr>
<td align="left">Name</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-beanname">命名 Beans</a></td>
</tr>
<tr>
<td align="left">Scope</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes">Bean的作用域</a></td>
</tr>
<tr>
<td align="left">Constructor arguments</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-collaborators=">依赖注入</a></td>
</tr>
<tr>
<td align="left">Properties</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-collaborators">依赖注入</a></td>
</tr>
<tr>
<td align="left">Autowiring mode</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-autowire">自动化协作者</a></td>
</tr>
<tr>
<td align="left">Lazy initialization mode</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lazy-init">Lazy-initialized Beans</a></td>
</tr>
<tr>
<td align="left">Initialization method</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle-initializingbean">初始化回调</a></td>
</tr>
<tr>
<td align="left">Destruction method</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle-disposablebean">毁灭回调</a></td>
</tr>
</tbody></table>
<p>除了包含有关如何创建特定 bean 的信息的 bean 定义之外，<code>ApplicationContext</code> implementations 还允许注册在容器外部(由用户)创建的现有 objects。这是通过<code>getBeanFactory()</code>方法访问 ApplicationContext 的 BeanFactory 来完成的，该方法返回 BeanFactory <code>DefaultListableBeanFactory</code> implementation。 <code>DefaultListableBeanFactory</code>通过<code>registerSingleton(..)</code>和<code>registerBeanDefinition(..)</code>方法支持此注册。但是，典型的 applications 只能使用通过常规 bean 定义元数据定义的 beans。</p>
<h3 id="1-3-1-命名Beans"><a href="#1-3-1-命名Beans" class="headerlink" title="1.3.1.  命名Beans"></a>1.3.1.  命名Beans</h3><p>bean 通常只有一个标识符。但是，如果它需要多个，则额外的可以被视为别名。</p>
<p>在 XML-based configuration 元数据中，使用<code>id</code>属性，<code>name</code>属性或两者来指定 bean 标识符。id属性允许指定一个id。如果要引入其他别名，可以在name属性中指定。</p>
<p>在 XML-based configuration 元数据中，您可以使用<alias/>元素来完成此操作。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;fromName&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;toName&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-3-2-实例化Beans"><a href="#1-3-2-实例化Beans" class="headerlink" title="1.3.2.  实例化Beans"></a>1.3.2.  实例化Beans</h3><p>bean 定义本质上是 creating 一个或多个 objects 的配方。容器在询问时查看命名 bean 的配方，并使用由 bean 定义封装的 configuration 元数据来创建(或获取)实际的 object。</p>
<p>以下 bean 定义指定通过调用工厂方法来创建 bean。该定义未指定返回的 object 的类型(class)，仅指定包含工厂方法的 class。在此 example 中，<code>createInstance()</code>方法必须是静态方法。以下 example 显示了如何指定工厂方法：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;clientService&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;examples.ClientService&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-method</span>=<span class="string">&quot;createInstance&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ClientService clientService = <span class="keyword">new</span> ClientService();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ClientService</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClientService <span class="title">createInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> clientService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用实例工厂方法进行实例化会从容器中调用现有 bean 的 non-static 方法来创建新的 bean。要使用此机制，请将<code>class</code>属性保留为空，并在<code>factory-bean</code>属性中，在当前(或 parent 或 ancestor)容器中指定 bean 的 name，该容器包含要调用以创建 object 的实例方法。使用<code>factory-method</code>属性设置工厂方法本身的 name。以下 example 显示了如何配置这样的 bean：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- the factory bean, which contains a method called createInstance() --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;serviceLocator&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.DefaultServiceLocator&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- inject any dependencies required by this locator bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- the bean to be created via the factory bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;clientService&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-bean</span>=<span class="string">&quot;serviceLocator&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-method</span>=<span class="string">&quot;createClientServiceInstance&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultServiceLocator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ClientService clientService = <span class="keyword">new</span> ClientServiceImpl();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientService <span class="title">createClientServiceInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> clientService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个工厂 class 也可以包含多个工厂方法</p>
<h2 id="1-4-依赖"><a href="#1-4-依赖" class="headerlink" title="1.4.  依赖"></a>1.4.  依赖</h2><h3 id="1-4-1-依赖注入"><a href="#1-4-1-依赖注入" class="headerlink" title="1.4.1.  依赖注入"></a>1.4.1.  依赖注入</h3><p>依赖注入（DI）是一个过程，是指一个Bean在初始化时，通过构造函数的参数、工厂方法的参数、或者properties中定义的依赖项或者从工厂方法返回的依赖项，来构成一个完整的bean。</p>
<p>DI 存在两种主要变体：<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-constructor-injection">Constructor-based 依赖注入</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-setter-injection">Setter-based 依赖注入</a>。</p>
<p>构造方法注入。</p>
<p>由容器调用具有多个参数的构造方法完成，每个参数代表一个依赖项。调用具有特定参数的静态工厂方法来构造bean是等效的。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;thingOne&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.ThingOne&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;thingTwo&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;thingThree&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;thingTwo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.ThingTwo&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;thingThree&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.ThingThree&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当构造方法中的参数类型是已知的，比如int或string，需要添加类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> examples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Number of years to calculate the Ultimate Answer</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> years;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The Answer to Life, the Universe, and Everything</span></span><br><span class="line">    <span class="keyword">private</span> String ultimateAnswer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExampleBean</span><span class="params">(<span class="keyword">int</span> years, String ultimateAnswer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.years = years;</span><br><span class="line">        <span class="keyword">this</span>.ultimateAnswer = ultimateAnswer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7500000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;42&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以使用<code>index</code>属性显式指定构造函数 arguments 的索引，如下面的 example 所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7500000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;42&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以使用构造函数参数 name 进行 value 消歧，如下面的 example 所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;years&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7500000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;ultimateAnswer&quot;</span> <span class="attr">value</span>=<span class="string">&quot;42&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>请记住，要使这项工作开箱即用，必须在启用 debug flag 的情况下编译 code，以便 Spring 可以从构造函数中查找参数 name。如果您不能或不想使用 debug flag 编译 code，则可以使用<a target="_blank" rel="noopener" href="https://download.oracle.com/javase/6/docs/api/java/beans/ConstructorProperties.html">@ConstructorProperties</a> 显式 name 构造函数 arguments。然后 sample class 必须如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> examples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fields omitted</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ConstructorProperties(&#123;&quot;years&quot;, &quot;ultimateAnswer&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExampleBean</span><span class="params">(<span class="keyword">int</span> years, String ultimateAnswer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.years = years;</span><br><span class="line">        <span class="keyword">this</span>.ultimateAnswer = ultimateAnswer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>setter依赖注入</p>
<p>Setter依赖注入是调用无参构造器或者无参工厂方法来实例化Bean后，在beans上调用setter方法的容器来完成。</p>
<p>可以混合使用构造器依赖注入和setter方法注入，构造器注入强制依赖项，settter方法注入可选依赖项。</p>
<p>容器解决依赖项分析：</p>
<ul>
<li>使用描述所有 beans 的 configuration 元数据创建和初始化<code>ApplicationContext</code>。 Configuration 元数据可以由 XML，Java code 或 annotations 指定。</li>
<li>对于每个 bean，其依赖关系以 properties，constructor arguments 或_ar_ments 的形式表示(如果使用它而不是普通的构造函数)。当实际创建 bean 时，这些依赖项将提供给 bean。</li>
<li>每个 property 或构造函数参数都是要设置的 value 的实际定义，或者是容器中另一个 bean 的 reference。</li>
<li>作为 value 的每个 property 或构造函数参数都从其指定的格式转换为该 property 或 constructor 参数的实际类型。默认情况下，Spring 可以将 string 格式提供的 value 转换为所有 built-in 类型，例如<code>int</code>，<code>long</code>，<code>String</code>，<code>boolean</code>等。</li>
</ul>
<p>Spring 容器在创建容器时验证每个 bean 的 configuration。但是，在实际创建 bean 之前，不会设置 bean properties 本身。</p>
<p>循环依赖：</p>
<p>对于 example：Class A 需要通过构造函数注入实现 class B，而 class B 需要通过构造函数注入实现 class A.如果为 classes A 和 B 配置 beans 以相互注入，则 Spring IoC 容器会在运行时检测到此循环 reference，并抛出<code>BeanCurrentlyInCreationException</code>。</p>
<p>可以使用setter注入配置循环依赖项。</p>
<p>spring在容器 load-time 处检测 configuration 问题，例如 reference to non-existent beans 和循环依赖项。</p>
<p>如果不存在循环依赖关系，则当一个或多个协作 beans 被注入依赖 bean 时，每个协作 bean 在被注入依赖 bean 之前完全配置。这意味着，如果 bean A 依赖于 bean B，Spring IoC 容器在 bean A 上调用 setter 方法之前完全配置 bean B.换句话说，bean 被实例化(如果它不是 pre-instantiated singleton)，设置其依赖项，并调用相关的生命周期方法(例如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle-initializingbean">配置的 init 方法</a>或<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle-initializingbean">InitializingBean 回调方法</a>)。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;parent&quot;</span> <span class="attr">abstract</span>=<span class="string">&quot;true&quot;</span> <span class="attr">class</span>=<span class="string">&quot;example.ComplexObject&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;adminEmails&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;administrator&quot;</span>&gt;</span>[emailprotected]<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;support&quot;</span>&gt;</span>[emailprotected]<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;child&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;adminEmails&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- the merge is specified on the child collection definition --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span> <span class="attr">merge</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;sales&quot;</span>&gt;</span>[emailprotected]<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;support&quot;</span>&gt;</span>[emailprotected]<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意在<code>child</code> bean 定义的<code>adminEmails</code> property 的<code>&lt;props/&gt;</code>元素上使用<code>merge=true</code>属性。当<code>child</code> bean 由容器解析并实例化时，生成的实例有一个<code>adminEmails</code> <code>Properties</code>集合，其中包含将 child 的<code>adminEmails</code>集合与 parent 的<code>adminEmails</code>集合合并的结果。</p>
<p>Spring 将 properties 等的空 arguments 视为空<code>Strings</code>。</p>
<p>需要null的时候使用<null/>。</p>
<h3 id="1-4-3-使用depends-on"><a href="#1-4-3-使用depends-on" class="headerlink" title="1.4.3.  使用depends-on"></a>1.4.3.  使用depends-on</h3><p>在使用此元素的 bean 初始化之前，<code>depends-on</code>属性可以显式强制初始化一个或多个 beans。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beanOne&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ExampleBean&quot;</span> <span class="attr">depends-on</span>=<span class="string">&quot;manager,accountDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;manager&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;manager&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;manager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ManagerBean&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.jdbc.JdbcAccountDao&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-4-4-Lazy-initialized-Beans"><a href="#1-4-4-Lazy-initialized-Beans" class="headerlink" title="1.4.4.  Lazy-initialized Beans"></a>1.4.4.  Lazy-initialized Beans</h3><p>默认情况下，<code>ApplicationContext</code> implementations 急切地创建和配置所有<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-singleton">singleton</a> beans 作为初始化 process 的一部分。通常，这个 pre-instantiation 是可取的，因为 configuration 或周围环境中的错误会立即被发现，而不是几小时甚至几天。如果不希望出现这种情况，可以通过将 bean 定义标记为 lazy-initialized 来阻止 singleton bean 的 pre-instantiation。 lazy-initialized bean 告诉 IoC 容器在第一次请求时创建 bean 实例，而不是在启动时创建 bean 实例。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;lazy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.something.ExpensiveToCreateBean&quot;</span> <span class="attr">lazy-init</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;not.lazy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.something.AnotherBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是，当 lazy-initialized bean 是 singleton bean 的依赖关系而 singleton bean 不是 lazy-initialized 时，<code>ApplicationContext</code>会在启动时创建 lazy-initialized bean，因为它必须满足 singleton 的依赖关系。 lazy-initialized bean 被注入 singleton bean，而不是 lazy-initialized。</p>
<p>可以使用<code>&lt;beans/&gt;</code>元素上的<code>default-lazy-init</code>属性控制容器 level 上的 lazy-initialization，以下 example 显示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">default-lazy-init</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- no beans will be pre-instantiated... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-4-5-自动装配"><a href="#1-4-5-自动装配" class="headerlink" title="1.4.5.  自动装配"></a>1.4.5.  自动装配</h3><p>自动装配具有以下优点：</p>
<ul>
<li>自动装配可以显着减少指定 properties 或构造函数 arguments 的需要。 (其他机制，如 bean 模板<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-singleton">在本章的其他地方讨论过</a>在此 regard.)也很有价值</li>
<li>随着 objects 的发展，自动装配可以更新 configuration。例如，如果需要向 class 添加依赖项，则可以自动满足该依赖项，而无需修改 configuration。因此，自动装配在开发期间尤其有用，而不会在 code base 变得更稳定时否定切换到显式布线的选项。</li>
</ul>
<p>使用 XML-based configuration 元数据(请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-child-bean-definitions">依赖注入</a>)时，可以使用``元素的<code>autowire</code>属性为 bean 定义指定 autowire 模式。自动装配功能有四种模式。您为每个 bean 指定自动装配，因此可以选择要自动装配的那些。以下 table 描述了四种自动装配模式：</p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>no</code></td>
<td align="left">(默认)无自动装配。 Bean references 必须由<code>ref</code>元素定义。不建议对较大的部署更改默认设置，因为明确指定协作者可以提供更好的控制和清晰度。在某种程度上，它记录了系统的结构。</td>
</tr>
<tr>
<td align="left"><code>byName</code></td>
<td align="left">property name 自动装配。 Spring 查找 bean，其 name 与需要自动装配的 property 相同。例如，如果 bean 定义由 name 设置为 autowire 并且它包含<code>master</code> property(即，它具有<code>setMaster(..)</code>方法)，则 Spring 将查找名为<code>master</code>的 bean 定义并使用它来设置 property。</td>
</tr>
<tr>
<td align="left"><code>byType</code></td>
<td align="left">如果容器中只存在 property 类型的一个 bean，则允许 property 自动装配。如果存在多个，则抛出致命的 exception，这表示您不能对该 bean 使用<code>byType</code>自动装配。如果没有匹配的 beans，则不会发生任何事情(property 未设置)。</td>
</tr>
<tr>
<td align="left"><code>constructor</code></td>
<td align="left">类似于<code>byType</code>但适用于构造函数 arguments。如果容器中没有构造函数参数类型的一个 bean，则会引发致命错误。</td>
</tr>
</tbody></table>
<p>当 Spring遇到一个在 setter 方法中使用的 @Autowired 注释，它会在方法中视图执行 <strong>byType</strong> 自动连接。</p>
<h3 id="1-4-6-方法注入"><a href="#1-4-6-方法注入" class="headerlink" title="1.4.6.  方法注入"></a>1.4.6.  方法注入</h3><p>容器中大多数bean都是单例。当 singleton bean 需要与另一个 singleton bean 协作或 non-singleton bean 需要与另一个 non-singleton bean 协作时，通常通过将一个 bean 定义为另一个的 property 来处理依赖关系。</p>
<p> 有时我们需要在一个bean A中调用另一个bean B的方法，通常我们会添加一个字段，然后使用依赖注入把bean B的实例注入到这个字段上。这种情况下在bean A 和 bean B都是singleton时没问题，但是在 bean A是singleton和bean B是非singleton时就可能出现问题。因为bean B为非singleton , 那么bean B是希望他的使用者在一些情况下创建一个新实例，而bean A使用字段把bean B的一个实例缓存了下来，每次都使用的是同一个实例。</p>
<p> 我们假设bean B是一个prototype</p>
<p> 一种解决办法是不使用字段依赖注入，每次使用bean B的时候都去bean容器中重新获取</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是一个命令执行类，提供一个process方法，执行用户的命令</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandManager</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用依赖注入，把applicationContext注入进来</span></span><br><span class="line">    <span class="meta">@Autowire</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户指定的参数，每次使用一个新的Command实例去执行命令</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> commandState 执行的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 执行后的返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">process</span><span class="params">(Map commandState)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 每次使用都调用createCommand去获取一个新实例</span></span><br><span class="line">        Command command = createCommand();</span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="keyword">return</span> command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从applicationContext获取一个新的Command实例</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Command <span class="title">createCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.applicationContext.getBean(<span class="string">&quot;command&quot;</span>, Command.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 上面的代码是每次都从applicationContext重新获取一个新实例来实现的。Spring提供了一个Lookup method inject机制，它可以改变方法的返回值，来达到方法注入的效果。对应的有annotation和xml两种使用方式。</p>
<h4 id="查找方法注入"><a href="#查找方法注入" class="headerlink" title="查找方法注入"></a>查找方法注入</h4><p>annotation的使用方式@Lookup，把@Lookup加到你要改变方法返回值的方法上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandManager</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">process</span><span class="params">(Map commandState)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 每次使用都调用createCommand去获取一个新实例</span></span><br><span class="line">        Command command = createCommand();</span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="keyword">return</span> command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Loopup的注释中的写明了需要返回的bean名字，如果没有写bean name，那么会根据createCommand的函数返回值类型去查找对应的bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Lookup(&quot;command&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Command <span class="title">createCommand</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> Spring的Lookup method inject实现原理的是使用CGLIB动态生成一个类去继承<code>CommandManager</code>，重写<code>createCommand</code>方法。然后根据@Lookup中指定的bean Name或者<code>createCommand</code>方法的返回类型判断需要返回的bean。<code>createCommand</code>可以是abstract和可以不是。因为使用的是继承，所以<code>CommandManager</code>类和<code>createCommand</code>方法都不能是final的。</p>
<p><code>createCommand</code>方法的签名需要满足如下要求</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">public</span>|<span class="keyword">protected</span>&gt; [<span class="keyword">abstract</span>] &lt;<span class="keyword">return</span>-<span class="keyword">type</span>&gt; theMethodName(no-<span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure>

<p>如果方法是<code>abstract</code>，则 dynamically-generated 子类实现该方法。否则，dynamically-generated 子类将覆盖原始 class 中定义的具体方法。对应实现的XML配置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;command&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;AsyncCommand&quot;</span> scope=<span class="string">&quot;prototype&quot;</span>&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">&quot;commandManager&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;CommandManager&quot;</span>&gt;</span><br><span class="line">    &lt;lookup-method name=<span class="string">&quot;createCommand&quot;</span> bean=<span class="string">&quot;command&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h4 id="任意方法替换"><a href="#任意方法替换" class="headerlink" title="任意方法替换"></a>任意方法替换</h4><h2 id="1-5-Bean范围"><a href="#1-5-Bean范围" class="headerlink" title="1.5.  Bean范围"></a>1.5.  Bean范围</h2><p> Beans 可以定义为部署在多个范围之一中。 Spring Framework 支持六个范围，其中四个范围仅在您使用 web-aware <code>ApplicationContext</code>时可用。你也可以创建<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-other-injection">自定义范围。</a></p>
<p>以下 table 描述了支持的范围：</p>
<table>
<thead>
<tr>
<th align="left">范围</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-custom">singleton</a></td>
<td align="left">（默认）整个容器周期中只维护一个实例。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-singleton">原型</a></td>
<td align="left">每次请求时容器都会创建新的实例</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-prototype">请求</a></td>
<td align="left">将单个 bean 定义范围限定为单个 HTTP 请求的生命周期。也就是说，每个 HTTP 请求都有自己的 bean 实例，该实例是在单个 bean 定义的后面创建的。仅在 web-aware Spring <code>ApplicationContext</code>的 context 中有效。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-request">session</a></td>
<td align="left">将单个 bean 定义范围限定为 HTTP <code>Session</code>的生命周期。仅在 web-aware Spring <code>ApplicationContext</code>的 context 中有效。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-session">应用</a></td>
<td align="left">将单个 bean 定义范围限定为<code>ServletContext</code>的生命周期。仅在 web-aware Spring <code>ApplicationContext</code>的 context 中有效。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#beans-factory-scopes-application">WebSocket</a></td>
<td align="left">将单个 bean 定义范围限定为<code>WebSocket</code>的生命周期。仅在 web-aware Spring <code>ApplicationContext</code>的 context 中有效。</td>
</tr>
</tbody></table>
<h3 id="1-5-1-Singleton范围"><a href="#1-5-1-Singleton范围" class="headerlink" title="1.5.1.  Singleton范围"></a>1.5.1.  Singleton范围</h3><p>当把Bean的范围限定为Singleton时，Spring IoC容器只创建该bean的一个实例。该实例储存在此类singleton beans的缓存中，并且后续请求和引用都指向这同一个实例。</p>
<p><img src="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/singleton.jpg"></p>
<p> Spring singleton 的范围最好描述为 per-container 和 per-bean。这意味着，如果在单个 Spring 容器中为特定 class 定义一个 bean，则 Spring 容器将创建该bean 定义所定义的 class 的一个且仅一个实例。</p>
<h3 id="1-5-2-prototype范围"><a href="#1-5-2-prototype范围" class="headerlink" title="1.5.2.  prototype范围"></a>1.5.2.  prototype范围</h3><p>每次向spring IoC容器请求bean时都会新创建一个bean实例。</p>
<p><img src="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/prototype.jpg"></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.something.DefaultAccountService&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>应该为所有状态随时变化的 beans 使用原型范围，为 stateless beans 使用 singleton 范围。</p>
<p>当我们将一个bean的Scope定义为prototype时，有一点需要注意的是Spring将只会回调对应bean定义的初始化方法，而对于销毁方法，Spring是不会进行回调的。根据之前对我们对生命周期回调方法的介绍，我们知道初始化方法的回调是在Spring将对应的bean实例化之后进行回调的，不管我们将bean的Scope设置为何种类型，对应bean的实例化都是由Spring完成的，所以对于bean定义的初始化方法是可以被Spring回调的，这点没有问题。相对应的是bean的销毁方法是在Spring决定销毁bean容器之前进行回调的，这个时候Spring需要拿到对应的bean实例才能进行对应销毁方法的回调，但是对于prototype类型的bean定义而言，Spring是不会保留对应的bean实例的，所以它拿不到，也就不会进行回调了。而对于之前我们介绍的singleton类型的bean定义，由于其实例都由Spring缓存起来了，以确保每次请求的都是同一个实例，所以在bean容器销毁前，Spring还是可以拿到原来实例化的bean实例，所以就可以进行对应销毁方法的回调。</p>
<h3 id="1-5-3-带有prototype-bean依赖的单例bean"><a href="#1-5-3-带有prototype-bean依赖的单例bean" class="headerlink" title="1.5.3.  带有prototype-bean依赖的单例bean"></a>1.5.3.  带有prototype-bean依赖的单例bean</h3><p>需要使用方法注入</p>
<h3 id="1-5-4-Request，Session，Application-和-WebSocket-Scopes"><a href="#1-5-4-Request，Session，Application-和-WebSocket-Scopes" class="headerlink" title="1.5.4.  Request，Session，Application 和 WebSocket Scopes"></a>1.5.4.  Request，Session，Application 和 WebSocket Scopes</h3><p>仅当您使用 web-aware Spring <code>ApplicationContext</code> implementation(例如<code>XmlWebApplicationContext</code>)时，<code>request</code>，<code>session</code>，<code>application</code>和<code>websocket</code>范围才可用。如果将这些范围与常规 Spring IoC 容器(例如<code>ClassPathXmlApplicationContext</code>)一起使用，则会抛出抱怨未知 bean 范围的<code>IllegalStateException</code>。</p>
<h4 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h4><p>当我们将一个bean的Scope定义为request时，表示在每一个HttpRequest生命周期内从bean容器获取到的对应bean定义的实例都是同一个实例，而不同的HttpRequest所获取到的实例是不一样的。该类型的Scope只允许在Web环境下使用，包括后续介绍的session和application。</p>
<p>对于此种类型的bean有一个问题需要注意，那就是如果我们拥有一个singleton类型的 beanA，然后其需要被注入一个request类型的beanB时，如果我们在对beanA进行定义时就定义好了其对beanB的依赖。则由于Spring默认会在初始化bean容器后立即对单例类型的bean进行实例化，进而导致会实例化其所依赖的其它bean，也就是说在实例化beanA的时候，会进而实例化beanB。但此时是没有HttpRequest请求的，也就是说没有Web环境的，那么Spring将无法实例化beanB，其会抛出异常。<br>针对上述情形，可以有两种处理方法，一是指定beanA为懒初始化，这样Spring在bean容器初始化完成后默认不会对其进行实例化，只有在其第一次需要被使用的情况下才会被初始化，所以此时beanA不能作为其它会被Spring在bean容器初始化后进行实例化的bean的依赖关系链上的一员存在。<br>使用注解进行制定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanA</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种处理方式是可以在beanB的bean定义下定义<a href="aop:scoped-proxy/">aop:scoped-proxy/</a>以告诉Spring需要为对应的bean生成一个代理。这样在将beanB注入给beanA时实际上注入的只是一个代理，然后在我们真正使用beanB的时候，Spring会拿一个真正的beanB实例来进行对应的操作。</p>
<h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>当将一个bean的Scope定义为session时即表示该bean的实例将与session保持一致，即每一个不同的session保持一个不同的实例，同一个session则拥有相同的实例。或者换句话来说就是在同一session环境下，不管你从bean容器中获取对应bean定义的实例多少次，你取到的总是一个相同的实例。</p>
<h4 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h4><p>指定Scope为application也只能在Web环境下使用。当定义一个bean的scope为application时表示对应的bean实例是跟ServletContext绑定在一起的，即在整个ServletContext环境下都只会拥有一个对应的实例。</p>
<h3 id="1-5-5-自定义范围"><a href="#1-5-5-自定义范围" class="headerlink" title="1.5.5.  自定义范围"></a>1.5.5.  自定义范围</h3><p>自己实现scope接口，并注册到IoC容器中。</p>
<h2 id="1-6-自定义Bean的性质"><a href="#1-6-自定义Bean的性质" class="headerlink" title="1.6.  自定义Bean的性质"></a>1.6.  自定义Bean的性质</h2><p>Spring Framework 提供了许多可用于自定义 bean 特性的接口。本节将它们分组如下：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#registerDestructionCallback">生命周期回调</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle">ApplicationContextAware 和 BeanNameAware</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-aware">其他感知接口</a></li>
</ul>
<h3 id="1-6-1-生命周期回调"><a href="#1-6-1-生命周期回调" class="headerlink" title="1.6.1.  生命周期回调"></a>1.6.1.  生命周期回调</h3><p>实现 Spring <code>InitializingBean</code>和<code>DisposableBean</code>接口，容器就可以通过afterPropertiesSet()和destory()方法进行Bean的初始化和销毁操作。</p>
<p>使用<code>init-method</code>和<code>destroy-method</code>也可以定义初始化方法和销毁方法。</p>
<p>初始化方法是在初始化之后执行的，销毁方法是在销毁Bean之前执行的。</p>
<p>还可以实现Lifecyscle接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lifecycle</span> </span>&#123;  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;  </span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h4 id="初始化回调"><a href="#初始化回调" class="headerlink" title="初始化回调"></a>初始化回调</h4><p>接口允许 bean 在容器在 bean 上设置所有必需的 properties 后执行初始化工作。 <code>InitializingBean</code>接口指定单个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure>

<p>我们建议您不要使用<code>InitializingBean</code>接口，因为它会不必要地将 code 耦合到 Spring。或者，我们建议使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-extension">@PostConstruct</a> annotation 或指定 POJO 初始化方法。对于 XML-based configuration 元数据，可以使用<code>init-method</code>属性指定具有 void no-argument 签名的方法的 name。使用 Java configuration，您可以使用<code>@Bean</code>的<code>initMethod</code>属性。</p>
<h4 id="销毁回调"><a href="#销毁回调" class="headerlink" title="销毁回调"></a>销毁回调</h4><p>实现<code>org.springframework.beans.factory.DisposableBean</code>接口允许 bean 在包含它的容器被销毁时获得回调。 <code>DisposableBean</code>接口指定单个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure>

<p>我们建议您不要使用<code>DisposableBean</code>回调接口，因为它会不必要地将 code 耦合到 Spring。或者，我们建议使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-java-lifecycle-callbacks">@PreDestroy</a> annotation 或指定 bean 定义支持的泛型方法。使用 XML-based configuration 元数据，您可以使用``上的<code>destroy-method</code>属性。使用 Java configuration，您可以使用<code>@Bean</code>的<code>destroyMethod</code>属性。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleInitBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;cleanup&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以在<beans/>中添加默认的初始化方法或销毁方法：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">default-init-method</span>=<span class="string">&quot;init&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;blogService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.something.DefaultBlogService&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;blogDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;blogDao&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>从 Spring 2.5 开始，您有三个控制 bean 生命周期行为的选项：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle">InitializingBean</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle-initializingbean">DisposableBean</a>回调接口</li>
<li>自定义<code>init()</code>和<code>destroy()</code>方法</li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle-disposablebean">@PostConstruct 和 @PreDestroy 注释</a>。您可以组合这些机制来控制给定的 bean。</li>
</ul>
<h4 id="启动和关闭回调方法"><a href="#启动和关闭回调方法" class="headerlink" title="启动和关闭回调方法"></a>启动和关闭回调方法</h4><p><code>Lifecycle</code>接口为具有自己的生命周期要求的任何 object 定义了基本方法(例如启动和停止一些后台 process)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Phased</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPhase</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmartLifecycle</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span>, <span class="title">Phased</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAutoStartup</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">(Runnable callback)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动时，具有最低相位的 objects 首先启动。停止时，遵循反向顺序。因此，实现<code>SmartLifecycle</code>且其<code>getPhase()</code>方法返回<code>Integer.MIN_VALUE</code>的 object 将是第一个开始，最后一个停止。在频谱的另一端，<code>Integer.MAX_VALUE</code>的阶段值将指示 object 应该最后启动并首先停止(可能因为它依赖于其他进程 running)。在考虑阶段 value 时，同样重要的是要知道没有实现<code>SmartLifecycle</code>的任何“正常”<code>Lifecycle</code> object 的默认阶段是<code>0</code>。因此，任何负相位 value 都表示 object 应该在这些标准组件之前启动(并在它们之后停止)。对于任何正相值，反向都是 true。</p>
<p><code>SmartLifecycle</code>定义的 stop 方法接受回调。在 implementation 的 shutdown process 完成之后，任何 implementation 都必须调用该回调的<code>run()</code>方法。这样可以在必要时启用异步关闭</p>
<h3 id="1-6-2-ApplicationContextAware和BeanNameAware"><a href="#1-6-2-ApplicationContextAware和BeanNameAware" class="headerlink" title="1.6.2.  ApplicationContextAware和BeanNameAware"></a>1.6.2.  ApplicationContextAware和BeanNameAware</h3><p>当<code>ApplicationContext</code>创建实现<code>org.springframework.context.ApplicationContextAware</code>接口的 object 实例时，该实例将提供的 reference。</p>
<h2 id="1-7-Bean定义继承"><a href="#1-7-Bean定义继承" class="headerlink" title="1.7.  Bean定义继承"></a>1.7.  Bean定义继承</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;inheritedTestBean&quot;</span> <span class="attr">abstract</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.TestBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;parent&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;inheritsWithDifferentClass&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.DerivedTestBean&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">parent</span>=<span class="string">&quot;inheritedTestBean&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;initialize&quot;</span>&gt;</span>  (1)</span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;override&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- the age property value of 1 will be inherited from parent --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>child bean 定义从 parent 继承范围，构造函数参数值，属性值和方法覆盖，并带有添加新值的选项。您指定的任何范围，初始化方法，销毁方法或<code>static</code>工厂方法设置都会覆盖相应的 parent 设置。</p>
<p>前面的 example 使用<code>abstract</code>属性显式地将 parent bean 定义标记为 abstract。如果 parent 定义未指定 class，则需要将 parent bean 定义显式标记为<code>abstract</code>，如下面的 example 所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;inheritedTestBeanWithoutClass&quot;</span> <span class="attr">abstract</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;parent&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;inheritsWithClass&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.DerivedTestBean&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">parent</span>=<span class="string">&quot;inheritedTestBeanWithoutClass&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;initialize&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;override&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- age will inherit the value of 1 from the parent bean definition--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>parent bean 无法单独实例化，因为它不完整，并且也明确标记为<code>abstract</code>。当定义为<code>abstract</code>时，它仅可用作纯模板 bean 定义，用作 child 定义的 parent 定义。尝试使用这样的<code>abstract</code> parent bean，通过将其称为另一个 bean 的 ref property 或使用 parent bean ID 进行显式<code>getBean()</code>调用返回错误。类似地，容器的内部<code>preInstantiateSingletons()</code>方法忽略定义为 abstract 的 bean 定义。</p>
<h2 id="1-8-集装箱扩建点"><a href="#1-8-集装箱扩建点" class="headerlink" title="1.8.  集装箱扩建点"></a>1.8.  集装箱扩建点</h2><p>通常，application 开发人员不需要子类<code>ApplicationContext</code> implementation classes。相反，可以通过插入特殊 integration 接口的 implementations 来扩展 Spring IoC 容器。</p>
<h3 id="1-8-1-使用-BeanPostProcessor-自定义-Beans"><a href="#1-8-1-使用-BeanPostProcessor-自定义-Beans" class="headerlink" title="1.8.1.  使用 BeanPostProcessor 自定义 Beans"></a>1.8.1.  使用 BeanPostProcessor 自定义 Beans</h3><h2 id="1-9-Annotation-based-Container-Configuration"><a href="#1-9-Annotation-based-Container-Configuration" class="headerlink" title="1.9.  Annotation-based Container Configuration"></a>1.9.  Annotation-based Container Configuration</h2><p>在xml配置中添加<a href="context:annotation-config">context:annotation-config</a>来开启注解模式。</p>
<p><code>&lt;context:annotation-config/&gt;</code>仅在定义它的同一 application context 中查找 beans 上的 annotations。</p>
<h3 id="1-9-1-Required"><a href="#1-9-1-Required" class="headerlink" title="1.9.1.  @Required"></a>1.9.1.  @Required</h3><p><code>@Required</code> annotation 适用于 bean property setter 方法，如下例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Required</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的property必须被装配，否则会抛出异常。</p>
<h3 id="1-9-2-使用-Autowired"><a href="#1-9-2-使用-Autowired" class="headerlink" title="1.9.2.  使用@Autowired"></a>1.9.2.  使用@Autowired</h3><p>可以将<code>@Autowired</code> annotation 应用于构造函数，如以下 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MovieRecommender</span><span class="params">(CustomerPreferenceDao customerPreferenceDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 Spring Framework 4.3 开始，如果目标 bean 仅定义一个开头的构造函数，则不再需要在这样的构造函数上使用<code>@Autowired</code> annotation。但是，如果有几个构造器可用，则必须注释至少一个构造器以教导容器使用哪一个。</p>
<p>还可以将<code>@Autowired</code> annotation 应用于“传统”setter 方法，如以下 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-9-5-使用泛型作为自动装配限定符"><a href="#1-9-5-使用泛型作为自动装配限定符" class="headerlink" title="1.9.5.  使用泛型作为自动装配限定符"></a>1.9.5.  使用泛型作为自动装配限定符</h3><p>除了<code>@Qualifier</code> annotation 之外，您还可以使用 Java 泛型类型作为隐式的限定形式。例如，假设您有以下 configuration：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringStore <span class="title">stringStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringStore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IntegerStore <span class="title">integerStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IntegerStore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设前面的 beans 实现了一个通用接口(即<code>Store</code>和<code>Store</code>)，你可以<code>@Autowire</code> <code>Store</code>接口，泛型用作限定符，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Store&lt;String&gt; s1; <span class="comment">// &lt;String&gt; qualifier, injects the stringStore bean</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Store&lt;Integer&gt; s2; </span><br></pre></td></tr></table></figure>

<p>通用限定符也适用于自动装配 lists，<code>Map</code>实例和数组。</p>
<h3 id="1-9-6-使用-CustomAutowireConfigurer"><a href="#1-9-6-使用-CustomAutowireConfigurer" class="headerlink" title="1.9.6. 使用 CustomAutowireConfigurer"></a>1.9.6. 使用 CustomAutowireConfigurer</h3><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/CustomAutowireConfigurer.html">CustomAutowireConfigurer 上</a>是一个<code>BeanFactoryPostProcessor</code>，它允许您注册自己的自定义限定符注释类型，即使它们没有使用 Spring 的<code>@Qualifier</code> annotation 注释。以下 example 显示了如何使用<code>CustomAutowireConfigurer</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;customAutowireConfigurer&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.annotation.CustomAutowireConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;customQualifierTypes&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>example.CustomQualifier<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>AutowireCandidateResolver</code>通过以下方式确定 autowire 候选人：</p>
<ul>
<li>每个 bean 定义的<code>autowire-candidate</code> value</li>
<li><code>&lt;beans/&gt;</code>元素上可用的任何<code>default-autowire-candidates</code>模式</li>
<li><code>@Qualifier</code> 注释的存在以及使用<code>CustomAutowireConfigurer</code>注册的任何自定义注释</li>
</ul>
<p>当多个 beans 有资格作为 autowire 候选者时，“primary”的确定如下：如果候选者中只有一个 bean 定义将<code>primary</code>属性设置为<code>true</code>，则选择它。</p>
<h3 id="1-9-7-注射-Resource"><a href="#1-9-7-注射-Resource" class="headerlink" title="1.9.7.  注射@Resource"></a>1.9.7.  注射@Resource</h3><p>Spring 还支持使用字段上的 JSR-250 <code>@Resource</code> annotation 或 bean property setter 方法进行注入。</p>
<p><code>@Resource</code>采用 name 属性。默认情况下，Spring 将 value 解释为要注入的 bean name。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource(name=&quot;myMovieFinder&quot;)</span> (<span class="number">1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果未显式指定 name，则默认 name 派生自字段 name 或 setter 方法。如果是字段，则需要字段 name。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-9-8-使用-PostConstruct和-PreDestory"><a href="#1-9-8-使用-PostConstruct和-PreDestory" class="headerlink" title="1.9.8.  使用@PostConstruct和@PreDestory"></a>1.9.8.  使用@PostConstruct和@PreDestory</h3><p><code>CommonAnnotationBeanPostProcessor</code>不仅识别<code>@Resource</code> annotation，还识别 JSR-250 生命周期注释。在 Spring 2.5 中引入，对这些注释的支持提供了<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-scanning-qualifiers">初始化回调</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle-initializingbean">销毁回调</a>中描述的另一种替代方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachingMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">populateMovieCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// populates the movie cache upon initialization...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearMovieCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// clears the movie cache upon destruction...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-10-Classpath扫描和托管组件"><a href="#1-10-Classpath扫描和托管组件" class="headerlink" title="1.10.  Classpath扫描和托管组件"></a>1.10.  Classpath扫描和托管组件</h2><p>本章中的大多数示例都使用 XML 来指定配置Bean的数据，该元数据在 Spring 容器中生成每个<code>BeanDefinition</code>。上一节(<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle-combined-effects">Annotation-based Container Configuration</a>)演示了如何通过源代码级别的注解提供大量配置元数据。但是，即使在这些示例中，基础bean 定义也在 XML 文件中明确定义，而 annotations 仅驱动依赖项注入。本节介绍通过扫描 classpath 隐式检测候选组件的选项。候选组件是 classes，它们与过滤条件匹配，并且在容器中注册了相应的 bean 定义。这消除了使用 XML 执行 bean 注册的需要。相反，您可以使用 annotations(用于 example，<code>@Component</code>)，AspectJ 类型表达式或您自己的自定义过滤条件来选择哪些 classes 具有向容器注册的 bean 定义。</p>
<h3 id="1-10-1-Component和进一步的刻板印象注释"><a href="#1-10-1-Component和进一步的刻板印象注释" class="headerlink" title="1.10.1.  @Component和进一步的刻板印象注释"></a>1.10.1.  @Component和进一步的刻板印象注释</h3><p><code>@Repository</code> annotation 是任何 class 的标记，它满足 repository(也称为 Data Access Object 或 DAO)的角色或构造型。该标记的用途之一是 exceptions 的自动转换，如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#beans-annotation-config">Exception 翻译</a>中所述。</p>
<p>Spring 提供了进一步的构造型注释：<code>@Component</code>，<code>@Service</code>和<code>@Controller</code>。 <code>@Component</code>是任何 Spring-managed component 的通用构造型。 <code>@Repository</code>，<code>@Service</code>和<code>@Controller</code>是<code>@Component</code>的特化，用于更具体的用例(分别在持久性，服务和表示层中)。因此，您可以使用<code>@Component</code>注释 component classes，但是，通过使用<code>@Repository</code>，<code>@Service</code>或<code>@Controller</code>注释它们，您的 classes 更适合通过工具处理或与方面相关联。例如，这些构造型注释成为切入点的理想目标。 <code>@Repository</code>，<code>@Service</code>和<code>@Controller</code>还可以在 Spring Framework 的未来版本中携带其他语义。因此，如果您在服务层使用<code>@Component</code>或<code>@Service</code>之间进行选择，<code>@Service</code>显然是更好的选择。同样，如前所述，已经支持<code>@Repository</code>作为持久层中自动 exception 转换的标记。</p>
<h3 id="1-10-2-使用-Meta-annotations-和-Composed-Annotations"><a href="#1-10-2-使用-Meta-annotations-和-Composed-Annotations" class="headerlink" title="1.10.2.  使用 Meta-annotations 和 Composed Annotations"></a>1.10.2.  使用 Meta-annotations 和 Composed Annotations</h3><p>元注解的作用就是负责注解其他注解。Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。Java5.0定义的元注解：<br>　　　　1.@Target,<br>　　　　2.@Retention,<br>　　　　3.@Documented,<br>　　　　4.@Inherited</p>
<h3 id="1-10-3-自动检测-Classes-并注册-Bean-定义"><a href="#1-10-3-自动检测-Classes-并注册-Bean-定义" class="headerlink" title="1.10.3.  自动检测 Classes 并注册 Bean 定义"></a>1.10.3.  自动检测 Classes 并注册 Bean 定义</h3><p>Spring 可以自动检测原型 classes 并使用<code>ApplicationContext</code>注册相应的<code>BeanDefinition</code>实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleMovieLister</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JpaMovieFinder</span> <span class="keyword">implements</span> <span class="title">MovieFinder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// implementation elided for clarity</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要自动检测这些 classes 并注册相应的 beans，您需要将<code>@ComponentScan</code>添加到<code>@Configuration</code> class，其中<code>basePackages</code>属性是两个 classes 的 common parent 包。 </p>
<h3 id="1-10-4-使用过滤器自定义扫描"><a href="#1-10-4-使用过滤器自定义扫描" class="headerlink" title="1.10.4.  使用过滤器自定义扫描"></a>1.10.4.  使用过滤器自定义扫描</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;org.example&quot;,</span></span><br><span class="line"><span class="meta">        includeFilters = @Filter(type = FilterType.REGEX, pattern = &quot;.*Stub.*Repository&quot;),</span></span><br><span class="line"><span class="meta">        excludeFilters = @Filter(Repository.class))</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;org.example&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;regex&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">expression</span>=<span class="string">&quot;.*Stub.*Repository&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Repository&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-10-5-在组件中定义-Bean-元数据"><a href="#1-10-5-在组件中定义-Bean-元数据" class="headerlink" title="1.10.5.  在组件中定义 Bean 元数据"></a>1.10.5.  在组件中定义 Bean 元数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryMethodComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;public&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestBean <span class="title">publicInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TestBean(<span class="string">&quot;publicInstance&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Component method implementation omitted</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是在Bean的定义类中产生其他Bean，工厂类的概念。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryMethodComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;public&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestBean <span class="title">publicInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TestBean(<span class="string">&quot;publicInstance&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use of a custom qualifier and autowiring of method parameters</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> TestBean <span class="title">protectedInstance</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="meta">@Qualifier(&quot;public&quot;)</span> TestBean spouse,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="meta">@Value(&quot;#&#123;privateInstance.age&#125;&quot;)</span> String country)</span> </span>&#123;</span><br><span class="line">        TestBean tb = <span class="keyword">new</span> TestBean(<span class="string">&quot;protectedInstance&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        tb.setSpouse(spouse);</span><br><span class="line">        tb.setCountry(country);</span><br><span class="line">        <span class="keyword">return</span> tb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TestBean <span class="title">privateInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TestBean(<span class="string">&quot;privateInstance&quot;</span>, i++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@RequestScope</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestBean <span class="title">requestScopedInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TestBean(<span class="string">&quot;requestScopedInstance&quot;</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-10-6-自动检测命名的组件"><a href="#1-10-6-自动检测命名的组件" class="headerlink" title="1.10.6.  自动检测命名的组件"></a>1.10.6.  自动检测命名的组件</h3><p>当 component 作为 scan process 的一部分自动检测时，其 bean name 由该扫描程序已知的<code>BeanNameGenerator</code>策略生成。默认情况下，任何包含 name <code>value</code>的 Spring 构造型 annotation(<code>@Component</code>，<code>@Repository</code>，<code>@Service</code>和<code>@Controller</code>)都会将 name 提供给相应的 bean 定义。</p>
<p>如果这样的 annotation 不包含 name <code>value</code>或任何其他检测到的 component(例如自定义过滤器发现的那些)，则默认的 bean name generator 将返回未大写的 non-qualified class name。如果检测到以下 component classes，则名称将为<code>myMovieLister</code>和<code>movieFinderImpl</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;myMovieLister&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieFinderImpl</span> <span class="keyword">implements</span> <span class="title">MovieFinder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果您不想依赖默认的 bean-naming 策略，则可以提供自定义 bean-naming 策略。首先，实现<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/factory/support/BeanNameGenerator.html">BeanNameGenerator</a>接口，并确保包含默认的 no-arg 构造函数。然后，在配置扫描程序时提供完全限定的 class name，如下面的 example annotation 和 bean 定义所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;org.example&quot;, nameGenerator = MyNameGenerator.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;org.example&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">name-generator</span>=<span class="string">&quot;org.example.MyNameGenerator&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-10-7-为自动检测组件提供scope"><a href="#1-10-7-为自动检测组件提供scope" class="headerlink" title="1.10.7.  为自动检测组件提供scope"></a>1.10.7.  为自动检测组件提供scope</h3><p>与 Spring-managed 组件一样，自动检测组件的默认范围和最常见范围是<code>singleton</code>。但是，有时您需要一个可由<code>@Scope</code> annotation 指定的不同范围。您可以在 annotation 中提供范围的 name，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieFinderImpl</span> <span class="keyword">implements</span> <span class="title">MovieFinder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-10-8-使用-Annotations-提供限定符元数据"><a href="#1-10-8-使用-Annotations-提供限定符元数据" class="headerlink" title="1.10.8.  使用 Annotations 提供限定符元数据"></a>1.10.8.  使用 Annotations 提供限定符元数据</h3><h3 id="1-10-9-生成候选组件索引"><a href="#1-10-9-生成候选组件索引" class="headerlink" title="1.10.9.  生成候选组件索引"></a>1.10.9.  生成候选组件索引</h3><p>虽然 classpath 扫描非常快，但是可以通过在编译时创建候选的静态列表来改进大应用程序的启动性能。</p>
<p>要生成索引，请为包含作为 component scan 指令目标的组件的每个模块添加其他依赖项。以下 example 显示了如何使用 Maven 执行此操作：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-indexer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="1-12-使用java的容器配置"><a href="#1-12-使用java的容器配置" class="headerlink" title="1.12.  使用java的容器配置"></a>1.12.  使用java的容器配置</h2><p>本节介绍如何在 Java code 中使用 annotations 来配置 Spring 容器。它包括以下主题：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-java-basic-concepts">基本概念： @Bean 和 @Configuration</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-java-instantiating-container">使用 AnnotationConfigApplicationContext 实例化 Spring 容器</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-java-bean-annotation">使用 @Bean Annotation</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-java-configuration-annotation">使用 @Configuration annotation</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-java-composing-configuration-classes">编写 Java-based 配置</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-definition-profiles">Bean 定义 Profiles</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-property-source-abstraction">PropertySource 抽象</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-using-propertysource">使用 @PropertySource</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-placeholder-resolution-in-statements">Statements 中的占位符解析</a></li>
</ul>
<h3 id="1-12-1-Bean和-Configuration"><a href="#1-12-1-Bean和-Configuration" class="headerlink" title="1.12.1.  @Bean和@Configuration"></a>1.12.1.  @Bean和@Configuration</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyService <span class="title">myService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面的<code>AppConfig</code> class 等效于以下 Spring `` XML：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.acme.services.MyServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-12-2-使用-AnnotationConfigApplicationContext-实例化-Spring-容器"><a href="#1-12-2-使用-AnnotationConfigApplicationContext-实例化-Spring-容器" class="headerlink" title="1.12.2.  使用 AnnotationConfigApplicationContext 实例化 Spring 容器"></a>1.12.2.  使用 AnnotationConfigApplicationContext 实例化 Spring 容器</h3><h4 id="简单构造"><a href="#简单构造" class="headerlink" title="简单构造"></a>简单构造</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">    MyService myService = ctx.getBean(MyService.class);</span><br><span class="line">    myService.doStuff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用register构造"><a href="#使用register构造" class="headerlink" title="使用register构造"></a>使用register构造</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">    ctx.register(AppConfig.class, OtherConfig.class);</span><br><span class="line">    ctx.register(AdditionalConfig.class);</span><br><span class="line">    ctx.refresh();</span><br><span class="line">    MyService myService = ctx.getBean(MyService.class);</span><br><span class="line">    myService.doStuff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 no-arg 构造函数实例化<code>AnnotationConfigApplicationContext</code>，然后使用<code>register()</code>方法对其进行配置。</p>
<h4 id="使用scan：启用Component扫描"><a href="#使用scan：启用Component扫描" class="headerlink" title="使用scan：启用Component扫描"></a>使用scan：启用Component扫描</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.acme&quot;)</span> (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span>  </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">    ctx.scan(<span class="string">&quot;com.acme&quot;</span>);</span><br><span class="line">    ctx.refresh();</span><br><span class="line">    MyService myService = ctx.getBean(MyService.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-12-3-使用-Bean注解"><a href="#1-12-3-使用-Bean注解" class="headerlink" title="1.12.3.  使用@Bean注解"></a>1.12.3.  使用@Bean注解</h3><p>可以在@Component或者@Configuration注解的类下面使用@Bean注解。</p>
<h4 id="声明Bean"><a href="#声明Bean" class="headerlink" title="声明Bean"></a>声明Bean</h4><p>要声明 bean，可以使用<code>@Bean</code> annotation 注释方法。您可以使用此方法在指定为方法的 return value 的类型的<code>ApplicationContext</code>中注册 bean 定义。默认情况下， bean name 与方法 name 相同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransferServiceImpl <span class="title">transferService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Bean依赖项"><a href="#Bean依赖项" class="headerlink" title="Bean依赖项"></a>Bean依赖项</h4><p>如果我们的<code>TransferService</code>需要<code>AccountRepository</code>，我们可以使用方法参数来实现该依赖关系，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransferService <span class="title">transferService</span><span class="params">(AccountRepository accountRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl(accountRepository);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接收生命周期回调"><a href="#接收生命周期回调" class="headerlink" title="接收生命周期回调"></a>接收生命周期回调</h4><p>使用<code>@Bean</code> annotation 定义的任何 classes 都支持常规生命周期回调，并且可以使用 JSR-250 中的<code>@PostConstruct</code>和<code>@PreDestroy</code> 注释。</p>
<p><code>@Bean</code> annotation 支持指定任意初始化和销毁回调方法，就像<code>bean</code>元素上 Spring XML 的<code>init-method</code>和<code>destroy-method</code>属性一样，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanOne</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// initialization logic</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanTwo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// destruction logic</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(initMethod = &quot;init&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanOne <span class="title">beanOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BeanOne();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(destroyMethod = &quot;cleanup&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanTwo <span class="title">beanTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BeanTwo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，使用具有公共<code>close</code>或<code>shutdown</code>方法的 Java configuration 定义的 beans 将自动使用销毁回调登记。如果您有一个公共的<code>close</code>或<code>shutdown</code>方法，并且您不希望在容器关闭时调用它，则可以将<code>@Bean(destroyMethod=&quot;&quot;)</code>添加到 bean 定义以禁用默认的<code>(inferred)</code>模式。</p>
<h4 id="指定Bean范围"><a href="#指定Bean范围" class="headerlink" title="指定Bean范围"></a>指定Bean范围</h4><p>Spring 包含<code>@Scope</code> annotation，以便您可以指定 bean 的范围。</p>
<p>默认范围是<code>singleton</code>，但您可以使用<code>@Scope</code> annotation 覆盖它，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Encryptor <span class="title">encryptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring 提供了一种通过<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-other-injection">范围代理</a>处理作用域依赖项的便捷方式。使用 XML configuration 时创建此类代理的最简单方法是``元素。使用<code>@Scope</code> annotation 在 Java 中配置 beans 可提供与<code>proxyMode</code>属性的等效支持。默认值为无代理(<code>ScopedProxyMode.NO</code>)，但您可以指定<code>ScopedProxyMode.TARGET_CLASS</code>或<code>ScopedProxyMode.INTERFACES</code>。</p>
<p>如果使用 Java 将 XML 范围内的 scoped proxy example port(请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-other-injection">范围代理</a>)传递到我们的<code>@Bean</code>，它类似于以下内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// an HTTP Session-scoped bean exposed as a proxy</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@SessionScope</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserPreferences <span class="title">userPreferences</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UserPreferences();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Service <span class="title">userService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UserService service = <span class="keyword">new</span> SimpleUserService();</span><br><span class="line">    <span class="comment">// a reference to the proxied userPreferences bean</span></span><br><span class="line">    service.setUserPreferences(userPreferences());</span><br><span class="line">    <span class="keyword">return</span> service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="lt-aop-scoped-proxy-gt"><a href="#lt-aop-scoped-proxy-gt" class="headerlink" title="&lt;aop:scoped-proxy/&gt;"></a>&lt;aop:scoped-proxy/&gt;</h4><p>Spring的Bean是有scope属性的，表示bean的生存周期。scope的值有prototype、singleton、session、request。那么就有个问题了，如果一个singleton的bean中引用了一个prototype的bean，结果会怎样呢？在默认情况下，单例会永远持有一开始构造所赋给它的值。</p>
<p>所以，为了让我们在每次调用这个Bean的时候都能够得到具体scope中的值，比如prototype，那么我们希望每次在单例中调用这个Bean的时候，得到的都是一个新的prototype，Spring中AOP名字空间中引入了这个标签<strong>&lt;aop:scoped-proxy/&gt;</strong> <strong>。</strong></p>
<h4 id="自定义Bean命名"><a href="#自定义Bean命名" class="headerlink" title="自定义Bean命名"></a>自定义Bean命名</h4><p>默认情况下，configuration classes 使用<code>@Bean</code>方法的 name 作为生成的 bean 的 name。但是，使用<code>name</code>属性可以覆盖此功能，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;myThing&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thing <span class="title">thing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Bean别名"><a href="#Bean别名" class="headerlink" title="Bean别名"></a>Bean别名</h4><p><code>@Bean</code> annotation 的<code>name</code>属性接受 String array。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&#123;&quot;dataSource&quot;, &quot;subsystemA-dataSource&quot;, &quot;subsystemB-dataSource&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// instantiate, configure and return DataSource bean...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Bean描述"><a href="#Bean描述" class="headerlink" title="Bean描述"></a>Bean描述</h4><p>有时，提供 bean 的更详细的文本描述是有帮助的。当 beans 暴露(可能通过 JMX)用于监视目的时，这可能特别有用。</p>
<p>要向<code>@Bean</code>添加描述，可以使用<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/context/annotation/Description.html">@Description</a> annotation，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Description(&quot;Provides a basic example of a bean&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thing <span class="title">thing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-12-4-使用-Configuration注解"><a href="#1-12-4-使用-Configuration注解" class="headerlink" title="1.12.4.  使用@Configuration注解"></a>1.12.4.  使用@Configuration注解</h3><p><code>@Configuration</code>是 class-level annotation，表示 object 是 bean 定义的来源。</p>
<h4 id="注入Inter-bean依赖项"><a href="#注入Inter-bean依赖项" class="headerlink" title="注入Inter-bean依赖项"></a>注入Inter-bean依赖项</h4><p>当 beans 彼此依赖时，表达该依赖关系就像让一个 bean 方法调用另一个一样简单，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanOne <span class="title">beanOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BeanOne(beanTwo());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanTwo <span class="title">beanTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BeanTwo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="look-up方法注入"><a href="#look-up方法注入" class="headerlink" title="look-up方法注入"></a>look-up方法注入</h4><p>如前所述，<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-method-injection">查找方法注入</a>是一种您应该很少使用的高级 feature。在 singleton-scoped bean 依赖于 prototype-scoped bean 的情况下，它很有用。使用 Java 进行此类型的 configuration 提供了实现此 pattern 的自然方法。以下 example 显示了如何使用查找方法注入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandManager</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">process</span><span class="params">(Object commandState)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// grab a new instance of the appropriate Command interface</span></span><br><span class="line">        Command command = createCommand();</span><br><span class="line">        <span class="comment">// set the state on the (hopefully brand new) Command instance</span></span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="keyword">return</span> command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// okay... but where is the implementation of this method?</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Command <span class="title">createCommand</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过使用 Java configuration，您可以创建<code>CommandManager</code>的子类，其中抽象<code>createCommand()</code>方法被覆盖，以便查找新的(原型)命令 object。以下 example 显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AsyncCommand <span class="title">asyncCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AsyncCommand command = <span class="keyword">new</span> AsyncCommand();</span><br><span class="line">    <span class="comment">// inject dependencies here as required</span></span><br><span class="line">    <span class="keyword">return</span> command;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommandManager <span class="title">commandManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// return new anonymous implementation of CommandManager with command() overridden</span></span><br><span class="line">    <span class="comment">// to return a new prototype Command object</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CommandManager() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Command <span class="title">createCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> asyncCommand();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-12-5-撰写Java-based配置"><a href="#1-12-5-撰写Java-based配置" class="headerlink" title="1.12.5.  撰写Java-based配置"></a>1.12.5.  撰写Java-based配置</h3><h4 id="import"><a href="#import" class="headerlink" title="@import"></a>@import</h4><p>@import可以从另一个Configuration类中加载@Bean定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> A <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(ConfigA.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> B <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，在实例化 context 时，不需要同时指定<code>ConfigA.class</code>和<code>ConfigB.class</code>，只需要显式提供<code>ConfigB</code></p>
<p>这种方法简化了容器实例化，因为只需要处理一个 class，而不是要求你在构造期间记住可能大量的<code>@Configuration</code> classes。</p>
<h4 id="在导入的-Bean-定义上注入依赖项"><a href="#在导入的-Bean-定义上注入依赖项" class="headerlink" title="在导入的 @Bean 定义上注入依赖项"></a>在导入的 @Bean 定义上注入依赖项</h4><p>在大多数实际场景中，beans 在 configuration classes 之间依赖于彼此。使用 XML 时，这不是问题，因为不涉及编译器，并且您可以在容器初始化期间声明<code>ref=&quot;someBean&quot;</code>并信任 Spring 来解决它。使用<code>@Configuration</code> classes 时，Java 编译器会在 configuration model 上设置约束，因为对其他 beans 的引用必须是有效的 Java 语法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransferService <span class="title">transferService</span><span class="params">(AccountRepository accountRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl(accountRepository);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RepositoryConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AccountRepository <span class="title">accountRepository</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcAccountRepository(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(&#123;ServiceConfig.class, RepositoryConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemTestConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// return new DataSource</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(SystemTestConfig.class);</span><br><span class="line">    <span class="comment">// everything wires up across configuration classes...</span></span><br><span class="line">    TransferService transferService = ctx.getBean(TransferService.class);</span><br><span class="line">    transferService.transfer(<span class="number">100.00</span>, <span class="string">&quot;A123&quot;</span>, <span class="string">&quot;C456&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="结合-Java-和-XML-Configuration"><a href="#结合-Java-和-XML-Configuration" class="headerlink" title="结合 Java 和 XML Configuration"></a>结合 Java 和 XML Configuration</h4><p>请记住，<code>@Configuration</code> classes 最终是容器中的 bean 定义。在本系列示例中，我们创建一个名为<code>AppConfig</code>的<code>@Configuration</code> class，并将其作为``定义包含在<code>system-test-config.xml</code>中。因为<code>context:annotation-config</code>已打开，容器会识别<code>@Configuration</code> annotation 并正确处理<code>AppConfig</code>中声明的<code>@Bean</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AccountRepository <span class="title">accountRepository</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcAccountRepository(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransferService <span class="title">transferService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransferService(accountRepository());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- enable processing of annotations such as @Autowired and @Configuration --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:/com/acme/jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.acme.AppConfig&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>因为<code>@Configuration</code>是带有<code>@Component</code>的 meta-annotated，<code>@Configuration</code> -annotated classes 自动成为 component 扫描的候选者。使用与上一个 example 中描述的相同的场景，我们可以重新定义<code>system-test-config.xml</code>以利用 component-scanning。请注意，在这种情况下，我们不需要显式声明<code>context:annotation-config</code>，因为<code>context:component-scan</code>启用相同的功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportResource(&quot;classpath:/com/acme/properties-config.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DriverManagerDataSource(url, username, password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-13-环境抽象"><a href="#1-13-环境抽象" class="headerlink" title="1.13.  环境抽象"></a>1.13.  环境抽象</h2><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/core/env/Environment.html">环境</a>接口是集成在容器中的抽象，它为 application 环境的两个 key 方面建模：<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-definition-profiles">profiles</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-property-source-abstraction">properties</a>。</p>
<p>profile 是 bean 定义的命名逻辑 group，仅当给定的 profile 为 active 时才向容器注册。 Beans 可以分配给 profile，无论是用 XML 定义还是用 annotations 定义。与 profiles 相关的<code>Environment</code> object 的作用是确定哪些 profiles(如果有)当前是 active，以及哪些 profiles(如果有)默认情况下应该 active。</p>
<p>Properties 在几乎所有 applications 中都发挥着重要作用，可能来自各种来源：properties files，JVM 系统 properties，系统环境变量，JNDI，servlet context 参数，ad-hoc <code>Properties</code> objects，<code>Map</code>objects 等等。与 properties 相关的<code>Environment</code> object 的作用是为用户提供方便的服务接口，用于配置 property 源和从中解析 properties。</p>
<h3 id="1-13-1-Bean定义Profile"><a href="#1-13-1-Bean定义Profile" class="headerlink" title="1.13.1.  Bean定义Profile"></a>1.13.1.  Bean定义Profile</h3><p>Bean 定义 profiles 在核心容器中提供了一种机制，允许在不同的环境中注册不同的 beans。</p>
<p>Spring中的Profile功能其实早在Spring 3.1的版本就已经出来，它可以理解为我们在Spring容器中所定义的Bean的<strong>逻辑组名称</strong>，只有当这些Profile被激活的时候，才会将Profile中所对应的Bean注册到Spring容器中。</p>
<h4 id="使用-Profile"><a href="#使用-Profile" class="headerlink" title="使用@Profile"></a>使用@Profile</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Profile(&quot;dev&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DevConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanOne <span class="title">getBeanOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BeanOne one = <span class="keyword">new</span> BeanOne();</span><br><span class="line">        one.setName(<span class="string">&quot;devBeanOne&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> one;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Profile(&quot;test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanOne <span class="title">getBeanOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BeanOne one = <span class="keyword">new</span> BeanOne();</span><br><span class="line">        one.setName(<span class="string">&quot;testBeanOne&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> one;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>profile string 可能包含一个简单的 profile name(用于 example，<code>production</code>)或一个 profile 表达式。 profile 表达式允许表达更复杂的 profile 逻辑(对于 example，<code>production &amp; us-east</code>)。 profile 表达式支持以下 operators：</p>
<ul>
<li><code>!</code>：profile 的逻辑“not”</li>
<li><code>&amp;</code>：profiles 的逻辑“和”</li>
<li><code>|</code>：profiles 的逻辑“或”</li>
</ul>
<p>如果不使用括号，则无法混合<code>&amp;</code>和<code>|</code> 运算符。对于 example，<code>production &amp; us-east | eu-central</code>不是有效的表达式。它必须表示为<code>production &amp; (us-east | eu-central)</code>。</p>
<p>可以使用<code>@Profile</code>作为<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-meta-annotations">meta-annotation</a>来创建自定义组合注释。以下 example 定义了一个自定义<code>@Production</code> 注释，您可以将其用作<code>@Profile(&quot;production&quot;)</code>的 drop-in 替换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Profile(&quot;production&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Production &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Profile</code>也可以在 level 方法中声明，只包含 configuration class 的一个特定 bean(对于 example，对于特定 bean 的替代变体)，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;dataSource&quot;)</span></span><br><span class="line">    <span class="meta">@Profile(&quot;development&quot;)</span> (<span class="number">1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">standaloneDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder()</span><br><span class="line">            .setType(EmbeddedDatabaseType.HSQL)</span><br><span class="line">            .addScript(<span class="string">&quot;classpath:com/bank/config/sql/schema.sql&quot;</span>)</span><br><span class="line">            .addScript(<span class="string">&quot;classpath:com/bank/config/sql/test-data.sql&quot;</span>)</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;dataSource&quot;)</span></span><br><span class="line">    <span class="meta">@Profile(&quot;production&quot;)</span> (<span class="number">2</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">jndiDataSource</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Context ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">        <span class="keyword">return</span> (DataSource) ctx.lookup(<span class="string">&quot;java:comp/env/jdbc/datasource&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用@import把两个配置文件导入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(&#123;DevConfig.class, TestConfig.class&#125;)</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;hsp&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClass</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="variable">@ContextConfiguration</span>(classes = &#123;ConfigClass.class&#125;)</span><br><span class="line"><span class="variable">@ActiveProfiles</span>(<span class="string">&quot;dev&quot;</span>)</span><br><span class="line">public class TestAll &#123;</span><br><span class="line">    <span class="variable">@Autowired</span></span><br><span class="line">    private BeanOne beanOne;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Test</span></span><br><span class="line">    public void testProfile() &#123;</span><br><span class="line">        <span class="selector-tag">System</span><span class="selector-class">.out</span><span class="selector-class">.println</span>(beanOne.getName());</span><br><span class="line">        <span class="comment">//devBeanOne</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="激活Profile"><a href="#激活Profile" class="headerlink" title="激活Profile"></a>激活Profile</h4><p>激活 profile 可以通过多种方式完成，但最直接的方法是以编程方式对<code>Environment</code> API 进行编程，这可以通过<code>ApplicationContext</code>获得。以下 example 显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">ctx.getEnvironment().setActiveProfiles(<span class="string">&quot;development&quot;</span>);</span><br><span class="line">ctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);</span><br><span class="line">ctx.refresh();</span><br></pre></td></tr></table></figure>

<p>此外，您还可以通过<code>spring.profiles.active</code> property 声明性地激活 profile，这可以通过系统环境变量，<code>web.xml</code>中的 JVM 系统 properties，servlet context 参数指定，甚至可以作为 JNDI 中的条目指定(请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-property-source-abstraction">PropertySource 抽象</a>)。</p>
<h4 id="默认Profile"><a href="#默认Profile" class="headerlink" title="默认Profile"></a>默认Profile</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Profile(&quot;default&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultDataConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder()</span><br><span class="line">            .setType(EmbeddedDatabaseType.HSQL)</span><br><span class="line">            .addScript(<span class="string">&quot;classpath:com/bank/config/sql/schema.sql&quot;</span>)</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您可以使用<code>Environment</code>上的<code>setDefaultProfiles()</code>或使用<code>spring.profiles.default</code> property 声明性地更改默认 profile 的 name。</p>
<h3 id="1-13-2-PropertySource抽象"><a href="#1-13-2-PropertySource抽象" class="headerlink" title="1.13.2.  PropertySource抽象"></a>1.13.2.  PropertySource抽象</h3><p>Spring 的<code>Environment</code>抽象提供了 property 源的可配置层次结构上的搜索操作。请考虑以下列表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx = <span class="keyword">new</span> GenericApplicationContext();</span><br><span class="line">Environment env = ctx.getEnvironment();</span><br><span class="line"><span class="keyword">boolean</span> containsMyProperty = env.containsProperty(<span class="string">&quot;my-property&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Does my environment contain the &#x27;my-property&#x27; property? &quot;</span> + containsMyProperty);</span><br></pre></td></tr></table></figure>

<p>在前面的代码片段中，我们看到 high-level 方式询问 Spring 是否为当前环境定义了<code>my-property</code> property。要回答这个问题，<code>Environment</code> object 会对一组<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/core/env/PropertySource.html">PropertySource</a> objects 执行搜索。 <code>PropertySource</code>是对 key-value 对的任何源的简单抽象，Spring 的<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/core/env/StandardEnvironment.html">StandardEnvironment</a>配置有两个 PropertySource objects - 一个表示 JVM 系统 properties(<code>System.getProperties()</code>)的集合，另一个表示系统环境变量集(<code>System.getenv()</code>)。</p>
<h3 id="1-13-3-使用-PropertySource"><a href="#1-13-3-使用-PropertySource" class="headerlink" title="1.13.3.  使用@PropertySource"></a>1.13.3.  使用@PropertySource</h3><p>新建一个app.properties</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">testbean.name</span>=BeanOne</span><br></pre></td></tr></table></figure>

<p>配置类ConfigClass.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:app.properties&quot;)</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;hsp&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClass</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Environment env;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;one&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanOne <span class="title">getBeanOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BeanOne one = <span class="keyword">new</span> BeanOne();</span><br><span class="line">        one.setName(env.getProperty(<span class="string">&quot;testbean.name&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> one;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = &#123;ConfigClass.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAll</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;one&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> BeanOne beanOne;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testProfile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(beanOne.getName());</span><br><span class="line">        <span class="comment">//BeanOne</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-13-4-Statements-中的占位符解析"><a href="#1-13-4-Statements-中的占位符解析" class="headerlink" title="1.13.4.  Statements 中的占位符解析"></a>1.13.4.  Statements 中的占位符解析</h3><h2 id="1-14-注册-LoadTimeWeaver"><a href="#1-14-注册-LoadTimeWeaver" class="headerlink" title="1.14.  注册 LoadTimeWeaver"></a>1.14.  注册 LoadTimeWeaver</h2><p>用于在 classes 加载到 Java 虚拟机(JVM)时动态转换 class。</p>
<p>要启用 load-time 编织，您可以将<code>@EnableLoadTimeWeaving</code>添加到一个<code>@Configuration</code> classes 中，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableLoadTimeWeaving</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者，对于 XML configuration，您可以使用<code>context:load-time-weaver</code>元素：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:load-time-weaver</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>一旦为<code>ApplicationContext</code>配置，该<code>ApplicationContext</code>中的任何 bean 都可以实现<code>LoadTimeWeaverAware</code>，从而接收 load-time weaver 实例的 reference。这与<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#orm-jpa">Spring 的 JPA 支持</a>结合使用特别有用，其中 load-time 编织可能是 JPA class 转换所必需的。有关更多详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/orm/jpa/LocalContainerEntityManagerFactoryBean.html">LocalContainerEntityManagerFactoryBean</a> javadoc。有关 AspectJ load-time 编织的更多信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-aj-ltw">Load-time 在 Spring Framework 中使用 AspectJ 进行编织</a>。</p>
<h2 id="1-15-ApplicationContext-的附加功能"><a href="#1-15-ApplicationContext-的附加功能" class="headerlink" title="1.15.  ApplicationContext 的附加功能"></a>1.15.  ApplicationContext 的附加功能</h2><h3 id="1-15-1-使用-MessageSource-进行国际化"><a href="#1-15-1-使用-MessageSource-进行国际化" class="headerlink" title="1.15.1.  使用 MessageSource 进行国际化"></a>1.15.1.  使用 MessageSource 进行国际化</h3><p><code>ApplicationContext</code>接口扩展了一个名为<code>MessageSource</code>的接口，因此提供了国际化(“i18n”)功能。 Spring 还提供<code>HierarchicalMessageSource</code>接口，可以分层次地解析消息。这些接口共同提供了 Spring 效果消息解析的基础。这些接口上定义的方法包括：</p>
<ul>
<li><code>String getMessage(String code, Object[] args, String default, Locale loc)</code>：用于从<code>MessageSource</code>检索消息的基本方法。如果未找到指定 locale 的消息，则使用默认消息。传入的任何 arguments 都使用标准 library 提供的<code>MessageFormat</code>功能成为替换值。</li>
<li><code>String getMessage(String code, Object[] args, Locale loc)</code>：与前一个方法基本相同，但有一点不同：无法指定默认消息。如果找不到该消息，则抛出<code>NoSuchMessageException</code>。</li>
<li><code>String getMessage(MessageSourceResolvable resolvable, Locale locale)</code>：前面方法中使用的所有 properties 也包装在一个名为<code>MessageSourceResolvable</code>的 class 中，您可以使用此方法。</li>
</ul>
<h3 id="1-15-2-标准和自定义事件"><a href="#1-15-2-标准和自定义事件" class="headerlink" title="1.15.2.  标准和自定义事件"></a>1.15.2.  标准和自定义事件</h3><p>通过<code>ApplicationEvent</code> class 和<code>ApplicationListener</code>接口提供<code>ApplicationContext</code>中的 Event 处理。如果实现<code>ApplicationListener</code>接口的 bean 被部署到 context 中，那么每次Bean被发布到<code>ApplicationContext</code>都会收到通知。</p>
<p>以下 table 描述了 Spring 提供的标准 events：</p>
<table>
<thead>
<tr>
<th align="left">事件</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>ContextRefreshedEvent</code></td>
<td align="left">初始化或刷新<code>ApplicationContext</code>时发布(例如，通过<code>ConfigurableApplicationContext</code>接口使用<code>refresh()</code>方法)。这里，“初始化”意味着所有 beans 都被加载，post-processor beans 被检测并激活，单例是 pre-instantiated，<code>ApplicationContext</code>object 可以使用了。如果 context 尚未关闭，则可以多次触发刷新，前提是所选的<code>ApplicationContext</code>实际上支持这种“热”刷新。例如，<code>XmlWebApplicationContext</code>支持热刷新，但<code>GenericApplicationContext</code>不支持。</td>
</tr>
<tr>
<td align="left"><code>ContextStartedEvent</code></td>
<td align="left">通过在<code>ConfigurableApplicationContext</code>接口上使用<code>start()</code>方法启动<code>ApplicationContext</code>时发布。这里，“已启动”意味着所有<code>Lifecycle</code> beans 都会收到明确的启动信号。通常，此信号用于在显式停止后重新启动 beans，但它也可用于启动尚未为自动启动配置的组件(对于 example，尚未在初始化时启动的组件)。</td>
</tr>
<tr>
<td align="left"><code>ContextStoppedEvent</code></td>
<td align="left">通过在<code>ConfigurableApplicationContext</code>接口上使用<code>stop()</code>方法停止<code>ApplicationContext</code>时发布。这里，“停止”意味着所有<code>Lifecycle</code> beans 都会收到明确的停止信号。可以通过<code>start()</code>调用重新启动已停止的 context。</td>
</tr>
<tr>
<td align="left"><code>ContextClosedEvent</code></td>
<td align="left">通过在<code>ConfigurableApplicationContext</code>接口上使用<code>close()</code>方法关闭<code>ApplicationContext</code>时发布。在这里，“关闭”意味着所有 singleton beans 都被销毁。封闭的 context 到达其生命的终点。它无法刷新或重新启动。</td>
</tr>
<tr>
<td align="left"><code>RequestHandledEvent</code></td>
<td align="left">web-specific event 告诉所有 beans 已经为 HTTP 请求提供服务。请求完成后发布此 event。此 event 仅适用于使用 Spring 的<code>DispatcherServlet</code>的 web applications。</td>
</tr>
</tbody></table>
<p>自定义一个需要监听的Event</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplicationEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object source;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSource</span><span class="params">(Object source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.source = source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTest</span><span class="params">(String test)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.test = test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> String test;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyApplicationEvent</span><span class="params">(Object source, String address, String test)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">        <span class="keyword">this</span>.test = test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MyApplicationEvent&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;source=&quot;</span> + source +</span><br><span class="line">                <span class="string">&quot;, address=&#x27;&quot;</span> + address + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, test=&#x27;&quot;</span> + test + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想要发布我们的自定义事件,就需要调用ApplicationEventPublisher类中的publishEvent()方法 。官方文档中是叫我们创建一个实现ApplicationEventPublisherAware的类，并且注册为spring中的bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplicationEventService</span> <span class="keyword">implements</span> <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; blackList;</span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher publisher;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher applicationEventPublisher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.publisher = applicationEventPublisher;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">(String address, String text)</span> </span>&#123;</span><br><span class="line">        blackList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        blackList.add(<span class="string">&quot;111111@qq.com&quot;</span>);</span><br><span class="line">        blackList.add(<span class="string">&quot;123@cc.com&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (blackList.contains(address)) &#123;</span><br><span class="line">            publisher.publishEvent(<span class="keyword">new</span> MyApplicationEvent(<span class="keyword">this</span>, address, text));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testListener</span><span class="params">(String address, String text)</span> </span>&#123;</span><br><span class="line">        MyApplicationEvent event = <span class="keyword">new</span> MyApplicationEvent(<span class="keyword">this</span>, address, text);</span><br><span class="line">        publisher.publishEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在配置的时候，Spring容器会检测到这个MyApplicationEventService实现 ApplicationEventPublisherAware并自动调用 setApplicationEventPublisher()。实际上，传入的参数将是Spring容器本身; 您只需通过其ApplicationEventPublisher接口与应用程序上下文进行 交互。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplicationListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">MyApplicationEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(MyApplicationEvent myApplicationEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;my listener start&quot;</span>);</span><br><span class="line">        System.out.println(myApplicationEvent.toString());</span><br><span class="line">        System.out.println(<span class="string">&quot;my listener end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="基于注解的时间监听器"><a href="#基于注解的时间监听器" class="headerlink" title="基于注解的时间监听器"></a>基于注解的时间监听器</h4><p>基于注解的话，Listener不需要实现接口，只需要注解就可以</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplicationListener</span></span>&#123;</span><br><span class="line">    <span class="meta">@EventListener(MyApplicationEvent.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(MyApplicationEvent myApplicationEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;my listener start&quot;</span>);</span><br><span class="line">        System.out.println(myApplicationEvent.toString());</span><br><span class="line">        System.out.println(<span class="string">&quot;my listener end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以加上判断条件，如果条件不成立，不会调用该listener。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplicationListener</span></span>&#123;</span><br><span class="line">    <span class="meta">@EventListener(value = MyApplicationEvent.class, condition = &quot;#event.test==&#x27;hi&#x27;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(MyApplicationEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;my listener start&quot;</span>);</span><br><span class="line">        System.out.println(event.toString());</span><br><span class="line">        System.out.println(<span class="string">&quot;my listener end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="异步Listeners"><a href="#异步Listeners" class="headerlink" title="异步Listeners"></a>异步Listeners</h4><p>如果希望特定的Listener异步处理events，则可以用@Async</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplicationListener</span></span>&#123;</span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(MyApplicationEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;my listener start&quot;</span>);</span><br><span class="line">        System.out.println(event.toString());</span><br><span class="line">        System.out.println(<span class="string">&quot;my listener end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用异步 events 时请注意以下限制：</p>
<ul>
<li>如果 event listener 抛出<code>Exception</code>，则它不会传播给调用者有关详细信息，请参阅<code>AsyncUncaughtExceptionHandler</code>。</li>
<li>这样的 event listener 无法发送回复。如果您需要作为处理结果发送另一个 event，inject <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/aop/interceptor/AsyncUncaughtExceptionHandler.html">ApplicationEventPublisher</a>手动发送 event。</li>
</ul>
<h4 id="给listener定义顺序"><a href="#给listener定义顺序" class="headerlink" title="给listener定义顺序"></a>给listener定义顺序</h4><p>如果需要在另一个 listener 之前调用一个 listener，可以将<code>@Order</code> annotation 添加到方法声明中，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EventListener</span></span><br><span class="line"><span class="meta">@Order(42)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processBlackListEvent</span><span class="params">(BlackListEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// notify appropriate parties via notificationAddress...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="泛型化Events"><a href="#泛型化Events" class="headerlink" title="泛型化Events"></a>泛型化Events</h4><p>您还可以使用泛型来进一步定义 event 的结构。考虑使用<code>EntityCreatedEvent</code>，其中<code>T</code>是创建的实际实体的类型。对于 example，您可以创建以下 listener 定义以仅接收<code>EntityCreatedEvent</code>的<code>EntityCreatedEvent</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EventListener</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPersonCreated</span><span class="params">(EntityCreatedEvent&lt;Person&gt; event)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于类型擦除，仅当被触发的 event 解析 event listener 过滤器的通用参数(即<code>class PersonCreatedEvent extends EntityCreatedEvent &#123; … &#125;</code>之类的东西)时，此方法才有效。</p>
<h3 id="1-15-3-方便的访问Low-level资源"><a href="#1-15-3-方便的访问Low-level资源" class="headerlink" title="1.15.3.  方便的访问Low-level资源"></a>1.15.3.  方便的访问Low-level资源</h3><p>application context 是<code>ResourceLoader</code>，可用于加载<code>Resource</code> objects。</p>
<p>您可以配置部署到 application context 中的 bean 来实现特殊的回调接口<code>ResourceLoaderAware</code>，在初始化时自动回调，application context 本身作为<code>ResourceLoader</code>传入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyResourceLoader</span> <span class="keyword">implements</span> <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ResourceLoader loader;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Set resource Loader&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.loader = resourceLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-16-BeanFactory"><a href="#1-16-BeanFactory" class="headerlink" title="1.16.  BeanFactory"></a>1.16.  BeanFactory</h2><p><code>BeanFactory</code> API 为 Spring 的 IoC 功能提供了基础。它主要用于与 Spring 和相关 third-party 框架的其他部分进行整合，其<code>DefaultListableBeanFactory</code>实现是 higher-level <code>GenericApplicationContext</code>容器中的 key 委托。</p>
<p><code>BeanFactory</code>和相关接口(例如<code>BeanFactoryAware</code>，<code>InitializingBean</code>，<code>DisposableBean</code>)是其他 framework 组件的重要集成点。通过不需要任何注释或甚至反射，它们允许容器与其组件之间的非常有效的交互。 Application-level beans 可以使用相同的回调接口，但通常更推荐声明性依赖注入，通过 annotations 或通过编程 configuration。</p>
<p>请注意，核心<code>BeanFactory</code> API level 及其<code>DefaultListableBeanFactory</code> implementation 不会对 configuration 格式或要使用的任何 component annotations 进行假设。所有这些风格都通过 extensions(例如<code>XmlBeanDefinitionReader</code>和<code>AutowiredAnnotationBeanPostProcessor</code>)进入，并作为核心元数据表示在共享<code>BeanDefinition</code> objects 上运行。这就是 Spring 容器如此灵活和可扩展的本质。</p>
<h3 id="1-16-1-BeanFactory或ApplicationContext"><a href="#1-16-1-BeanFactory或ApplicationContext" class="headerlink" title="1.16.1.  BeanFactory或ApplicationContext"></a>1.16.1.  BeanFactory或ApplicationContext</h3><p>您应该使用<code>ApplicationContext</code>，除非您有充分的理由不这样做，<code>GenericApplicationContext</code>及其子类<code>AnnotationConfigApplicationContext</code>作为自定义引导的 common implementations。这些是 Spring 核心容器的主要入口点，适用于所有 common 目的：加载配置文件，触发 classpath 扫描，以编程方式注册 bean 定义和带注释的 classes，以及(截至 5.0)注册功能 bean 定义。</p>
<h1 id="2-资源"><a href="#2-资源" class="headerlink" title="2.资源"></a>2.资源</h1><p>本章介绍 Spring 如何处理资源以及如何使用 Spring 中的资源。它包括以下主题：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources-introduction">介绍</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources-resource">资源接口</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources-implementations">Built-in 资源 Implementations</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources-resourceloader">ResourceLoader</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources-resourceloaderaware">ResourceLoaderAware 接口</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources-as-dependencies">资源作为依赖关系</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources-app-ctx">Application Contexts 和 Resource Paths</a></li>
</ul>
<h2 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1.  介绍"></a>2.1.  介绍</h2><p>Java 的标准<code>java.net.URL</code> class 和各种 URL 前缀的标准处理程序不足以完全访问 low-level 资源。</p>
<h2 id="2-2-资源接口"><a href="#2-2-资源接口" class="headerlink" title="2.2.  资源接口"></a>2.2.  资源接口</h2><p>Spring 的<code>Resource</code>接口是一个更强大的接口，用于抽象对 low-level 资源的访问。以下清单显示了<code>Resource</code>接口定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Resource</span> <span class="keyword">extends</span> <span class="title">InputStreamSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">exists</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">URL <span class="title">getURL</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">File <span class="title">getFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Resource <span class="title">createRelative</span><span class="params">(String relativePath)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getFilename</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正如<code>Resource</code>接口的定义所示，它扩展了<code>InputStreamSource</code>接口。以下清单显示了<code>InputStreamSource</code>接口的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InputStreamSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-内建Resource的实现类"><a href="#2-3-内建Resource的实现类" class="headerlink" title="2.3.  内建Resource的实现类"></a>2.3.  内建Resource的实现类</h2><p>Spring 包括以下<code>Resource</code> implementations：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources-implementations-urlresource">UrlResource 对象</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources-implementations-classpathresource">使用 ClassPathResource</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources-implementations-filesystemresource">FileSystemResource</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources-implementations-servletcontextresource">ServletContextResource</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources-implementations-inputstreamresource">InputStreamResource</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources-implementations-bytearrayresource">使用 ByteArrayResource</a></li>
</ul>
<h3 id="2-3-1-UrlResource对象"><a href="#2-3-1-UrlResource对象" class="headerlink" title="2.3.1.  UrlResource对象"></a>2.3.1.  UrlResource对象</h3><p><code>UrlResource</code>包装<code>java.net.URL</code>，可用于访问通常可通过 URL 访问的任何 object，例如 files，HTTP 目标，FTP 目标等。所有 URL 都具有标准化的<code>String</code>表示，使得适当的标准化前缀用于指示来自另一个的一种 URL 类型。这包括<code>file:</code>用于访问文件系统path，<code>http:</code>用于通过 HTTP 协议访问资源，<code>ftp:</code>用于通过 FTP 访问资源</p>
<p>如果路径 string 包含已知前缀(例如<code>classpath:</code>)，它会为该前缀创建一个适当的专用<code>Resource</code>。但是，如果它不识别前缀，则假定 string 是标准 URL string 并创建<code>UrlResource</code>。</p>
<h3 id="2-3-2-使用ClassPathResource"><a href="#2-3-2-使用ClassPathResource" class="headerlink" title="2.3.2.  使用ClassPathResource"></a>2.3.2.  使用ClassPathResource</h3><p>JavaBeans <code>PropertyEditor</code>在 string 路径上识别特殊前缀<code>classpath:</code>，并在这种情况下创建<code>ClassPathResource</code>。</p>
<h3 id="2-3-3-FileSystemResource"><a href="#2-3-3-FileSystemResource" class="headerlink" title="2.3.3.  FileSystemResource"></a>2.3.3.  FileSystemResource</h3><p>这是<code>java.io.File</code>和<code>java.nio.file.Path</code>句柄的<code>Resource</code> implementation。它支持分辨率为<code>File</code>和<code>URL</code>。</p>
<h3 id="2-3-4-ServletContext"><a href="#2-3-4-ServletContext" class="headerlink" title="2.3.4.  ServletContext"></a>2.3.4.  ServletContext</h3><p>用于解释相关 web application 根目录中的相对路径。</p>
<p>它始终支持流访问和 URL 访问，但只有在扩展 web application 存档且资源实际位于文件系统上时才允许<code>java.io.File</code>访问。无论它是在文件系统上扩展还是直接从 JAR 或其他地方(如数据库)(可以想象)访问它实际上都依赖于 Servlet 容器。</p>
<h3 id="2-3-5-InputStreamResource"><a href="#2-3-5-InputStreamResource" class="headerlink" title="2.3.5.  InputStreamResource"></a>2.3.5.  InputStreamResource</h3><p><code>InputStreamResource</code>是给定<code>InputStream</code>的<code>Resource</code> implementation。只有在没有特定的<code>Resource</code> implementation 适用时才应该使用它。特别是，在可能的情况下，首选<code>ByteArrayResource</code>或任何 file-based <code>Resource</code> implement。</p>
<h3 id="2-3-6-ByteArrayResource"><a href="#2-3-6-ByteArrayResource" class="headerlink" title="2.3.6.  ByteArrayResource"></a>2.3.6.  ByteArrayResource</h3><p>这是给定字节 array 的<code>Resource</code> implementation。它为给定的字节 array 创建<code>ByteArrayInputStream</code>。</p>
<p>它对于从任何给定的字节 array 中加载内容非常有用，而不必求助于 single-use <code>InputStreamResource</code>。</p>
<h2 id="2-4-ResourceLoader"><a href="#2-4-ResourceLoader" class="headerlink" title="2.4.  ResourceLoader"></a>2.4.  ResourceLoader</h2><p><code>ResourceLoader</code>接口应由 objects 实现，它可以 return(即加载)<code>Resource</code>实例。以下清单显示了<code>ResourceLoader</code>接口定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResourceLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Resource <span class="title">getResource</span><span class="params">(String location)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有 application 上下文都实现了<code>ResourceLoader</code>接口。因此，所有 application 上下文都可用于获取<code>Resource</code>实例。</p>
<p>当您在特定的 application context 上调用<code>getResource()</code>，并且指定的位置路径没有特定的前缀时，您将返回适合该特定 application context 的<code>Resource</code>类型</p>
<p>可以通过指定特殊的<code>classpath:</code>前缀来强制使用<code>ClassPathResource</code>，</p>
<p>可以通过指定任何标准<code>java.net.URL</code>前缀来强制使用<code>UrlResource</code>。</p>
<h2 id="2-5-ResourceLoaderAware接口"><a href="#2-5-ResourceLoaderAware接口" class="headerlink" title="2.5.  ResourceLoaderAware接口"></a>2.5.  ResourceLoaderAware接口</h2><p><code>ResourceLoaderAware</code>接口是一个特殊的标记接口，用于标识期望提供<code>ResourceLoader</code> reference 的 objects。以下清单显示了<code>ResourceLoaderAware</code>接口的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 class 实现<code>ResourceLoaderAware</code>并部署到 application context(作为 Spring-managed bean)时，application context 将其识别为<code>ResourceLoaderAware</code>。然后 application context 调用<code>setResourceLoader(ResourceLoader)</code>，将自身作为参数提供(请记住，Spring 中的所有 application 上下文都实现了<code>ResourceLoader</code>接口)。</p>
<p>也可以使用自动装配把ResourceLoader注入而不用实现ResourceLoaderAware。</p>
<h2 id="2-6-资源作为依赖关系"><a href="#2-6-资源作为依赖关系" class="headerlink" title="2.6.  资源作为依赖关系"></a>2.6.  资源作为依赖关系</h2><p>注入这些 properties 的重要性在于所有 application 上下文都注册并使用特殊的 JavaBeans <code>PropertyEditor</code>，它可以将<code>String</code> _path 转换为<code>Resource</code> objects。因此，如果<code>myBean</code>具有<code>Resource</code>类型的模板 property，则可以为该资源配置一个简单的 string，如下面的 example 所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;template&quot;</span> <span class="attr">value</span>=<span class="string">&quot;some/resource/path/myTemplate.txt&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>请注意，资源路径没有前缀。因此，因为 application context 本身将用作<code>ResourceLoader</code>，所以资源本身通过<code>ClassPathResource</code>，<code>FileSystemResource</code>或<code>ServletContextResource</code>加载，具体取决于 context 的确切类型。</p>
<p>如果需要强制使用特定的<code>Resource</code>类型，则可以使用前缀。</p>
<h2 id="2-7-Application-Contexts和Resource-Paths"><a href="#2-7-Application-Contexts和Resource-Paths" class="headerlink" title="2.7.  Application Contexts和Resource Paths"></a>2.7.  Application Contexts和Resource Paths</h2><h3 id="2-7-1-构建ApplicationContext"><a href="#2-7-1-构建ApplicationContext" class="headerlink" title="2.7.1.  构建ApplicationContext"></a>2.7.1.  构建ApplicationContext</h3><p>applicationContext构造函数的参数主要使用String或者Array。</p>
<h4 id="构造-ClassPathXmlApplicationContext-实例"><a href="#构造-ClassPathXmlApplicationContext-实例" class="headerlink" title="构造 ClassPathXmlApplicationContext 实例"></a>构造 ClassPathXmlApplicationContext 实例</h4><p>请考虑以下目录布局：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">com/</span><br><span class="line">  foo/</span><br><span class="line">    services.xml</span><br><span class="line">    daos.xml</span><br><span class="line">    MessengerService.class</span><br></pre></td></tr></table></figure>

<p>以下 example 显示了如何实例化<code>ClassPathXmlApplicationContext</code>实例，该实例由 files 中定义的名为<code>services.xml</code>和<code>daos.xml</code>(位于 classpath 上)的 beans 组成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(</span><br><span class="line">    <span class="keyword">new</span> String[] &#123;<span class="string">&quot;services.xml&quot;</span>, <span class="string">&quot;daos.xml&quot;</span>&#125;, MessengerService.class);</span><br></pre></td></tr></table></figure>

<h3 id="2-7-2-ApplicationContext构造函数资源Paths中的通配符"><a href="#2-7-2-ApplicationContext构造函数资源Paths中的通配符" class="headerlink" title="2.7.2.  ApplicationContext构造函数资源Paths中的通配符"></a>2.7.2.  ApplicationContext构造函数资源Paths中的通配符</h3><h4 id="Ant-style模式"><a href="#Ant-style模式" class="headerlink" title="Ant-style模式"></a>Ant-style模式</h4><p>路径位置可以包含 Ant-style 模式，如下面的示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/WEB-INF<span class="comment">/*-context.xml</span></span><br><span class="line"><span class="comment">com/mycompany/**/</span>applicationContext.xml</span><br><span class="line">file:C:/some/path<span class="comment">/*-context.xml</span></span><br><span class="line"><span class="comment">classpath:com/mycompany/**/</span>applicationContext.xml</span><br></pre></td></tr></table></figure>

<p>当路径位置包含 Ant-style pattern 时，解析程序遵循更复杂的过程来尝试解析通配符。它为直到最后 non-wildcard 段的路径生成<code>Resource</code>并从中获取 URL。如果此 URL 不是<code>jar:</code> URL 或 container-specific 变体(例如 WebLogic 中的<code>zip:</code>，WebSphere 中的<code>wsjar</code>等)，则从中获取<code>java.io.File</code>并用于通过遍历文件系统来解析通配符。对于 jar:URL，解析器从中获取<code>java.net.JarURLConnection</code>或手动解析 jar:URL，然后遍历 jar 文件的内容以解析通配符。</p>
<h4 id="classpath-前缀"><a href="#classpath-前缀" class="headerlink" title="classpath*:前缀"></a>classpath*:前缀</h4><p>构造 XML-based application context 时，位置 string 可以使用特殊的<code>classpath*:</code>前缀，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx =</span><br><span class="line">    <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;classpath*:conf/appContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>此特殊前缀指定必须获取 match 给定 name 的所有 classpath 资源(内部，这通常通过调用<code>ClassLoader.getResources(…)</code>)然后合并以形成最终的 application context 定义。</p>
<p>您还可以将<code>classpath*:</code>前缀与<code>PathMatcher</code> pattern 组合在位置路径的 rest 中(对于 example，<code>classpath*:META-INF/*-beans.xml</code>)。在这种情况下，解析策略非常简单：在最后一个 non-wildcard 路径段上使用<code>ClassLoader.getResources()</code>调用来获取 class 加载器层次结构中的所有匹配资源，然后，在每个资源之外，使用前面描述的相同的<code>PathMatcher</code>解析策略通配符子路径。</p>
<h3 id="2-7-3-FileSystemResource警告"><a href="#2-7-3-FileSystemResource警告" class="headerlink" title="2.7.3.  FileSystemResource警告"></a>2.7.3.  FileSystemResource警告</h3><p>但是，出于向后兼容性(历史)的原因，当<code>FileSystemApplicationContext</code>是<code>ResourceLoader</code>时，这会发生变化。 <code>FileSystemApplicationContext</code>强制所有附加的<code>FileSystemResource</code>实例将所有位置 paths 视为相对的，无论它们是否以前导斜杠开头。实际上，这意味着以下示例是等效的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx =</span><br><span class="line">    <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">&quot;conf/context.xml&quot;</span>);</span><br><span class="line">ApplicationContext ctx =</span><br><span class="line">    <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">&quot;/conf/context.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>实际上，如果需要 true 绝对文件系统 paths，则应避免对<code>FileSystemResource</code>或<code>FileSystemXmlApplicationContext</code>使用绝对路径，并使用<code>file:</code> URL 前缀强制使用<code>UrlResource</code>。以下示例显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// actual context type doesn&#x27;t matter, the Resource will always be UrlResource</span></span><br><span class="line">ctx.getResource(<span class="string">&quot;file:///some/resource/path/myTemplate.txt&quot;</span>);</span><br><span class="line"><span class="comment">// force this FileSystemXmlApplicationContext to load its definition via a UrlResource</span></span><br><span class="line">ApplicationContext ctx =</span><br><span class="line">    <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">&quot;file:///conf/context.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="3-验证、数据绑定和类型转换"><a href="#3-验证、数据绑定和类型转换" class="headerlink" title="3.  验证、数据绑定和类型转换"></a>3.  验证、数据绑定和类型转换</h1><p>Spring 已经提出了一个<code>Validator</code>接口，它在 application 的每一层都是基本的，非常有用。</p>
<p>数据 binding 对于让用户输入动态绑定到 application 的域 model(或用于 process 用户输入的任何 objects)非常有用。 Spring 提供恰当的名称<code>DataBinder</code>来做到这一点。 <code>Validator</code>和<code>DataBinder</code>组成<code>validation</code>包，主要用于但不限于 MVC framework。</p>
<h2 id="3-1-使用Spring的验证器接口进行验证"><a href="#3-1-使用Spring的验证器接口进行验证" class="headerlink" title="3.1.  使用Spring的验证器接口进行验证"></a>3.1.  使用Spring的验证器接口进行验证</h2><p>Validator接口可以用于验证objects。</p>
<p><code>Validator</code>接口使用<code>Errors</code> object 工作，以便在验证时，验证程序可以向<code>Errors</code> object 报告验证失败。</p>
<h2 id="3-2-将代码解析为错误信息"><a href="#3-2-将代码解析为错误信息" class="headerlink" title="3.2.  将代码解析为错误信息"></a>3.2.  将代码解析为错误信息</h2><h2 id="3-3-Bean-操作和-BeanWrapper"><a href="#3-3-Bean-操作和-BeanWrapper" class="headerlink" title="3.3.  Bean 操作和 BeanWrapper"></a>3.3.  Bean 操作和 BeanWrapper</h2><p><code>org.springframework.beans</code>包遵循 JavaBeans 标准。 JavaBean 是一个具有默认 no-argument 构造函数的 class，它遵循命名约定，其中(对于 example)名为<code>bingoMadness</code>的 property 将具有 setter 方法<code>setBingoMadness(..)</code>和 getter 方法<code>getBingoMadness()</code>。</p>
<p>beans 包中一个非常重要的 class 是<code>BeanWrapper</code>接口及其相应的 implementation(<code>BeanWrapperImpl</code>)。从 javadoc 引用，<code>BeanWrapper</code>提供了设置和获取 property 值(单独或批量)，获取 property 描述符和查询 properties 以确定它们是可读还是可写的功能。此外，<code>BeanWrapper</code>提供对嵌套 properties 的支持，使 sub-properties 上的 properties 设置为无限深度。 <code>BeanWrapper</code>还支持添加标准 JavaBeans <code>PropertyChangeListeners</code>和<code>VetoableChangeListeners</code>的功能，而无需在目标 class 中支持 code。最后但并非最不重要的是，<code>BeanWrapper</code>提供了对设置索引 properties 的支持。 <code>BeanWrapper</code>通常不直接由 application code 使用，但由<code>DataBinder</code>和<code>BeanFactory</code>使用。</p>
<p><code>BeanWrapper</code>的工作方式部分由 name 表示：它包装 bean 以对该 bean 执行操作，例如设置和检索 properties。</p>
<h3 id="3-3-1-设置和获取基本和嵌套的Properties"><a href="#3-3-1-设置和获取基本和嵌套的Properties" class="headerlink" title="3.3.1.  设置和获取基本和嵌套的Properties"></a>3.3.1.  设置和获取基本和嵌套的Properties</h3><p>设置和获取 properties 是通过使用带有几个重载变体的<code>setPropertyValue</code>，<code>setPropertyValues</code>，<code>getPropertyValue</code>和<code>getPropertyValues</code>方法完成的。</p>
<table>
<thead>
<tr>
<th align="left">表达</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>name</code></td>
<td align="left">表示 property <code>name</code>，对应于<code>getName()</code>或<code>isName()</code>和<code>setName(..)</code>方法。</td>
</tr>
<tr>
<td align="left"><code>account.name</code></td>
<td align="left">指示 property <code>account</code>的嵌套 property <code>name</code>，它对应于(对于 example)<code>getAccount().setName()</code>或<code>getAccount().getName()</code>方法。</td>
</tr>
<tr>
<td align="left"><code>account[2]</code></td>
<td align="left">表示索引 property <code>account</code>的第三个元素。索引的 properties 可以是<code>array</code>，<code>list</code>或其他自然排序的集合。</td>
</tr>
<tr>
<td align="left"><code>account[COMPANYNAME]</code></td>
<td align="left">表示由<code>account</code> <code>Map</code> property 的<code>COMPANYNAME</code> key 索引的 map 条目的 value。</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        BeanWrapper wrapper = <span class="keyword">new</span> BeanWrapperImpl(p);</span><br><span class="line">        wrapper.setPropertyValue(<span class="string">&quot;address&quot;</span>, <span class="keyword">new</span> Address());</span><br><span class="line">        wrapper.setPropertyValue(<span class="string">&quot;address.addr&quot;</span>, <span class="string">&quot;treet 1&quot;</span>);</span><br><span class="line">        wrapper.setPropertyValue(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hsp&quot;</span>);</span><br><span class="line">        wrapper.setPropertyValue(<span class="string">&quot;age&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-2-内建的PropertyEditor实现类"><a href="#3-3-2-内建的PropertyEditor实现类" class="headerlink" title="3.3.2.  内建的PropertyEditor实现类"></a>3.3.2.  内建的PropertyEditor实现类</h3><p>Spring 使用<code>PropertyEditor</code>的概念来实现<code>Object</code>和<code>String</code>之间的转换。以与 object 本身不同的方式表示 properties 是很方便的。例如，<code>Date</code>可以用人类可读的方式表示(如<code>String</code>：<code>&#39;2007-14-09&#39;</code>)，而我们仍然可以将人类可读的表单转换回原始 date(或者更好的是，转换以人类可读形式输入的任何 date 回到<code>Date</code> objects)。通过注册<code>java.beans.PropertyEditor</code>类型的自定义编辑器可以实现此行为。在<code>BeanWrapper</code>上注册自定义编辑器，或者在特定的 IoC 容器中注册(如上一章所述)，使其了解如何将 properties 转换为所需的类型。</p>
<p>在 Spring 中使用 property 编辑的几个示例：</p>
<ul>
<li>在 beans 上设置 properties 是通过使用<code>PropertyEditor</code> implementations 完成的。当您使用<code>java.lang.String</code>作为在 XML 文件中声明的某些 bean 的 property 的 value 时，Spring(如果相应 property 的 setter 具有<code>Class</code>参数)使用<code>ClassEditor</code>尝试将参数解析为<code>Class</code> object。</li>
<li>在 Spring 的 MVC framework 中解析 HTTP 请求参数是通过使用所有类型的<code>PropertyEditor</code> implement 来完成的，您可以在<code>CommandController</code>的所有子类中手动绑定。</li>
</ul>
<p>Spring 有许多 built-in <code>PropertyEditor</code> implementations 让生活变得轻松。它们都位于<code>org.springframework.beans.propertyeditors</code>包中。大多数(但不是全部，如下面的 table 所示)默认情况下由<code>BeanWrapperImpl</code>注册。如果 property 编辑器可以某种方式配置，您仍然可以注册自己的变体来覆盖默认变体。以下 table 描述了 Spring 提供的各种<code>PropertyEditor</code> implement：</p>
<table>
<thead>
<tr>
<th align="left">类</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>ByteArrayPropertyEditor</code></td>
<td align="left">字节数组的编辑器。将 strings 转换为其对应的字节表示形式。默认情况下由<code>BeanWrapperImpl</code>注册。</td>
</tr>
<tr>
<td align="left"><code>ClassEditor</code></td>
<td align="left">解析 strings 表示 classes 到实际的 classes 和 vice-versa。如果找不到 class，则抛出<code>IllegalArgumentException</code>。默认情况下，由<code>BeanWrapperImpl</code>注册。</td>
</tr>
<tr>
<td align="left"><code>CustomBooleanEditor</code></td>
<td align="left"><code>Boolean</code> properties 的可自定义 property 编辑器。默认情况下，由<code>BeanWrapperImpl</code>注册，但可以通过将其自定义实例注册为自定义编辑器来覆盖。</td>
</tr>
<tr>
<td align="left"><code>CustomCollectionEditor</code></td>
<td align="left">Property 集合编辑器，将任何源<code>Collection</code>转换为给定目标<code>Collection</code>类型。</td>
</tr>
<tr>
<td align="left"><code>CustomDateEditor</code></td>
<td align="left"><code>java.util.Date</code>的可自定义 property 编辑器，支持自定义<code>DateFormat</code>。没有默认注册。必须是 user-registered，并根据需要使用适当的格式。</td>
</tr>
<tr>
<td align="left"><code>CustomNumberEditor</code></td>
<td align="left">任何<code>Number</code>子类的可自定义 property 编辑器，例如<code>Integer</code>，<code>Long</code>，<code>Float</code>或<code>Double</code>。默认情况下，由<code>BeanWrapperImpl</code>注册，但可以通过将其自定义实例注册为自定义编辑器来覆盖。</td>
</tr>
<tr>
<td align="left"><code>FileEditor</code></td>
<td align="left">将 strings 解析为<code>java.io.File</code> objects。默认情况下，由<code>BeanWrapperImpl</code>注册。</td>
</tr>
<tr>
<td align="left"><code>InputStreamEditor</code></td>
<td align="left">One-way property 编辑器，可以使用 string 并生成(通过中间<code>ResourceEditor</code>和<code>Resource</code>)<code>InputStream</code>，以便<code>InputStream</code> properties 可以直接设置为 strings。请注意，默认用法不会为您关闭<code>InputStream</code>。默认情况下，由<code>BeanWrapperImpl</code>注册。</td>
</tr>
<tr>
<td align="left"><code>LocaleEditor</code></td>
<td align="left">可以将 strings 解析为<code>Locale</code> objects 和 vice-versa(string 格式为<code>[country][variant]</code>，与<code>Locale</code>的<code>toString()</code>方法相同)。默认情况下，由<code>BeanWrapperImpl</code>注册。</td>
</tr>
<tr>
<td align="left"><code>PatternEditor</code></td>
<td align="left">可以将 strings 解析为<code>java.util.regex.Pattern</code> objects 和 vice-versa。</td>
</tr>
<tr>
<td align="left"><code>PropertiesEditor</code></td>
<td align="left">可以将 strings(使用<code>java.util.Properties</code> class 的 javadoc 中定义的格式格式化)转换为<code>Properties</code> objects。默认情况下，由<code>BeanWrapperImpl</code>注册。</td>
</tr>
<tr>
<td align="left"><code>StringTrimmerEditor</code></td>
<td align="left">Property 编辑器修剪 strings。 (可选)允许将空 string 转换为<code>null</code> value。默认情况下未注册 - 必须为 user-registered。</td>
</tr>
<tr>
<td align="left"><code>URLEditor</code></td>
<td align="left">可以将 URL 的 string 表示解析为实际的<code>URL</code> object。默认情况下，由<code>BeanWrapperImpl</code>注册。</td>
</tr>
</tbody></table>
<p>将 bean properties 设置为 string 值时，Spring IoC 容器最终使用标准 JavaBeans <code>PropertyEditor</code> implementations 将这些 strings 转换为 property 的复杂类型。 Spring pre-registers 一些自定义的<code>PropertyEditor</code> implement(用于 example，将表示为 string 的 class name 转换为<code>Class</code> object)。此外，Java 的标准 JavaBeans <code>PropertyEditor</code>查找机制允许适当地命名 class 并放置在与它提供支持的 class 相同的包中，以便可以自动找到它。</p>
<p>如果需要注册其他自定义<code>PropertyEditors</code>，可以使用多种机制。假设您有一个<code>BeanFactory</code> reference，最通常不方便或不推荐的手动方法是使用<code>ConfigurableBeanFactory</code>接口的<code>registerCustomEditor()</code>方法。另一个(稍微方便一点)机制是使用一个名为<code>CustomEditorConfigurer</code>的特殊 bean 工厂 post-processor。虽然你可以使用 bean factory post-processors 和<code>BeanFactory</code> implement，但<code>CustomEditorConfigurer</code>有一个嵌套的 property 设置，所以我们强烈建议你将它与<code>ApplicationContext</code>一起使用，你可以用类似的方式将它部署到任何其他 bean，并且可以自动检测它并应用。</p>
<h2 id="3-4-Spring类转换"><a href="#3-4-Spring类转换" class="headerlink" title="3.4.  Spring类转换"></a>3.4.  Spring类转换</h2><p>Spring 3 引入了一个<code>core.convert</code>包，它提供了一般的类型转换系统。系统定义了一个用于实现类型转换逻辑的 SPI 和一个用于在运行时执行类型转换的 API。在 Spring 容器中，您可以使用此系统替代<code>PropertyEditor</code> implementations 将外部化的 bean property value strings 转换为所需的 property 类型。您还可以在需要进行类型转换的 application 中的任何位置使用公共 API。</p>
<h3 id="3-4-1-转换器SPI"><a href="#3-4-1-转换器SPI" class="headerlink" title="3.4.1.  转换器SPI"></a>3.4.1.  转换器SPI</h3><p>实现类型转换逻辑的 SPI 很简单且类型很强，如下面的接口定义所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.core.convert.converter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">S</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">convert</span><span class="params">(S source)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-2-使用ConverterFactory"><a href="#3-4-2-使用ConverterFactory" class="headerlink" title="3.4.2.  使用ConverterFactory"></a>3.4.2.  使用ConverterFactory</h3><p>当您需要集中整个 class 层次结构的转换逻辑时(对于 example，当从 String 转换为 java.lang.Enum objects 时)，您可以实现<code>ConverterFactory</code>，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.core.convert.converter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConverterFactory</span>&lt;<span class="title">S</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    &lt;T extends R&gt; <span class="function">Converter&lt;S, T&gt; <span class="title">getConverter</span><span class="params">(Class&lt;T&gt; targetType)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-2-使用GenericConverter"><a href="#3-4-2-使用GenericConverter" class="headerlink" title="3.4.2.  使用GenericConverter"></a>3.4.2.  使用GenericConverter</h3><p>当您需要复杂的<code>Converter</code> implementation 时，请考虑使用<code>GenericConverter</code>接口。使用比<code>Converter</code>更灵活但不太强类型的签名，<code>GenericConverter</code>支持在多个源类型和目标类型之间进行转换。此外，<code>GenericConverter</code>使您可以在实现转换逻辑时使用的源和目标字段 context。这样的 context 允许类型转换由字段 annotation 或在字段签名上声明的通用信息驱动。以下清单显示了<code>GenericConverter</code>的接口定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.core.convert.converter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GenericConverter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;ConvertiblePair&gt; <span class="title">getConvertibleTypes</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">convert</span><span class="params">(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-7-Spring验证"><a href="#3-7-Spring验证" class="headerlink" title="3.7.  Spring验证"></a>3.7.  Spring验证</h2><h3 id="3-7-1-JSR-303-Bean-Validation-API-概述"><a href="#3-7-1-JSR-303-Bean-Validation-API-概述" class="headerlink" title="3.7.1.  JSR-303 Bean Validation API 概述"></a>3.7.1.  JSR-303 Bean Validation API 概述</h3><p>考虑以下 example，它显示了一个带有两个 properties 的简单<code>PersonForm</code> model：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonForm</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JSR-303 允许您为这些 properties 定义声明性验证约束，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonForm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Size(max=64)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Min(0)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-Spring表达式语言（）SpEL"><a href="#4-Spring表达式语言（）SpEL" class="headerlink" title="4.Spring表达式语言（）SpEL"></a>4.Spring表达式语言（）SpEL</h1><h2 id="4-1-Evaluation"><a href="#4-1-Evaluation" class="headerlink" title="4.1.  Evaluation"></a>4.1.  Evaluation</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">Expression exp = parser.parseExpression(<span class="string">&quot;&#x27;Hello World&#x27;&quot;</span>); (<span class="number">1</span>)</span><br><span class="line">String message = (String) exp.getValue();</span><br></pre></td></tr></table></figure>

<p><code>ExpressionParser</code>接口负责解析表达式 string。在前面的 example 中，表达式 string 是由周围的单引号表示的 string 文字。 <code>Expression</code>接口负责评估先前定义的表达式 string。分别调用<code>parser.parseExpression</code>和<code>exp.getValue</code>时，可以抛出两个 exceptions，<code>ParseException</code>和<code>EvaluationException</code>。</p>
<p>在下面的方法调用示例中，我们在 string 文字上调用<code>concat</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">Expression exp = parser.parseExpression(<span class="string">&quot;&#x27;Hello World&#x27;.concat(&#x27;!&#x27;)&quot;</span>); (<span class="number">1</span>)</span><br><span class="line">String message = (String) exp.getValue();</span><br></pre></td></tr></table></figure>

<p>泛型方法的使用：<code>public &lt;T&gt; T getValue(Class&lt;T&gt; desiredResultType)</code>。使用此方法无需将表达式的 value 强制转换为所需的结果类型。如果无法将 value 强制转换为<code>T</code>类型或使用已注册的类型转换器进行转换，则抛出<code>EvaluationException</code>。</p>
<p>SpEL 的更常见用法是提供一个表达式 string，该表达式是针对特定的 object 实例(称为 root object)进行评估的。以下 example 显示了如何从<code>Inventor</code> class 的实例检索<code>name</code> property 或创建 boolean 条件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create and set a calendar</span></span><br><span class="line">GregorianCalendar c = <span class="keyword">new</span> GregorianCalendar();</span><br><span class="line">c.set(<span class="number">1856</span>, <span class="number">7</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// The constructor arguments are name, birthday, and nationality.</span></span><br><span class="line">Inventor tesla = <span class="keyword">new</span> Inventor(<span class="string">&quot;Nikola Tesla&quot;</span>, c.getTime(), <span class="string">&quot;Serbian&quot;</span>);</span><br><span class="line"></span><br><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line"></span><br><span class="line">Expression exp = parser.parseExpression(<span class="string">&quot;name&quot;</span>); (<span class="number">1</span>)</span><br><span class="line">String name = (String) exp.getValue(tesla);</span><br><span class="line"><span class="comment">// name == &quot;Nikola Tesla&quot;</span></span><br><span class="line"></span><br><span class="line">exp = parser.parseExpression(<span class="string">&quot;name == &#x27;Nikola Tesla&#x27;&quot;</span>);</span><br><span class="line"><span class="keyword">boolean</span> result = exp.getValue(tesla, Boolean.class);</span><br><span class="line"><span class="comment">// result == true</span></span><br></pre></td></tr></table></figure>

<h3 id="4-1-1-了解EvaluationContext"><a href="#4-1-1-了解EvaluationContext" class="headerlink" title="4.1.1.  了解EvaluationContext"></a>4.1.1.  了解EvaluationContext</h3><h2 id="4-2-Bean中定义的表达式"><a href="#4-2-Bean中定义的表达式" class="headerlink" title="4.2.  Bean中定义的表达式"></a>4.2.  Bean中定义的表达式</h2><p>您可以将带有 XML-based 或 annotation-based configuration 元数据的 SpEL 表达式用于定义<code>BeanDefinition</code>实例。在这两种情况下，定义表达式的语法都是<code>#&#123; &lt;expression string&gt; &#125;</code>形式。</p>
<h3 id="4-2-1-XML-Configuration"><a href="#4-2-1-XML-Configuration" class="headerlink" title="4.2.1.  XML Configuration"></a>4.2.1.  XML Configuration</h3><p>可以使用表达式设置 property 或构造函数参数 value，如下面的 example 所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;numberGuess&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.spring.samples.NumberGuess&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;randomNumber&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123; T(java.lang.Math).random() * 100.0 &#125;&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- other properties --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="5-使用Spring进行面向对象编程"><a href="#5-使用Spring进行面向对象编程" class="headerlink" title="5.  使用Spring进行面向对象编程"></a>5.  使用Spring进行面向对象编程</h1><p>Aspect-oriented 编程(AOP)通过提供另一种思考程序结构的方式来补充 Object-oriented 编程(OOP)。 OOP 中的 key 模块化单元是 class，而在 AOP 中，模块化单元是 aspect。</p>
<p>Spring的核心组件之一就是AOP框架。虽然Spring IoC容器不依赖于AOP，AOP补充了Spring IoC以提供非常强大的中间件解决方案。</p>
<h2 id="5-1-AOP概念"><a href="#5-1-AOP概念" class="headerlink" title="5.1.  AOP概念"></a>5.1.  AOP概念</h2><p>术语：</p>
<ul>
<li>Aspect：纵向关注事务实现的切面。</li>
<li>连接点：程序执行期间的一个点。例如方法的执行或exception的处理，在Spring AOP中，连接点始终表示方法执行。</li>
<li>通知（Advice）：在切面的某个连接点上执行的操作。</li>
<li>切入点：匹配连接点的断言，在AOP中Advice和一个切入点表达式关联。</li>
<li>引入（Introduction）：在不修改代码的前提下，为类添加新的方法和属性。</li>
<li>目标对象：被一个或多个切面所通知的对象。由于Spring AOP是使用运行时代理实现的，因此对象始终是代理对象。</li>
<li>AOP代理：AOP创建的对象，用来实现切面契约。</li>
<li>织入（Weaving）：把切面连接到其他的应用程序类型或者对象上，并创建一个被通知的对象，分为：编译时织入、类加载时织入和执行时织入。</li>
</ul>
<p>通知（Advice）有一下几种类型：</p>
<ul>
<li>前置通知：在连接点之前执行的通知，但不能阻止连接点的执行，除非在通知中抛出异常。</li>
<li>返回后通知：在某个连接点完成后执行的通知。</li>
<li>抛出异常后通知：在方法抛出异常退出时执行的通知。</li>
<li>后通知：当连接点退出时执行的通知，无论是正常返回还是异常退出。</li>
<li>环绕通知：包围一个连接点的通知。</li>
</ul>
<p>环绕通知是最普遍的通知。由于 Spring AOP(如 AspectJ)提供了全方位的通知类型，因此我们建议您使用可以实现所需行为的最不强大的通知类型。例如，如果您只需要使用方法的 return value 更新缓存，那么最好实现返回后通知，而不是环绕通知，尽管环绕通知可以完成同样的事情。</p>
<h2 id="5-2-Spring-AOP能力和目标"><a href="#5-2-Spring-AOP能力和目标" class="headerlink" title="5.2.  Spring AOP能力和目标"></a>5.2.  Spring AOP能力和目标</h2><p>Spring AOP 是用纯 Java 实现的。不需要特殊的编译 process。 Spring AOP 不需要控制 class 加载器层次结构，因此适合在 servlet 容器或 application 服务器中使用。</p>
<p>Spring AOP 目前仅支持方法执行连接点(建议在 Spring beans 上执行方法)。虽然可以在不破坏核心 Spring AOP API 的情况下添加对字段拦截的支持，但未实现字段拦截。如果您需要通知字段访问和更新连接点，请考虑使用 AspectJ 等语言。</p>
<h2 id="5-3-AOP代理"><a href="#5-3-AOP代理" class="headerlink" title="5.3.  AOP代理"></a>5.3.  AOP代理</h2><p>Spring AOP默认使用AOP代理的标准JDK动态代理。这使得任何接口都可以被代理。</p>
<h2 id="5-4-AspectJ支持"><a href="#5-4-AspectJ支持" class="headerlink" title="5.4.  @AspectJ支持"></a>5.4.  @AspectJ支持</h2><p>@AspectJ 指的是将切面声明为使用 annotations 注释的常规 Java classes 的样式。作为 AspectJ 5 版本的一部分，<a target="_blank" rel="noopener" href="https://www.eclipse.org/aspectj">AspectJ 项目</a>引入了 @AspectJ 样式。 Spring 使用 AspectJ 提供的 library 解释与 AspectJ 5 相同的注释，用于切入点解析和匹配。但是，AOP 运行时仍然是纯粹的 Spring AOP，并且不依赖于 AspectJ 编译器或编织器。</p>
<h3 id="5-4-1-启用-AspectJ支持"><a href="#5-4-1-启用-AspectJ支持" class="headerlink" title="5.4.1.  启用@AspectJ支持"></a>5.4.1.  启用@AspectJ支持</h3><p>如果Spring确定bean被一个或多个切面通知，它会自动为该bean生成一个代理来拦截方法调用，并确保根据需要执行通知。</p>
<p>可以使用xml或者Java Config启动@AspectJ支持。还要使用aspectjweaver.jar包。</p>
<p>使用Java Config启动@AspectJ支持，需要添加@EnableAspectJAutoProxy注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要使用 XML-based configuration 启用 @AspectJ 支持，请使用<code>aop:aspectj-autoproxy</code>元素，如下面的 example 所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-4-2-声明Aspect"><a href="#5-4-2-声明Aspect" class="headerlink" title="5.4.2. 声明Aspect"></a>5.4.2. 声明Aspect</h3><p>启用@AspectJ支持后，具有@Aspect注解的Bean将由Spring自动检测并用于配置Spring AOP。</p>
<p>两个 example 中的第一个在 application context 中显示了一个常规的 bean 定义，该定义指向具有<code>@Aspect</code> annotation 的 bean class：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myAspect&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.xyz.NotVeryUsefulAspect&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- configure properties of the aspect here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这两个示例中的第二个显示了<code>NotVeryUsefulAspect</code> class 定义，该定义使用<code>org.aspectj.lang.annotation.Aspect</code> annotation 注释;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.xyz;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotVeryUsefulAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>切面可以有方法和字段（由@Aspect修饰）</p>
<p><code>@Aspect</code> annotation 不足以在 classpath 中自动检测。为此，您需要添加一个单独的<code>@Component</code> annotation(或者，根据 Spring 的 component 扫描器的规则，可以定义符合条件的自定义构造型 annotation)。</p>
<h3 id="5-4-3-声明切入点"><a href="#5-4-3-声明切入点" class="headerlink" title="5.4.3.  声明切入点"></a>5.4.3.  声明切入点</h3><p>切入点确定感兴趣的连接点，从而使我们能够控制通知何时执行。Spring AOP只支持Spring Beans的方法上执行连接点，因此，切入点可以看做匹配Spring Beans上方法的执行。切入点声明有两个部分：一个包含name的签名和一个确定方法执行的切入点表达式。</p>
<p>以下 example 定义名为<code>anyOldTransfer</code>的切入点，该切入点与名为<code>transfer</code>的任何方法的执行相匹配：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(* transfer(..))&quot;)</span><span class="comment">// the pointcut expression</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">anyOldTransfer</span><span class="params">()</span> </span>&#123;&#125;<span class="comment">// the pointcut signature</span></span><br></pre></td></tr></table></figure>

<p>切入点指示符用来指示切入点表达式目的，在Spring AOP中目前只有执行方法这一个连接点，Spring AOP支持的AspectJ切入点指示符如下：</p>
<ul>
<li>execution：用于匹配方法执行的连接点；</li>
<li>within：用于匹配指定的类及其子类中的所有方法。</li>
<li>this：匹配可以向上转型为this指定的类型的代理对象中的所有方法。</li>
<li>target：匹配可以向上转型为target指定的类型的目标对象中的所有方法。</li>
<li>args：用于匹配运行时传入的参数列表的类型为指定的参数列表类型的方法；</li>
<li>@within：用于匹配持有指定注解的类的所有方法；</li>
<li>@target：用于匹配的持有指定注解目标对象的所有方法；</li>
<li>@args：用于匹配运行时 传入的参数列表的类型持有 注解列表对应的注解 的方法；</li>
<li>@annotation：用于匹配持有指定注解的方法；</li>
</ul>
<p>　　AspectJ切入点支持的切入点指示符还有： call、get、set、preinitialization、staticinitialization、initialization、handler、adviceexecution、withincode、cflow、cflowbelow、if、@this、@withincode；但Spring AOP目前不支持这些指示符，使用这些指示符将抛出IllegalArgumentException异常。</p>
<p> Spring AOP 是一个 proxy-based 系统，它区分代理 object 本身(绑定到<code>this</code>)和代理后面的目标 object(绑定到<code>target</code>)。</p>
<p>请注意，切入点定义通常与任何截获的方法匹配。切入点严格意味着 public-only，即使在通过代理进行潜在 non-public 交互的 CGLIB 代理方案中，也需要相应地进行定义。</p>
<p>您可以使用<code>&amp;&amp;,</code> <code>||</code>和<code>!</code>组合切入点表达式。您还可以通过 name 引用切入点表达式。以下 example 显示了三个切入点表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(public * *(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">anyPublicOperation</span><span class="params">()</span> </span>&#123;&#125; (<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Pointcut(&quot;within(com.xyz.someapp.trading..*)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inTrading</span><span class="params">()</span> </span>&#123;&#125; (<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Pointcut(&quot;anyPublicOperation() &amp;&amp; inTrading()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tradingOperation</span><span class="params">()</span> </span>&#123;&#125; (<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>在使用 enterprise applications 时，开发人员通常希望从几个方面引用 application 的模块和特定的操作集。我们建议定义一个“SystemArchitecture”aspect，为此目的捕获 common 切入点表达式。这样的 aspect 通常类似于以下 example：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xyz.someapp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemArchitecture</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A join point is in the web layer if the method is defined</span></span><br><span class="line"><span class="comment">     * in a type in the com.xyz.someapp.web package or any sub-package</span></span><br><span class="line"><span class="comment">     * under that.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;within(com.xyz.someapp.web..*)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inWebLayer</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A join point is in the service layer if the method is defined</span></span><br><span class="line"><span class="comment">     * in a type in the com.xyz.someapp.service package or any sub-package</span></span><br><span class="line"><span class="comment">     * under that.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;within(com.xyz.someapp.service..*)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inServiceLayer</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A join point is in the data access layer if the method is defined</span></span><br><span class="line"><span class="comment">     * in a type in the com.xyz.someapp.dao package or any sub-package</span></span><br><span class="line"><span class="comment">     * under that.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;within(com.xyz.someapp.dao..*)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inDataAccessLayer</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A business service is the execution of any method defined on a service</span></span><br><span class="line"><span class="comment">     * interface. This definition assumes that interfaces are placed in the</span></span><br><span class="line"><span class="comment">     * &quot;service&quot; package, and that implementation types are in sub-packages.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If you group service interfaces by functional area (for example,</span></span><br><span class="line"><span class="comment">     * in packages com.xyz.someapp.abc.service and com.xyz.someapp.def.service) then</span></span><br><span class="line"><span class="comment">     * the pointcut expression &quot;execution(* com.xyz.someapp..service.*.*(..))&quot;</span></span><br><span class="line"><span class="comment">     * could be used instead.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Alternatively, you can write the expression using the &#x27;bean&#x27;</span></span><br><span class="line"><span class="comment">     * PCD, like so &quot;bean(*Service)&quot;. (This assumes that you have</span></span><br><span class="line"><span class="comment">     * named your Spring service beans in a consistent fashion.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.xyz.someapp..service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">businessService</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A data access operation is the execution of any method defined on a</span></span><br><span class="line"><span class="comment">     * dao interface. This definition assumes that interfaces are placed in the</span></span><br><span class="line"><span class="comment">     * &quot;dao&quot; package, and that implementation types are in sub-packages.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.xyz.someapp.dao.*.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dataAccessOperation</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring AOP 用户可能最常使用<code>execution</code>切入点指示符。执行表达式的格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern)</span><br><span class="line">            <span class="keyword">throws</span>-pattern?)</span><br></pre></td></tr></table></figure>

<p>除返回类型 pattern(前面的代码片段中的<code>ret-type-pattern</code>)， name pattern 和参数 pattern 之外的所有部分都是可选的。返回类型 pattern 确定方法的 return 类型必须在 order 中才能匹配连接点。 <code>*</code>最常用作返回类型 pattern。它匹配任何 return 类型。仅当方法返回给定类型时，fully-qualified 类型 name 才匹配。 name pattern 与方法 name 匹配。您可以使用<code>*</code>通配符作为 name pattern 的全部或部分。如果指定声明类型 pattern，请包含尾随<code>.</code>以将其连接到 name pattern component。参数 pattern 稍微复杂一些：<code>()</code>匹配不带参数的方法，而<code>(..)</code>匹配任何数量(零个或多个)参数。 <code>(*)</code> pattern 匹配一个接受任何类型的一个参数的方法。 <code>(*,String)</code>匹配一个带两个参数的方法。第一个可以是任何类型，而第二个必须是<code>String</code>。有关更多信息，请参阅 AspectJ 编程指南的<a target="_blank" rel="noopener" href="https://www.eclipse.org/aspectj/doc/released/progguide/semantics-pointcuts.html">语言语义学</a>部分。</p>
<h3 id="5-4-4-声明通知"><a href="#5-4-4-声明通知" class="headerlink" title="5.4.4.  声明通知"></a>5.4.4.  声明通知</h3><p>通知与切入点表达式相关联，并在切入点匹配的方法执行前，执行后或者环绕运行。切入点表达式可以是对命名切入点的简单引用，也可以是在适当位置声明的切入点表达式。</p>
<h4 id="在连接点之前通知"><a href="#在连接点之前通知" class="headerlink" title="在连接点之前通知"></a>在连接点之前通知</h4><p>可以使用@before注解在aspect中声明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeforeExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAccessCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>环绕通知：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AroundExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;com.xyz.myapp.SystemArchitecture.businessService()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doBasicProfiling</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// start stopwatch</span></span><br><span class="line">        Object retVal = pjp.proceed();</span><br><span class="line">        <span class="comment">// stop stopwatch</span></span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问当前连接点，任何通知方法都可以声明一个类型为JoinPoint的参数作为其第一个参数，需要使用ProceedingJoinPoint作为around声明的第一个参数，它是JoinPoint的子类。JoinPoint接口提供了许多有用的方法：</p>
<ul>
<li>getArgs()：返回方法的参数</li>
<li>getThis()：返回代理的对象</li>
<li>getTarget()：返回目标对象。</li>
<li>getSIgnature()：返回正在通知的方法的描述，就是它的方法签名。</li>
<li>toString()：打印通知方法的有用描述。</li>
</ul>
<h4 id="将参数传递给通知"><a href="#将参数传递给通知" class="headerlink" title="将参数传递给通知"></a>将参数传递给通知</h4><p>要使参数值可以用于通知体，可以使用args的绑定形式。如果在args表达是中使用参数name代替类型name，则在调用通知时，相应参数的value将作为参数值传递。下面的代码：假设通知执行以Account对象作为第一个参数的相关操作，并且需要访问通知体中的账户。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation() &amp;&amp; args(account,..)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validateAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>切入点表达式的<code>args(account,..)</code>部分有两个目的。首先，它将匹配那些至少采用一个参数的方法而且传递给该方法的参数是Account实例。其次，它通过account参数使实际的Account对象可用于通知。</p>
<p>另一种编写方法是声明一个切入点（Point Cut），当它与连接点匹配时提供Account对象，然后从通知中引用指定的切入点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation() &amp;&amp; args(account,..)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">accountDataAccessOperation</span><span class="params">(Account account)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before(&quot;accountDataAccessOperation(account)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validateAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个示例中的第一个显示了<code>@Auditable</code> annotation 的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Auditable &#123;</span><br><span class="line">    <span class="function">AuditCode <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个示例中的第二个显示了与<code>@Auditable</code>方法的执行相匹配的建议：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; @annotation(auditable)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">audit</span><span class="params">(Auditable auditable)</span> </span>&#123;</span><br><span class="line">    AuditCode code = auditable.value();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="建议参数和泛型"><a href="#建议参数和泛型" class="headerlink" title="建议参数和泛型"></a>建议参数和泛型</h4><p>Spring AOP 可以处理 class 声明和方法参数中使用的泛型。假设您有一个如下所示的泛型类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sample</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sampleGenericMethod</span><span class="params">(T param)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sampleGenericCollectionMethod</span><span class="params">(Collection&lt;T&gt; param)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过将 advice 参数 typing 到要拦截方法的参数类型，可以将方法类型的拦截限制为某些参数类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;execution(* ..Sample+.sampleGenericMethod(*)) &amp;&amp; args(param)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeSampleMethod</span><span class="params">(MyType param)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Advice implementation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法不适用于通用集合。因此，您无法按如下方式定义切入点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;execution(* ..Sample+.sampleGenericCollectionMethod(*)) &amp;&amp; args(param)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeSampleMethod</span><span class="params">(Collection&lt;MyType&gt; param)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Advice implementation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了使这项工作，我们必须检查集合的每个元素，这是不合理的，因为我们也无法决定如何处理<code>null</code>值。要实现与此类似的操作，您必须将参数键入<code>Collection&lt;?&gt;</code>并手动检查元素的类型。</p>
<h4 id="确定参数名称"><a href="#确定参数名称" class="headerlink" title="确定参数名称"></a>确定参数名称</h4><p>通知调用中的参数 binding 依赖于切入点表达式中使用的匹配名称与通知和切入点方法签名中声明的参数名称。参数名称不能通过 Java 反射获得，因此 Spring AOP 使用以下策略来确定参数名称：</p>
<ul>
<li>如果用户已明确指定参数名称，则使用指定的参数名称。 advice 和 pointcut annotations 都有一个可选的<code>argNames</code>属性，您可以使用它来指定带注释的方法的参数名称。这些参数名称在运行时可用。以下代码显示了如何使用<code>argNames</code>属性：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(value=&quot;com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)&quot;,</span></span><br><span class="line"><span class="meta">        argNames=&quot;bean,auditable&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">audit</span><span class="params">(Object bean, Auditable auditable)</span> </span>&#123;</span><br><span class="line">    AuditCode code = auditable.value();</span><br><span class="line">    <span class="comment">// ... use code and bean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果第一个参数是<code>JoinPoint</code>，<code>ProceedingJoinPoint</code>或<code>JoinPoint.StaticPart</code>类型，则可以从<code>argNames</code>属性的 value 中省略参数的 name。例如，如果修改前面的接收以接收连接点 object，则<code>argNames</code>属性不需要包含它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(value=&quot;com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)&quot;,</span></span><br><span class="line"><span class="meta">        argNames=&quot;bean,auditable&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">audit</span><span class="params">(JoinPoint jp, Object bean, Auditable auditable)</span> </span>&#123;</span><br><span class="line">    AuditCode code = auditable.value();</span><br><span class="line">    <span class="comment">// ... use code, bean, and jp</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对<code>JoinPoint</code>，<code>ProceedingJoinPoint</code>和<code>JoinPoint.StaticPart</code>类型的第一个参数赋予的特殊处理对于不收集任何其他连接点 context 的通知实例特别方便。在这种情况下，您可以省略<code>argNames</code>属性。例如，以下通知无需声明<code>argNames</code>属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;com.xyz.lib.Pointcuts.anyPublicMethod()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">audit</span><span class="params">(JoinPoint jp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... use jp</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>&#39;argNames&#39;</code>属性有点笨拙，所以如果没有指定<code>&#39;argNames&#39;</code>属性，Spring AOP 会查看 class 的调试信息，并尝试从局部变量 table 中确定参数名称。此信息以 long 形式显示，因为 classes 已使用调试信息(至少<code>&#39;-g:vars&#39;</code>)进行编译。使用此 flag 进行编译的后果是：(1)您的 code 稍微容易理解(逆向工程)，(2)class 文件大小略大(通常无关紧要)，(3)优化删除未使用的本地变量未由编译器应用。换句话说，你应该通过 building 与 flag 一起遇到任何困难。</li>
</ul>
<blockquote>
<p>  如果即使没有调试信息，AspectJ 编译器(ajc)也编译了 @AspectJ aspect，则无需添加<code>argNames</code>属性，因为编译器会保留所需的信息。</p>
</blockquote>
<ul>
<li>如果在没有必要的调试信息的情况下编译了 code，Spring AOP 会尝试推断 binding 变量与参数的配对(对于 example，如果只有一个变量绑定在切入点表达式中，并且 advice 方法只接受一个参数，那么配对很明显)。如果给定可用信息，变量的 binding 是不明确的，则抛出<code>AmbiguousBindingException</code>。</li>
<li>如果上述所有策略都失败，则抛出<code>IllegalArgumentException</code>。</li>
</ul>
<h4 id="proceed参数"><a href="#proceed参数" class="headerlink" title="proceed参数"></a>proceed参数</h4><p>在args中把参数传入，之后调用proceed方法时传入该方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;execution(List&lt;Account&gt; find*(..)) &amp;&amp; &quot; +</span></span><br><span class="line"><span class="meta">        &quot;com.xyz.myapp.SystemArchitecture.inDataAccessLayer() &amp;&amp; &quot; +</span></span><br><span class="line"><span class="meta">        &quot;args(accountHolderNamePattern)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">preProcessQueryPattern</span><span class="params">(ProceedingJoinPoint pjp,</span></span></span><br><span class="line"><span class="function"><span class="params">        String accountHolderNamePattern)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    String newPattern = preProcess(accountHolderNamePattern);</span><br><span class="line">    <span class="keyword">return</span> pjp.proceed(<span class="keyword">new</span> Object[] &#123;newPattern&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通知顺序"><a href="#通知顺序" class="headerlink" title="通知顺序"></a>通知顺序</h4><p>当在一个连接点上定义了多个通知时，Spring AOP遵循与AspectJ相同的优先级规则来确定通知执行的顺序。order越小越先执行，但是最后执行结束。</p>
<h3 id="5-4-5-引入"><a href="#5-4-5-引入" class="headerlink" title="5.4.5.  引入"></a>5.4.5.  引入</h3><p>引入（Introduction）允许一个切面声明一个实现指定接口的通知对象，并且提供了一个接口实现类来代表这些对象。</p>
<p>使用@DeclareParents注解进行引入。该注解声明匹配类型具有新的父类。例如，给定一个声明为UsageTracked的接口和一个名为DefaultUsageTracked的实现类，以下切面声明服务接口的所有所有实现者也实现了UsageTracked接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsageTracking</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeclareParents(value=&quot;com.xzy.myapp.service.*+&quot;, defaultImpl=DefaultUsageTracked.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UsageTracked mixin;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;com.xyz.myapp.SystemArchitecture.businessService() &amp;&amp; this(usageTracked)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recordUsage</span><span class="params">(UsageTracked usageTracked)</span> </span>&#123;</span><br><span class="line">        usageTracked.incrementUseCount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-4-6-Aspect-Instantiation-Models"><a href="#5-4-6-Aspect-Instantiation-Models" class="headerlink" title="5.4.6.  Aspect Instantiation Models"></a>5.4.6.  Aspect Instantiation Models</h3><p>schema-defined aspects只支持singleton model，即 基于配置文件的aspects只支持单例模式</p>
<h3 id="5-4-7-AOP-Example"><a href="#5-4-7-AOP-Example" class="headerlink" title="5.4.7.  AOP Example"></a>5.4.7.  AOP Example</h3><p>使用环绕通知来实现多次重试操作。</p>
<h2 id="5-5-Schema-based-AOP支持"><a href="#5-5-Schema-based-AOP支持" class="headerlink" title="5.5.  Schema-based AOP支持"></a>5.5.  Schema-based AOP支持</h2><p>Spring也可以使用xml来配置使用AOP，支持使用@AspectJ样式完全相同的切入点表达式和通知类型。</p>
<p>在xml中使用aop命名空间标记，需要导入spring-aop。</p>
<p>在Spring配置中，所有的aspect和advisor元素必须放在&lt;aop:config&gt;。其中可以包含切入点，通知和切面元素。</p>
<h3 id="5-5-1-声明Aspect"><a href="#5-5-1-声明Aspect" class="headerlink" title="5.5.1.  声明Aspect"></a>5.5.1.  声明Aspect</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;myAspect&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;aBean&quot;</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;aBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-5-2-声明切入点"><a href="#5-5-2-声明切入点" class="headerlink" title="5.5.2.  声明切入点"></a>5.5.2.  声明切入点</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;businessService&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">expression</span>=<span class="string">&quot;execution(* com.xyz.myapp.service.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>请注意，切入点表达式本身使用与<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-autoproxy">@AspectJ 支持</a>中描述的相同的 AspectJ 切入点表达式语言。如果使用基于 schema 的声明样式，则可以引用切入点表达式中类型(@Aspects)中定义的命名切入点。定义上述切入点的另一种方法如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;businessService&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">expression</span>=<span class="string">&quot;com.xyz.myapp.SystemArchitecture.businessService()&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>假设您有一个<code>SystemArchitecture</code> aspect，如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-ataspectj">共享 Common 切入点定义</a>中所述。</p>
<p>然后在 aspect 中声明切入点与声明 top-level 切入点非常相似，如下面的 example 所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;myAspect&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;aBean&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;businessService&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">expression</span>=<span class="string">&quot;execution(* com.xyz.myapp.service.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>组合切入点 sub-expressions 时，<code>&amp;&amp;</code>在 XML 文档中很难处理，因此您可以分别使用<code>and</code>，<code>or</code>和<code>not</code>关键字代替<code>&amp;&amp;</code>，<code>||</code>和<code>!</code>。例如，可以更好地编写上一个切入点，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;myAspect&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;aBean&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;businessService&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">expression</span>=<span class="string">&quot;execution(* com.xyz.myapp.service..(..)) and this(service)&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;businessService&quot;</span> <span class="attr">method</span>=<span class="string">&quot;monitor&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-5-3-声明通知"><a href="#5-5-3-声明通知" class="headerlink" title="5.5.3.  声明通知"></a>5.5.3.  声明通知</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;beforeExample&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;aBean&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:before</span></span></span><br><span class="line"><span class="tag">        <span class="attr">pointcut-ref</span>=<span class="string">&quot;dataAccessOperation&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">method</span>=<span class="string">&quot;doAccessCheck&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里，<code>dataAccessOperation</code>是在顶部(<code>&lt;aop:config&gt;</code>)level 定义的切入点的<code>id</code>。要改为内联切入点，请将<code>pointcut-ref</code>属性替换为<code>pointcut</code>属性，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;beforeExample&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;aBean&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:before</span></span></span><br><span class="line"><span class="tag">        <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.xyz.myapp.dao.*.*(..))&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">method</span>=<span class="string">&quot;doAccessCheck&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>抛出异常通知中需要声明抛出的异常的参数名：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;afterThrowingExample&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;aBean&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after-throwing</span></span></span><br><span class="line"><span class="tag">        <span class="attr">pointcut-ref</span>=<span class="string">&quot;dataAccessOperation&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">throwing</span>=<span class="string">&quot;dataAccessEx&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">method</span>=<span class="string">&quot;doRecoveryActions&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>doRecoveryActions</code>方法必须声明一个名为<code>dataAccessEx</code>的参数。此参数的类型以与<code>@AfterThrowing</code>描述的相同方式约束匹配。对于 example，方法签名可以声明如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRecoveryActions</span><span class="params">(DataAccessException dataAccessEx)</span> </span>&#123;...</span><br></pre></td></tr></table></figure>

<p>通知参数通过arg-names属性来实现。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:before</span></span></span><br><span class="line"><span class="tag">    <span class="attr">pointcut</span>=<span class="string">&quot;com.xyz.lib.Pointcuts.anyPublicMethod() and @annotation(auditable)&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">method</span>=<span class="string">&quot;audit&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">arg-names</span>=<span class="string">&quot;auditable&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-5-4-引入"><a href="#5-5-4-引入" class="headerlink" title="5.5.4.  引入"></a>5.5.4.  引入</h3><p>使用<code>aop:aspect</code>中的<code>aop:declare-parents</code>元素进行引入。您可以使用<code>aop:declare-parents</code>元素声明匹配类型具有新的父类。例如，给定名为<code>UsageTracked</code>的接口和名为<code>DefaultUsageTracked</code>的接口实现类，以下 aspect 声明服务接口的所有实现者也实现<code>UsageTracked</code>接口。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;usageTrackerAspect&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;usageTracking&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:declare-parents</span></span></span><br><span class="line"><span class="tag">        <span class="attr">types-matching</span>=<span class="string">&quot;com.xzy.myapp.service.*+&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">implement-interface</span>=<span class="string">&quot;com.xyz.myapp.service.tracking.UsageTracked&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">default-impl</span>=<span class="string">&quot;com.xyz.myapp.service.tracking.DefaultUsageTracked&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:before</span></span></span><br><span class="line"><span class="tag">        <span class="attr">pointcut</span>=<span class="string">&quot;com.xyz.myapp.SystemArchitecture.businessService()</span></span></span><br><span class="line"><span class="tag"><span class="string">            and this(usageTracked)&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">method</span>=<span class="string">&quot;recordUsage&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>就相当于是给满足切入点的bean声明了一个DefaultUsageTracked的父类，那么这些bean都可以向上转型，然后执行父类中的方法。</p>
<p>要实现的接口由<code>implement-interface</code>属性确定。 <code>types-matching</code>属性的 value 是 AspectJ 类型 pattern。匹配类型的任何 bean 都实现<code>UsageTracked</code>接口。</p>
<h3 id="5-5-5-Aspect-Instantiation-Models"><a href="#5-5-5-Aspect-Instantiation-Models" class="headerlink" title="5.5.5.  Aspect Instantiation Models"></a>5.5.5.  Aspect Instantiation Models</h3><p>schema-defined 方面唯一支持的实例化 model 是 singleton model。未来的版本可能支持其他实例化模型。</p>
<h3 id="5-5-6-Advisor"><a href="#5-5-6-Advisor" class="headerlink" title="5.5.6.  Advisor"></a>5.5.6.  Advisor</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;businessService&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">expression</span>=<span class="string">&quot;execution(* com.xyz.myapp.service.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span></span></span><br><span class="line"><span class="tag">        <span class="attr">pointcut-ref</span>=<span class="string">&quot;businessService&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">advice-ref</span>=<span class="string">&quot;tx-advice&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;tx-advice&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>除了前面的 example 中使用的<code>pointcut-ref</code>属性之外，您还可以使用<code>pointcut</code>属性来内联定义切入点表达式。</p>
<p>要定义顾问程序的优先级以便建议可以参与 ordering，请使用<code>order</code>属性来定义顾问程序的<code>Ordered</code> value。</p>
<h2 id="5-8-代理机制"><a href="#5-8-代理机制" class="headerlink" title="5.8.  代理机制"></a>5.8.  代理机制</h2><p>Spring AOP使用JDK动态代理或CGLIB为给定的目标对象创建代理。</p>
<p>如果要代理的目标对象实现至少一个接口，则使用JDK动态代理。目标类型实现的多有接口都是代理的。如果目标对象没有实现任何接口，则会创建CGLIB代理。</p>
<p>如果要强制使用CGLIB代理（例如，代理目标为对象定义的每个方法，而不仅仅是由接口实现的方法），需要考虑以下问题：</p>
<ul>
<li>无法通知<code>final</code>方法，因为它们无法被覆盖。</li>
<li>从 Spring 3.2 开始，不再需要将 CGLIB 添加到项目 classpath 中，因为 CGLIB classes 在<code>org.springframework</code>下重新打包并直接包含在 spring-core JAR 中。这意味着 CGLIB-based 代理支持“正常工作”，就像 JDK 动态代理一样。</li>
<li>从 Spring 4.0 开始，代理 object 的构造函数不再被调用两次，因为 CGLIB 代理实例是通过 Objenesis 创建的。只有当您的 JVM 不允许构造函数绕过时，您才可以从 Spring 的 AOP 支持中看到 两次调用和相应的debug log条目。</li>
</ul>
<p>要强制使用 CGLIB 代理，请将<code>&lt;aop:config&gt;</code>元素的<code>proxy-target-class</code>属性的 value 设置为 true，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- other beans defined here... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>要在使用 @AspectJ auto-proxy 支持时强制 CGLIB 代理，请将<code>&lt;aop:aspectj-autoproxy&gt;</code>元素的<code>proxy-target-class</code>属性设置为<code>true</code>，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>需要明确的是，在<code>&lt;tx:annotation-driven/&gt;</code>，<code>&lt;aop:aspectj-autoproxy/&gt;</code>或<code>&lt;aop:config/&gt;</code>元素上使用<code>proxy-target-class=&quot;true&quot;</code>会强制对所有这三个元素使用 CGLIB 代理。</p>
<h3 id="5-8-1-了解AOP代理"><a href="#5-8-1-了解AOP代理" class="headerlink" title="5.8.1.  了解AOP代理"></a>5.8.1.  了解AOP代理</h3><p>Spring AOP是基于代理的。</p>
<h2 id="5-9-程序化创建-AspectJ代理"><a href="#5-9-程序化创建-AspectJ代理" class="headerlink" title="5.9.  程序化创建@AspectJ代理"></a>5.9.  程序化创建@AspectJ代理</h2><p>您可以使用<code>org.springframework.aop.aspectj.annotation.AspectJProxyFactory</code> class 为一个或多个 @AspectJ 方面建议的目标 object 创建代理。这个 class 的基本用法非常简单，如下面的示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a factory that can generate a proxy for the given target object</span></span><br><span class="line">AspectJProxyFactory factory = <span class="keyword">new</span> AspectJProxyFactory(targetObject);</span><br><span class="line"></span><br><span class="line"><span class="comment">// add an aspect, the class must be an @AspectJ aspect</span></span><br><span class="line"><span class="comment">// you can call this as many times as you need with different aspects</span></span><br><span class="line">factory.addAspect(SecurityManager.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// you can also add existing aspect instances, the type of the object supplied must be an @AspectJ aspect</span></span><br><span class="line">factory.addAspect(usageTracker);</span><br><span class="line"></span><br><span class="line"><span class="comment">// now get the proxy object...</span></span><br><span class="line">MyInterfaceType proxy = factory.getProxy();</span><br></pre></td></tr></table></figure>

<h2 id="5-10-将AspectJ与Spring-Applicaitons一起使用"><a href="#5-10-将AspectJ与Spring-Applicaitons一起使用" class="headerlink" title="5.10.  将AspectJ与Spring Applicaitons一起使用"></a>5.10.  将AspectJ与Spring Applicaitons一起使用</h2><p><code>@Configurable</code> annotation 将 class 标记为符合 Spring-driven configuration 的条件。在最简单的情况下，您可以纯粹使用它作为标记 annotation，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xyz.myapp.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Configurable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configurable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Configurable(preConstruction = true)</code> 这个注解的作用是：<br>告诉<code>Spring</code>在构造函数运行之前将依赖注入到对象中。</p>
<p>如果要显式指定要使用的原型 bean 定义的 name，可以直接在 annotation 中执行此操作，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xyz.myapp.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Configurable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configurable(&quot;account&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用自动装配来避免必须指定专用的 bean 定义。要让 Spring 应用自动装配，请使用<code>@Configurable</code> 注释的<code>autowire</code> property。您可以分别按类型或 name 指定<code>@Configurable(autowire=Autowire.BY_TYPE)</code>或<code>@Configurable(autowire=Autowire.BY_NAME</code>进行自动装配。作为替代，从 Spring 2.5 开始，最好通过在字段或方法 level 上使用<code>@Autowired</code>或<code>@Inject</code>为<code>@Configurable</code> beans 指定显式的 annotation-driven 依赖注入(有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-aj-ltw">Annotation-based Container Configuration</a>)。</p>
<p>最后，您可以使用<code>dependencyCheck</code>属性(对于 example，<code>@Configurable(autowire=Autowire.BY_NAME,dependencyCheck=true)</code>)为新创建和配置的 object 中的 object references 启用 Spring 依赖性检查。如果此属性设置为<code>true</code>，则 Spring 会在 configuration 之后验证是否已设置所有 properties(不是 primitives 或集合)。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">crazyStrome</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://crazystrome.github.io/2020/11/06/spring/">http://crazystrome.github.io/2020/11/06/spring/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://crazyStrome.github.io" target="_blank">crazyStrome的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a><a class="post-meta__tags" href="/tags/Spring/">Spring</a></div><div class="post_share"><div class="social-share" data-image="https://dzone.com/storage/temp/12434118-spring-boot-logo.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/11/06/SpringBoot/"><img class="prev-cover" src="https://dzone.com/storage/temp/12434118-spring-boot-logo.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Spring Boot笔记</div></div></a></div><div class="next-post pull-right"><a href="/2020/11/06/Redis%E8%BF%90%E7%BB%B4-%E5%AD%97%E7%AC%A6%E4%B8%B2/"><img class="next-cover" src="http://www.bingimg.cn/down/OHR.KobukRiver_ZH-CN9932342738_1920x1080.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Redis运维-字符串</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/11/06/spring总结/" title="Spring总结"><img class="cover" src="https://dzone.com/storage/temp/12434118-spring-boot-logo.png"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-06</div><div class="title">Spring总结</div></div></a></div><div><a href="/2020/11/06/SpringMVC连接数据库/" title="SpringMVC连接数据库"><img class="cover" src="https://dzone.com/storage/temp/12434118-spring-boot-logo.png"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-06</div><div class="title">SpringMVC连接数据库</div></div></a></div><div><a href="/2020/11/06/SpringBoot/" title="Spring Boot笔记"><img class="cover" src="https://dzone.com/storage/temp/12434118-spring-boot-logo.png"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-06</div><div class="title">Spring Boot笔记</div></div></a></div><div><a href="/2020/11/04/OnJava8笔记/" title="OnJava8笔记"><img class="cover" src="https://visiontrainingsystems.com/wp-content/uploads/2016/05/java-690x388.png"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-04</div><div class="title">OnJava8笔记</div></div></a></div><div><a href="/2020/11/04/HashMap的hash原理/" title="HashMap的hash原理"><img class="cover" src="https://visiontrainingsystems.com/wp-content/uploads/2016/05/java-690x388.png"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-04</div><div class="title">HashMap的hash原理</div></div></a></div><div><a href="/2020/11/04/JVM的内存分区/" title="JVM内存分区"><img class="cover" src="https://i.loli.net/2020/03/22/HIx6ugVmdNTRMwE.png"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-04</div><div class="title">JVM内存分区</div></div></a></div></div></div></article></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 By crazyStrome</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>