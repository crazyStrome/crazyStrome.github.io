<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="啥都写">
<meta property="og:type" content="website">
<meta property="og:title" content="crazyStrome的博客">
<meta property="og:url" content="http://crazystrome.github.io/index.html">
<meta property="og:site_name" content="crazyStrome的博客">
<meta property="og:description" content="啥都写">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="crazyStrome">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://crazyStrome.github.io/"/>





  <title>crazyStrome的博客</title>
  








<meta name="generator" content="Hexo 5.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">crazyStrome的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://crazyStrome.github.io/2020/11/04/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="crazyStrome的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/11/04/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/" itemprop="url">MySQL技术内幕</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-11-04T20:20:55+08:00">
                2020-11-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-MySQL体系结构和存储引擎"><a href="#1-MySQL体系结构和存储引擎" class="headerlink" title="1.  MySQL体系结构和存储引擎"></a>1.  MySQL体系结构和存储引擎</h1><h2 id="1-1-定义数据库和实例"><a href="#1-1-定义数据库和实例" class="headerlink" title="1.1.  定义数据库和实例"></a>1.1.  定义数据库和实例</h2><p>数据库：物理操作系统文件或其他形式文件类型的集合。</p>
<p>实例：MySQL数据库由后台线程以及一个共享内存区组成。共享内存可以被运行的后台线程所共享。数据库实例才是真正用于操作数据库文件的。</p>
<p>MySQL被设计成一个单进程多线程架构的数据库。MySQL数据库实例在系统上的表现就是一个进程。</p>
<h2 id="1-2-MySQL体系结构"><a href="#1-2-MySQL体系结构" class="headerlink" title="1.2.  MySQL体系结构"></a>1.2.  MySQL体系结构</h2><p>从概念上来说，数据库是文件的集合，是依照某种数据模型组织起来并存放于二级存储器中的数据集合：数据库实例是程序，是位于用户与操作系统之间的一层数据管理软件，用户对数据库数据的任何操作，包括数据库定义、数据库查询、数据维护、数据库运行控制等都是在数据库实例下进行的，应用程序只有通过数据库实例才能和数据库打交道。</p>
<p>数据库是由一个个文件组成（一般来说都是二进制文件），要对这些文件执行诸如SELECT、INSERT、UPDATE和DELETE之类的操作是不能通过简单的操作文件来更改数据库的内容，需要通过数据库实例来完成对数据库的操作。</p>
<p><img src="https://i.loli.net/2020/04/29/UxIWHj1GQEXgSaq.png"></p>
<p>MySQL由一下几部分组成：</p>
<ul>
<li>连接池组件</li>
<li>管理服务和工具组件</li>
<li>SQL接口组件</li>
<li>查询分析器组件</li>
<li>优化器组件</li>
<li>缓冲组件</li>
<li>插件式存储引擎</li>
<li>物理文件</li>
</ul>
<p>MySQL数据库区别于其他数据库的最重要的一个特点就是其插件式的表存储引擎。</p>
<p>存储引擎是基于表的，而不是数据库。</p>
<h2 id="1-3-MySQL存储引擎"><a href="#1-3-MySQL存储引擎" class="headerlink" title="1.3.  MySQL存储引擎"></a>1.3.  MySQL存储引擎</h2><p>存储引擎是MySQL区别于其他数据库的一个重要特性。存储引擎的好处是，每个存储引擎都有各自的特点，能够根据具体的应用建立不同存储引擎表。</p>
<h3 id="1-3-1-InnoDB存储引擎"><a href="#1-3-1-InnoDB存储引擎" class="headerlink" title="1.3.1.  InnoDB存储引擎"></a>1.3.1.  InnoDB存储引擎</h3><p>InnoDB存储引擎支持事务，其设计目标主要面向在线事务处理（OLTP）的应用，其特点是行锁设计、支持外键，并支持类似于Oracle的非锁定读，即默认读取操作不会产生锁。</p>
<p>InnoDB存储引擎将数据放在一个逻辑的表空间中，这个表空间就像黑盒一样由InnoDB存储引擎自身进行管理。</p>
<p>InnoDB使用多版本并发控制来获得高并发性，并且实现了SQL标准的四种隔离级别，默认为REPEATABLE级别。同时，使用一种称为next-key locking的策略来避免幻读现象的产生。除此之外，InnoDB存储引擎还提供了插入缓冲、二次写、自适应哈希索引、预读等高性能和高可用的功能。</p>
<p>对于表中数据的存储，InnoDB存储引擎使用了聚集的方式，因此每张表的存储都是按照主键的顺序进行存放。如果没有显示地在表定义的时候指定主键，InnoDB存储引擎会为每一行生成一个6字节的ROWID，并以此作为主键。</p>
<h3 id="1-3-2-MyISAM存储引擎"><a href="#1-3-2-MyISAM存储引擎" class="headerlink" title="1.3.2.  MyISAM存储引擎"></a>1.3.2.  MyISAM存储引擎</h3><p>MyISAM存储引擎不支持事务、表锁设计，支持全文索引，主要面向一些OLAP数据库应用。数据库系统与文件系统很大的一个不同之处在与对事务的支持，然而MyISAM存储引擎是不支持事务的。其缓冲池只缓存索引文件，而不缓冲数据文件。</p>
<p>MyISAM存储引擎由MYD和MYI组成，MYD用来存放数据文件，MYI用来存放索引文件。可以通过使用myisampack工具进一步压缩数据。</p>
<h2 id="1-4-各存储引擎之间的比较"><a href="#1-4-各存储引擎之间的比较" class="headerlink" title="1.4.  各存储引擎之间的比较"></a>1.4.  各存储引擎之间的比较</h2><p><img src="https://i.loli.net/2020/04/29/yCMnVu2adWxROtv.png"></p>
<h2 id="1-5-连接MySQL"><a href="#1-5-连接MySQL" class="headerlink" title="1.5.  连接MySQL"></a>1.5.  连接MySQL</h2><p>连接MySQL操作是一个连接进程和MySQL数据库实例进行通信。常用的进程通信方式有管道、命名管道、共享内存、套接字、消息队列、信号量。</p>
<h1 id="2-InnoDB存储引擎"><a href="#2-InnoDB存储引擎" class="headerlink" title="2.  InnoDB存储引擎"></a>2.  InnoDB存储引擎</h1><p><img src="https://i.loli.net/2020/04/29/am2NSvtTfnhgBdU.png"></p>
<p>InnoDB存储引擎由多个内存块，可以认为这些内存块组成了一个大的内存池，负责如下工作：</p>
<ul>
<li>维护所有进程/线程需要访问的多个内部数据结构</li>
<li>缓存磁盘上的数据，方便快速地读取，同时在对磁盘文件的数据修改之前在这里缓存</li>
<li>重做日志（redo log）缓冲</li>
<li>。。。。</li>
</ul>
<p>后台线程的主要作用是负责刷新内存池的数据，保证缓存池中的内存缓存是最近的数据。此外将已修改的数据文件刷新到磁盘文件，同时保证在数据库发生异常的情况下，InnoDB能恢复到正常状态。</p>
<h3 id="2-3-1-后台线程"><a href="#2-3-1-后台线程" class="headerlink" title="2.3.1.  后台线程"></a>2.3.1.  后台线程</h3><p>InnoDB是多线程的模型，因此后台有多个不同的后台线程，负责处理不同的任务。</p>
<ol>
<li>Master Thread</li>
</ol>
<p>Master Thread是一个非常核心的后台线程，主要负责将缓冲池的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲、UNDO页的回收等。</p>
<ol start="2">
<li>IO Thread</li>
</ol>
<p>在InnoDB中使用了大量的AIO来处理写IO请求，这样可以极大提高数据库的性能。而IO Thread的工作主要是负责这些IO请求的回调处理。</p>
<ol start="3">
<li>Purge Thread</li>
</ol>
<p>事务被提交后，其所使用的undolog可能不再需要，因此需要Purge Thread来回收已经使用并分配的undo页。</p>
<ol start="4">
<li>Page Cleaner Thread</li>
</ol>
<p>Page Cleaner Thread作用是将之前版本中脏页的刷新操作都放入到单独的线程中来完成。其目的是为了减轻元Master Thread的工作以及对于用户查询线程的阻塞，进一步提高InnoDB存储引擎的性能。</p>
<h3 id="2-3-2-内存"><a href="#2-3-2-内存" class="headerlink" title="2.3.2.  内存"></a>2.3.2.  内存</h3><p><img src="upload%5Cimage-20200429172042048.png" alt="image-20200429172042048"></p>
<ol>
<li>缓冲池</li>
</ol>
<p>InnoDB是基于磁盘存储的，并将其中的记录按照页的方式进行管理。基于磁盘的数据库系统通常使用缓冲池技术来提高数据库的整体性能。</p>
<p>缓冲池其实就是一块内存区域，通过内存的速度来弥补磁盘速度较慢对数据库性能的影响。在数据库中进行读取页的操作，首先将从磁盘读到的页存放在缓冲池中，这个过程称为将页“FIX”在缓冲池中。下一次再读相同的页时，首先判断该页是否在缓冲池中。若在缓冲池中，称该页在缓冲池中被命中，直接读取该页。否则，读取磁盘上的页。</p>
<p>对于数据库中页的修改操作，首先修改在缓冲池中的页，然后再以一定的频率刷新到磁盘中。这里需要注意的是，页从缓冲池刷新回磁盘的操作并不是在每次页发生更新时触发，而是通过一种称为Checkpoint的机制刷新回磁盘。</p>
<p>缓冲池中缓存的数据页类型有：索引页、数据页、undo页、插入缓冲、自适应哈希索引、InnoDB存储的锁信息、数据字典信息等。</p>
<ol start="2">
<li>LRU List、Free List和Flush List</li>
</ol>
<p>数据库的缓冲池是通过LRU（Least Recent Used，最近最少使用）算法来进行管理的，即最频繁使用的页在LRU列表的前端，而最少使用的页在LRU列表的尾端。当缓冲池不能存放新读取到的页时，将首先释放LRU列表中尾端的页。</p>
<p>InnoDB对传统的LRU算法做了一些优化，在InnoDB的存储引擎中，LRU列表还加入了midpoint位置。新读取到的页，虽然是最新访问的页，但并不是直接放入到LRU列表的首部，而是放入到LRU列表的midpoint位置。这个算法在InnoDB下成为midpoint insertion strategy。在默认配置下，该位置在LRU列表长度的5/8处。</p>
<p>在InnoDB中，midpoint之后的列表成为old列表，之前的列表成为new列表。可以认为new列表都是活跃的数据。</p>
<p>如果直接将读取到的页放入到LRU的首部，那么某些SQL操作可能会使缓冲池中的页被刷新出，从而影响缓冲池效率。常见的操作为索引或者数据的扫描操作。这类操作会访问许多页，这些页可能只是在此次查询操作中需要，并不是活跃的热点数据。如果页被放入到LRU列表的首部，那么非常可能将所需要的热点数据页从LRU列表中移除，而在下一次需要读取该页时，InnoDB可能需要再次访问磁盘。</p>
<p>为了解决这个问题，InnoDB引入了innodb_old_blocks_time来进一步管理LRU列表。用于表示页读取到mid位置后需要等待多久才会被放入到LRU列表的热端。</p>
<p>LRU用来管理已经读取的页，当数据库刚启动时，LRU列表时空的，即没有任何的页。这时，页都存放在free列表中。当需要从缓冲池中分页时，首先从Free列表中查找是否有可用的空闲页，若有，则将改页从free列表中删除，放入到LRU列表中。否则，根据LRU算法，淘汰LRU列表末尾的页，将该内存空间分配给新的页。当页从LRU列表的old部分加入到new部分时，称此时发生的操作为page made young，而因为innodb_old_blocks_time的设置而导致页没有从old部分移动到new部分的操作称为page not made young。可以通过<code>SHOW ENGINE INNODB STATUS</code>来观察LRU列表以及Free列表的使用情况和运行状态。</p>
<ol start="3">
<li>重做日志缓冲</li>
</ol>
<p>InnoDB首先将重做日志信息放入到这个缓冲区，然后按照一定频率将其刷新到重做日志文件。重做日志缓冲一般不需要设置得很大，因为一般情况下每一秒钟会将重做日志缓冲刷新到日志文件，因此用户只需要保证每秒产生的事务量在这个缓冲大小之内即可。</p>
<ol start="4">
<li>额外的内存池</li>
</ol>
<p>在InnoDB中，对内存的管理是通过内存堆进行的。在对一些数据结构本身的内存进行分配时，需要从额外的内存池中进行申请，当该区域的内存不够时，会从缓冲池进行申请。</p>
<h2 id="2-4-Checkpoint技术"><a href="#2-4-Checkpoint技术" class="headerlink" title="2.4.  Checkpoint技术"></a>2.4.  Checkpoint技术</h2><p>如果在从缓冲池中将页的新版本刷新到磁盘时发生了宕机，那么数据就不能恢复了。为了避免发生数据丢失的问题，当前事务数据库系统普遍采用了Write Ahead Log策略，即当事务提交时，先写重做日志，再修改页。当由于宕机而导致数据丢失时，通过重做日志来完成数据的恢复。这也是ACID中D的要求。</p>
<p>Checkpoint技术的目的是解决一下问题：</p>
<ul>
<li>缩短数据库的恢复时间</li>
<li>缓冲池不够用时，将脏页刷新到磁盘</li>
<li>重做日志不可用时，刷新脏页</li>
</ul>
<p>当数据库发生宕机时，数据库不需要重做所有日志，因为checkpoint之前的页都已经刷新回磁盘。所以数据库只需对checkpoint后的重做日志进行恢复。</p>
<p>当缓冲池不够用时，根据LRU算法会溢出最近最少使用的页，若此页为脏页，那么需要强制执行checkpoint，将脏页也就是页的新版本刷新回磁盘。</p>
<p>InnoDB是通过LSN（Log Sequence Number）来标记版本的。LSN是8字节的数字。每个页有LSN，重做日志也有LSN，Checkpoint也有LSN。</p>
<p>在InnoDB中，有两种Checkpoint，分别为：</p>
<ul>
<li>Sharp Checkpoint</li>
<li>Fuzzy Checkpoint</li>
</ul>
<p>Sharp Checkpoint发生在数据库关闭时将所有的脏页都刷新回磁盘。</p>
<p>InnoDB内部使用Fuzzy Checkpoint进行页的刷新，即只刷新一部分脏页，而不是刷新所有的脏页回磁盘。</p>
<p>在InnoDB中可能发生如下几种情况的Fuzzy Checkpoint：</p>
<ul>
<li>Master Thread Checkpoint</li>
<li>FLUSH_LRU_LIST Checkpoint</li>
<li>Async/Sync Flush Checkpoint</li>
<li>Dirty Page too much Checkpoint</li>
</ul>
<p>对于Master Thread发生的Checkpoint。差不多以每十秒或者每一秒的速度从缓冲池的脏页列表中刷新一定比例的页回磁盘。这个过程是异步的，即此时的InnoDB存储引擎可以进行其他操作，用户查询线程不会阻塞。</p>
<p>FLUSH_LRU_LIST Checkpoint是因为InnoDB需要保证LRU列表中需要有差不多100个空闲页可以使用。</p>
<p>Async/Sync Flush Checkpoint指的是重做日志文件不可用的情况，这是需要强制将一些页刷新回磁盘，而此时脏页是从脏页列表中选取的。</p>
<p>Dirty Page too much，即脏页的数量太多，导致InnoDB强制进行Checkpoint。</p>
<h2 id="2-5-Master-Thread-工作方式"><a href="#2-5-Master-Thread-工作方式" class="headerlink" title="2.5.  Master Thread 工作方式"></a>2.5.  Master Thread 工作方式</h2><p>InnoDB的主要工作都是在一个单独的后台线程Master Thread中完成的。</p>
<h3 id="2-5-1-InnoDB-1-0-x版本之前的Master-Thread"><a href="#2-5-1-InnoDB-1-0-x版本之前的Master-Thread" class="headerlink" title="2.5.1.  InnoDB 1.0.x版本之前的Master Thread"></a>2.5.1.  InnoDB 1.0.x版本之前的Master Thread</h3><p>Master Thread具有最高的线程优先级别。其内部由多个循环组成：主循环（Loop）、后台循环（Backgroup loop）、刷新循环（flush loop）、暂停循环（suspend loop）。Master Thread会根据数据库运行的状态在loop、background loop、flush loop和suspend loop中进行切换。</p>
<p>loop称为主循环，大多数操作是在这个循环中。其中有两大部分的操作–每秒钟的操作和每十秒钟的操作。</p>
<p>每秒一次的操作包括：</p>
<ul>
<li>日志缓冲刷新到磁盘，即使这个事务还没有提交</li>
<li>合并插入缓冲</li>
<li>之多刷新100个InnoDB的缓冲池中的脏页到磁盘</li>
<li>如果当前没有用户活动，则切换到background loop</li>
</ul>
<p>每十秒的操作包括：</p>
<ul>
<li>刷新100个脏页到磁盘</li>
<li>合并至多五个插入缓冲</li>
<li>将日志缓冲刷新到磁盘</li>
<li>删除无用的Undo页</li>
<li>刷新100个或者10个脏页到磁盘</li>
</ul>
<p>若当前没有用户活动或者数据库关闭，就会切换到background loop。执行以下操作：</p>
<ul>
<li>删除无用的Undo页</li>
<li>合并20个插入缓冲</li>
<li>跳回到主循环</li>
<li>不断刷新100个页直到符合条件</li>
</ul>
<p>如果flush loop没有事情做，InnoDB引擎会切换到suspend loop，将Master Thread挂起，等待事件的发生。若用户启用了InnoDB，却没有任何InnoDB的表使用，那么Master Thread总是处于挂起的状态。</p>
<h3 id="2-5-2-InnoDB1-2-x版本之前的Master-Thread"><a href="#2-5-2-InnoDB1-2-x版本之前的Master-Thread" class="headerlink" title="2.5.2.  InnoDB1.2.x版本之前的Master Thread"></a>2.5.2.  InnoDB1.2.x版本之前的Master Thread</h3><p>提高磁盘的IO</p>
<h2 id="2-6-InnoDB的关键特性"><a href="#2-6-InnoDB的关键特性" class="headerlink" title="2.6.  InnoDB的关键特性"></a>2.6.  InnoDB的关键特性</h2><p>InnoDB的关键特性包括：</p>
<ul>
<li>插入缓冲</li>
<li>两次写</li>
<li>自适应哈希索引</li>
<li>异步IO</li>
<li>刷新邻接页</li>
</ul>
<h3 id="2-6-1-插入缓冲"><a href="#2-6-1-插入缓冲" class="headerlink" title="2.6.1.  插入缓冲"></a>2.6.1.  插入缓冲</h3><ol>
<li>Insert Buffer</li>
</ol>
<p>Insert Buffer和数据页一样，也是物理页的一个组成部分。</p>
<p>插入聚集索引一般是顺序的，不需要磁盘的随机读取。</p>
<p>当一张表上有非聚集的辅助索引时，在进行插入操作时，数据页的存放还是按主键进行顺序存放的，但是对于非聚集索引叶子节点的插入不再是顺序的了，需要离散地访问非聚集索引页，由于随机读取的存在而导致了插入操作性能下降。这是因为B+树的特性决定了非聚集索引插入的离散性。</p>
<p>在InnoDB中使用了Insert Buffer，对于非聚集索引的插入或者更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，若在，则直接插入；若不在，则先放入到一个Insert Buffer对象中，好像在欺骗数据库这个非聚集的索引已经插到了叶子节点中，而实际没有，只是存放在另一个位置。然后再以一定的频率和情况进行Insert Buffer和辅助索引页子节点的merge操作。</p>
<p>使用Insert Buffer需要满足一下两个条件：</p>
<ul>
<li>索引是辅助索引</li>
<li>索引不是唯一的</li>
</ul>
<ol start="2">
<li>Change Buffer</li>
</ol>
<p>InnoDB可以对DML操作-INSERT、DELETE、UPDATE都进行缓冲，分别是：Insert Buffer、Delete Buffer、Purge Buffer。</p>
<ol start="3">
<li>Insert Buffer的内部实现</li>
</ol>
<p>Insert Buffer的数据结构是一颗B+树。非叶子节点存放的是查询的search key。</p>
<p><img src="https://i.loli.net/2020/05/02/QA2GYbDgZsjN9Rm.png"></p>
<p>search key一共占用9个字节，其中space表示插入记录所在表的表空间id，在InnoDB中，每个表有一个唯一的space id，可以通过space id查询得知是哪张表。space占用4个字节。marker占用1字节，它使用来兼容老版本的Insert Buffer。offset表示所在页的偏移量，占用4个字节。</p>
<ol start="4">
<li>Merge Insert Buffer</li>
</ol>
<p>Merge Insert Buffer的操作可能发生在以下几种情况下：</p>
<ul>
<li>辅助索引页被读取到缓冲池</li>
<li>Insert Buffer Bitmap页追踪到该辅助索引页已无可用空间</li>
<li>Master Thread</li>
</ul>
<h3 id="2-6-2-两次写"><a href="#2-6-2-两次写" class="headerlink" title="2.6.2  两次写"></a>2.6.2  两次写</h3><p>doublewrite给InnoDB带来数据页的可靠性。</p>
<p>当发生数据库宕机时，存储引擎正在写入某个页到表中，而这个页只写了一部分，这种情况称为部分写失效。</p>
<p>在应用重做日志的时候，需要一个页的副本，当写入时效时，先通过页的副本来还原该页，再进行重做，这就是两次写。</p>
<h3 id="2-6-3-自适应哈希索引"><a href="#2-6-3-自适应哈希索引" class="headerlink" title="2.6.3  自适应哈希索引"></a>2.6.3  自适应哈希索引</h3><p>哈希的查找时间复杂度为o(1)。</p>
<p>InnoDB会监控对表上的各索引页的查询。如果观察到建立哈希索引可以带来速度提升，则建立哈希索引，称之为自适应哈希索引（Adaptive Hash Index，AHI）。AHI是通过缓冲池的B+树页构造而来的，因此建立的速度很快，而且不需要对整张表建立哈希索引。InnoDB会根据访问的频率和模式来自动地为某些热点页建立哈希索引。</p>
<h3 id="2-6-4-异步IO"><a href="#2-6-4-异步IO" class="headerlink" title="2.6.4  异步IO"></a>2.6.4  异步IO</h3><p>AIO可以同时发出多个IO请求。</p>
<p>AIO可以进行IO merge操作，就是把多个IO合并成一个IO，这样可以提高IOPS的性能。</p>
<h3 id="2-6-5-刷新邻接页"><a href="#2-6-5-刷新邻接页" class="headerlink" title="2.6.5  刷新邻接页"></a>2.6.5  刷新邻接页</h3><p>当刷新一个脏页时，InnoDB会检测该页所在区的所有页，如果是脏页，那么一起刷新。</p>
<h1 id="5-索引与算法"><a href="#5-索引与算法" class="headerlink" title="5  索引与算法"></a>5  索引与算法</h1><h2 id="5-1-InnoDB存储引擎索引概述"><a href="#5-1-InnoDB存储引擎索引概述" class="headerlink" title="5.1  InnoDB存储引擎索引概述"></a>5.1  InnoDB存储引擎索引概述</h2><p>InnoDB支持一下几种常见的索引：</p>
<ul>
<li>B+索引</li>
<li>全文索引</li>
<li>哈希索引</li>
</ul>
<p>InnoDB支持的哈希索引是自适应的，InnoDB存储引擎会根据表的使用情况自动生成哈希索引，不能人为干预是否在一张表中生成哈希索引。</p>
<p>B+树索引的构造类似于二叉树，根据键值快速找到数据。</p>
<p>B+树索引并不能找到一个给定键值的具体行。B+树索引能找到的只是被查找数据航所在的页，然后通过数据库把页读入到内存，再在内存中进行查找，最后得到要查找的数据。</p>
<h2 id="5-2-数据结构与算法"><a href="#5-2-数据结构与算法" class="headerlink" title="5.2  数据结构与算法"></a>5.2  数据结构与算法</h2><h3 id="5-2-1-二分查找法"><a href="#5-2-1-二分查找法" class="headerlink" title="5.2.1  二分查找法"></a>5.2.1  二分查找法</h3><p>将记录按有序化排列，在查找过程中采用跳跃式查找，即先以有序数列的中点位置为比较对象，如果要找的元素值小于该中点元素，则将待查序列缩小为左半部分，否则为右半部分。通过一次查找，将查找区间缩小一半。</p>
<h3 id="5-2-2-二叉查找树和平衡二叉树"><a href="#5-2-2-二叉查找树和平衡二叉树" class="headerlink" title="5.2.2  二叉查找树和平衡二叉树"></a>5.2.2  二叉查找树和平衡二叉树</h3><p>当二叉查找树单边增长时，可以使用平衡二叉树。</p>
<p>平衡二叉树满足任何节点的两个子树的高度最大差为1.</p>
<p>平衡二叉树的查询速度很快，但是维护一颗平衡二叉树的代价很大，需要进行多次的旋转来实现。</p>
<h2 id="5-3-B-树"><a href="#5-3-B-树" class="headerlink" title="5.3  B+树"></a>5.3  B+树</h2><p>B+树是为磁盘或其他直接存取辅助设备设计的平衡查找树。</p>
<h2 id="5-4-B-树索引"><a href="#5-4-B-树索引" class="headerlink" title="5.4  B+树索引"></a>5.4  B+树索引</h2><p>数据库中的B+树索引分为聚集索引和辅助索引，叶子节点存放所有数据。聚集索引和辅助索引不同的是，叶子节点存放的是否是一整行的信息。</p>
<h3 id="5-4-1-聚集索引"><a href="#5-4-1-聚集索引" class="headerlink" title="5.4.1  聚集索引"></a>5.4.1  聚集索引</h3><p>InnoDB存储引擎表的索引组织表，即表中数据按照主键顺序存放。而聚集索引就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的即为整张表的行记录数据，也将聚集索引的叶子节点称为数据页。聚集索引的这个特性决定了索引组织表中数据也是索引的一部分。同B+树数据结构一样，每个数据页否通过一个双向链表来进行链接。</p>
<p>每张表智能有一个聚集索引。聚集索引可以在B+树索引的叶子节点上直接找到数据，聚集索引可以很快地访问针对范围值的查询。</p>
<p>数据页上存放的是完整的每行的记录，而在非数据页的索引页中，存放的仅仅是键值及指向数据页的偏移量，而不是一个完整的行记录。</p>
<p>聚集索引存储并不是物理上连续的，而是逻辑上连续的。页通过双向链表链接，页按照主键的顺序排列；页中的记录也是通过双向链表进行维护的，物理存储上可以同样不按照主键存储。</p>
<p>聚集索引的好处：对于主键的排序查找和范围查找速度非常快。叶子节点的数据就是用户所要查询的数据。</p>
<h3 id="5-4-2-辅助索引"><a href="#5-4-2-辅助索引" class="headerlink" title="5.4.2  辅助索引"></a>5.4.2  辅助索引</h3><p>辅助索引也称非聚集性索引，叶子节点不包含行记录的全部数据。叶子节点除了包含键值以外，每个叶子节点中的索引行中还包含了一个书签。该书签用来告诉InnoDB哪里可以找到与索引对应的行数据。由于InnoDB存储引擎表是索引组织表，因此InnoDB存储引擎的辅助索引的书签就是相应行数据的聚集索引键。</p>
<p>辅助索引的存在并不影响数据在聚集索引中的组织，因此每张表可以有多个辅助索引。当通过辅助索引来寻找数据时，InnoDB会遍历辅助索引并通过叶级别的指针获得指向主键索引的主键，再通过主键索引来找到一个完整的行记录。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://crazyStrome.github.io/2020/11/04/JVM%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="crazyStrome的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/11/04/JVM%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/" itemprop="url">JVM内存分区</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-11-04T20:20:15+08:00">
                2020-11-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>JVM内存区域分为五个部分，分别是堆，方法区，虚拟机栈，本地方法栈，程序计数器。</p>
<p><img src="https://i.loli.net/2020/03/22/HIx6ugVmdNTRMwE.png" alt="img"></p>
<ul>
<li>堆。堆是Java对象的存储区域，任何用new字段分配的Java对象实例和数组，都被分配在堆上，Java堆可使用-Xms -Xmx进行内存控制，值得一提的是从JDK1.7版本之后，运行时常量池从方法区移到了堆上。</li>
<li>方法区。它用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据，方法区在JDK1.7版本及以前被称为永久代，从JDK1.8永久代被移除。</li>
<li>虚拟机栈。虚拟机中执行每个方法的时候，都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。</li>
<li>本地方法栈。与虚拟机栈发挥的作用相似，相比于虚拟机栈为Java方法服务，本地方法栈为虚拟机使用的Native方法服务，执行每个本地方法的时候，都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。</li>
<li>程序计数器。指示Java虚拟机下一条需要执行的字节码指令。 </li>
</ul>
<p>以上五个区域是Java虚拟机内存划分情况，其中方法区和堆被JVM中多个线程共享，比如类的静态常量就被存放在方法区，供类对象之间共享，虚拟机栈，本地方法栈，pc寄存器是每个线程独立拥有的，不会与其他线程共享。 </p>
<p>所以Java在通过new创建一个类对象实例的时候，一方面会在虚拟机栈中创建一个该对象的引用，另一方面会在堆上创建类对象的实例，然后将对象引用指向该对象的实例。对象引用存放在每一个方法对应的栈帧中。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://crazyStrome.github.io/2020/11/04/JVM%E7%9A%84GC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="crazyStrome的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/11/04/JVM%E7%9A%84GC/" itemprop="url">JVM的GC</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-11-04T20:19:23+08:00">
                2020-11-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>垃圾收集 Garbage Collection 通常被称为“GC”，它诞生于1960年 MIT 的 Lisp 语言，经过半个多世纪，目前已经十分成熟了。</p>
<p>jvm 中，程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理，因此，我们的内存垃圾回收<strong>主要集中于 java 堆和方法区中</strong>，在程序运行期间，这部分内存的分配和使用都是动态的。</p>
<h1 id="对象存活判断"><a href="#对象存活判断" class="headerlink" title="对象存活判断"></a>对象存活判断</h1><p>判断对象是否存活一般有两种方式：</p>
<ul>
<li><p>引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，<strong>无法解决对象相互循环引用</strong>的问题。</p>
</li>
<li><p>可达性分析（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。</p>
<p>  在Java语言中，<strong>GC Roots</strong>包括：</p>
<ul>
<li>虚拟机栈中引用的对象。</li>
<li>方法区中类静态属性实体引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>本地方法栈中JNI引用的对象。</li>
</ul>
</li>
</ul>
<h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记 -清除算法"></a>标记 -清除算法</h2><p><strong>标记-清除</strong>”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。</p>
<p>它的主要缺点有两个：一个是效率问题，标记和清除过程的效率都不高；另外一个是空间问题，标记清除之后会产生大量不连续的内存碎片，<strong>空间碎片太多</strong>可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>
<p><img src="https://i.loli.net/2020/03/22/3jgKSmnZk6xTwoa.png" alt="wpsA73E.tmp"></p>
<h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>“复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p>
<p>这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，持续复制长生存期的对象则导致效率降低。</p>
<p><img src="https://i.loli.net/2020/03/22/lGu64nzhWyTDwO8.png" alt="wps9D31.tmp"></p>
<h2 id="标记-压缩算法"><a href="#标记-压缩算法" class="headerlink" title="标记-压缩算法"></a>标记-压缩算法</h2><p>复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p>
<p>根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</p>
<p><img src="https://i.loli.net/2020/03/22/p5yQUKw9TqZAV3h.png" alt="wps3952.tmp"></p>
<h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>GC分代的基本假设：绝大部分对象的生命周期都非常短暂，存活时间短。</p>
<p>“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。</p>
<h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p> 如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现</p>
<h2 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h2><p>串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用<strong>一个线程</strong>去回收。新生代、老年代使用<strong>串行</strong>回收；<strong>新生代复制算法</strong>、<strong>老年代标记-压缩</strong>；垃圾收集的过程中会Stop The World（服务暂停）</p>
<p>参数控制：**-XX:+UseSerialGC** 串行收集器</p>
<p><img src="https://i.loli.net/2020/03/22/HDrYLuqMGCSiF76.png" alt="wpsA77.tmp"></p>
<h2 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h2><p>ParNew收集器其实就是Serial收集器的多线程版本。<strong>新生代并行，老年代串行；</strong>新生代复制算法、老年代标记-压缩</p>
<p>参数控制：**-XX:+UseParNewGC** ParNew收集器</p>
<p><strong>-XX:ParallelGCThreads</strong> 限制线程数量</p>
<p><img src="https://i.loli.net/2020/03/22/fkvPBayLU8oZuHY.png" alt="wps6A83.tmp"></p>
<h2 id="Parallel收集器"><a href="#Parallel收集器" class="headerlink" title="Parallel收集器"></a>Parallel收集器</h2><p>Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的<strong>吞吐量</strong>。可以通过参数来打开<strong>自适应调节策略，</strong>虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量；也可以通过参数控制GC的时间不大于多少毫秒或者比例；新生代复制算法、老年代标记-压缩</p>
<p>参数控制：**-XX:+UseParallelGC** 使用Parallel收集器+ 老年代串行</p>
<p><strong>Paralle**</strong>l** <strong>Old</strong> <strong>收集器</strong></p>
<p>Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法。这个收集器是在JDK 1.6中才开始提供</p>
<p>参数控制： <strong>-XX:+UseParallelOldGC</strong> 使用Parallel收集器+ 老年代并行</p>
<h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。</p>
<p>从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括： </p>
<ul>
<li><p>初始标记（CMS initial mark）</p>
</li>
<li><p>并发标记（CMS concurrent mark）</p>
</li>
<li><p>重新标记（CMS remark）</p>
</li>
<li><p>并发清除（CMS concurrent sweep）</p>
</li>
</ul>
<p>其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</p>
<p>由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行。<strong>老年代收集器</strong>（新生代使用ParNew）</p>
<p>优点:<strong>并发收集</strong>、<strong>低停顿</strong> </p>
<p>缺点：<strong>产生大量空间碎片、并发阶段会降低吞吐量</strong></p>
<p>参数控制：</p>
<ul>
<li><p><code>-XX:+UseConcMarkSweepGC</code>：使用CMS收集器</p>
</li>
<li><p><code>-XX:+ UseCMSCompactAtFullCollection</code>：Full GC后，进行一次碎片整理；整理过程是独占的，会引起停顿时间变长</p>
</li>
<li><p><code>-XX:+CMSFullGCsBeforeCompaction</code>：设置进行几次Full GC后，进行一次碎片整理</p>
</li>
<li><p><code>-XX:ParallelCMSThreads</code>：设定CMS的线程数量（一般情况约等于可用CPU数量）</p>
</li>
</ul>
<p><img src="https://i.loli.net/2020/03/22/phWjSYlc2xzB38s.png" alt="wpsCA6E.tmp"></p>
<h2 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h2><p>G1是目前技术发展的最前沿成果之一，HotSpot开发团队赋予它的使命是未来可以替换掉JDK1.5中发布的CMS收集器。与CMS收集器相比G1收集器有以下特点：</p>
<ol>
<li><p><strong>空间整合</strong>，G1收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。</p>
</li>
<li><p><strong>可预测停顿</strong>，这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</p>
</li>
</ol>
<p>上面提到的垃圾收集器，收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（可以不连续）Region的集合。</p>
<p><img src="https://i.loli.net/2020/03/22/vOjk3RxCoAWTdX9.jpg" alt="wps3B4C.tmp"></p>
<p>G1的新生代收集跟ParNew类似，当新生代占用达到一定比例的时候，开始出发收集。和CMS类似，G1收集器收集老年代对象会有短暂停顿。</p>
<p><strong>收集步骤</strong>：</p>
<ol>
<li><p><strong>标记阶段</strong>，首先初始标记(Initial-Mark),这个阶段是停顿的(Stop the World Event)，并且会触发一次普通Mintor GC。对应GC log:GC pause (young) (inital-mark)</p>
</li>
<li><p><strong>Root Region Scanning</strong>，程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在young GC之前完成。</p>
</li>
<li><p><strong>Concurrent Marking</strong>，在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。</p>
</li>
</ol>
<p><img src="https://i.loli.net/2020/03/22/qlAZUEJ9BMWiged.png" alt="wps93E7.tmp"></p>
<ol start="4">
<li><p><strong>Remark</strong>, 再标记，会有短暂停顿(STW)。再标记阶段是用来收集 并发标记阶段 产生新的垃圾(并发阶段和应用程序一同运行)；G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。</p>
</li>
<li><p><strong>Copy/Clean up</strong>，多线程清除失活对象，会有STW。G1将回收区域的存活对象拷贝到新区域，清除Remember Sets，并发清空回收区域并把它返回到空闲区域链表中。</p>
</li>
</ol>
<p><img src="/C:/Users/14154/AppData/Local/Temp/msohtmlclip1/01/clip_image009.png" alt="wps47EC.tmp"></p>
<ol start="6">
<li>复制/清除过程后。回收区域的活性对象已经被集中回收到深蓝色和深绿色区域。</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://crazyStrome.github.io/2020/11/04/HashMap%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="crazyStrome的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/11/04/HashMap%E7%9B%B8%E5%85%B3/" itemprop="url">HashMap相关</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-11-04T20:18:48+08:00">
                2020-11-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="HashMap相关面试问题"><a href="#HashMap相关面试问题" class="headerlink" title="HashMap相关面试问题"></a>HashMap相关面试问题</h1><h2 id="你知道HashMap的工作原理吗？你知道HashMap的get-方法的工作原理吗？"><a href="#你知道HashMap的工作原理吗？你知道HashMap的get-方法的工作原理吗？" class="headerlink" title="你知道HashMap的工作原理吗？你知道HashMap的get()方法的工作原理吗？"></a>你知道HashMap的工作原理吗？你知道HashMap的get()方法的工作原理吗？</h2><p>HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket位置来储存Entry对象。</p>
<h2 id="当两个对象的hashcode相同会发生什么？"><a href="#当两个对象的hashcode相同会发生什么？" class="headerlink" title="当两个对象的hashcode相同会发生什么？"></a>当两个对象的hashcode相同会发生什么？</h2><p>因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用LinkedList存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在LinkedList中。(当向 HashMap 中添加 key-value 对，由其 key 的 hashCode() 返回值决定该 key-value 对（就是 Entry 对象）的存储位置。当两个 Entry 对象的 key 的 hashCode() 返回值相同时，将由 key 通过 eqauls() 比较值决定是采用覆盖行为（返回 true），还是产生 Entry 链（返回 false）。)，此时若你能讲解JDK1.8红黑树引入，面试官或许会刮目相看。</p>
<h2 id="如果两个键的hashcode相同，你如何获取值对象？"><a href="#如果两个键的hashcode相同，你如何获取值对象？" class="headerlink" title="如果两个键的hashcode相同，你如何获取值对象？"></a>如果两个键的hashcode相同，你如何获取值对象？</h2><p>当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，然后获取值对象。如果有两个值对象储存在同一个bucket，将会遍历LinkedList直到找到值对象。找到bucket位置之后，会调用keys.equals()方法去找到LinkedList中正确的节点，最终找到要找的值对象。(当程序通过 key 取出对应 value 时，系统只要先计算出该 key 的 hashCode() 返回值，在根据该 hashCode 返回值找出该 key 在 table 数组中的索引，然后取出该索引处的 Entry，最后返回该 key 对应的 value 即可。)</p>
<h2 id="如果HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办？"><a href="#如果HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办？" class="headerlink" title="如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？"></a>如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</h2><p>当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。</p>
<h2 id="你了解重新调整HashMap大小存在什么问题吗？"><a href="#你了解重新调整HashMap大小存在什么问题吗？" class="headerlink" title="你了解重新调整HashMap大小存在什么问题吗？"></a>你了解重新调整HashMap大小存在什么问题吗？</h2><p>当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在LinkedList中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在LinkedList的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。这个时候，你可以质问面试官，为什么这么奇怪，要在多线程的环境下使用HashMap呢？</p>
<h2 id="你说HashMap的get迭代了一个链表，那怎么保证HashMap的时间复杂度O-1-链表的查找的时间复杂度又是多少？"><a href="#你说HashMap的get迭代了一个链表，那怎么保证HashMap的时间复杂度O-1-链表的查找的时间复杂度又是多少？" class="headerlink" title="你说HashMap的get迭代了一个链表，那怎么保证HashMap的时间复杂度O(1)?链表的查找的时间复杂度又是多少？"></a>你说HashMap的get迭代了一个链表，那怎么保证HashMap的时间复杂度O(1)?链表的查找的时间复杂度又是多少？</h2><p>分四步：</p>
<ul>
<li><p>判断key，根据key算出索引。</p>
</li>
<li><p>根据索引获得索引位置所对应的键值对链表。</p>
</li>
<li><p>遍历键值对链表，根据key找到对应的Entry键值对。</p>
</li>
<li><p>拿到value。</p>
</li>
</ul>
<p>分析：</p>
<p>以上四步要保证HashMap的时间复杂度O(1)，需要保证每一步都是O(1)，现在看起来就第三步对链表的循环的时间复杂度影响最大，链表查找的时间复杂度为O(n)，与链表长度有关。我们要保证那个链表长度为1，才可以说时间复杂度能满足O(1)。但这么说来只有那个hash算法尽量减少冲突，才能使链表长度尽可能短，理想状态为1。因此可以得出结论：HashMap的查找时间复杂度只有在最理想的情况下才会为O(1)，而要保证这个理想状态不是我们开发者控制的。</p>
<h2 id="put时，是加到链表头还是链表尾"><a href="#put时，是加到链表头还是链表尾" class="headerlink" title="put时，是加到链表头还是链表尾"></a>put时，是加到链表头还是链表尾</h2><p>jdk8之前的是链表头，JDK8是链表尾</p>
<h2 id="传统-HashMap-的缺点"><a href="#传统-HashMap-的缺点" class="headerlink" title="传统 HashMap 的缺点"></a>传统 HashMap 的缺点</h2><p>JDK 1.8 以前 HashMap 的实现是 数组+链表，即使哈希函数取得再好，也很难达到元素百分百均匀分布。</p>
<p>当 HashMap 中有大量的元素都存放到同一个桶中时，这个桶下有一条长长的链表，这个时候 HashMap 就相当于一个单链表，假如单链表有 n 个元素，遍历的时间复杂度就是 O(n)，完全失去了它的优势。</p>
<p>针对这种情况，JDK 1.8 中引入了 红黑树（查找时间复杂度为 O(logn)）来优化这个问题。</p>
<h2 id="HashMap-Hashtable-LinkedHashMap-和TreeMap"><a href="#HashMap-Hashtable-LinkedHashMap-和TreeMap" class="headerlink" title="HashMap Hashtable LinkedHashMap 和TreeMap"></a>HashMap Hashtable LinkedHashMap 和TreeMap</h2><p>Map主要用于存储健值对，根据键得到值，因此不允许键重复(重复了覆盖了),但允许值重复。</p>
<p>Hashmap 是一个最常用的Map,它根据键的HashCode值存储数据,根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。 HashMap最多只允许一条记录的键为Null;允许多条记录的值为 Null;HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。如果需要同步，可以用 Collections的synchronizedMap方法使HashMap具有同步的能力，或者使用ConcurrentHashMap。</p>
<p>Hashtable与 HashMap类似,它继承自Dictionary类，不同的是:它不允许记录的键或者值为空;它支持线程的同步，即任一时刻只有一个线程能写Hashtable,因此也导致了 Hashtable在写入时会比较慢。</p>
<p>LinkedHashMap 是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比 LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。</p>
<p>TreeMap实现SortMap接口，能够把它保存的记录根据键排序,默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。TreeMap不允许键为NULL，允许值为NULL</p>
<p>一般情况下，我们用的最多的是HashMap,在Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。如果需要输出的顺序和输入的相同,那么用LinkedHashMap 可以实现,它还可以按读取顺序来排列.</p>
<p>HashMap是一个最常用的Map，它根据键的hashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度。HashMap最多只允许一条记录的键为NULL，允许多条记录的值为NULL。</p>
<p>HashMap不支持线程同步，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致性。如果需要同步，可以用Collections的synchronizedMap方法使HashMap具有同步的能力。</p>
<p>Hashtable与HashMap类似，不同的是：它不允许记录的键或者值为空；它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtable在写入时会比较慢。</p>
<p>LinkedHashMap保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的。在遍历的时候会比HashMap慢</p>
<p>TreeMap能够把它保存的记录根据键排序，默认是按升序排序，也可以指定排序的比较器。当用Iterator遍历TreeMap时，得到的记录是排过序的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://crazyStrome.github.io/2020/11/04/HashMap%E7%9A%84hash%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="crazyStrome的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/11/04/HashMap%E7%9A%84hash%E5%8E%9F%E7%90%86/" itemprop="url">HashMap的hash原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-11-04T18:44:00+08:00">
                2020-11-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这段代码叫“<strong>扰动函数</strong>”。<br>题主贴的是Java 7的HashMap的源码，Java 8中这步已经简化了，只做一次16位右位移异或混合，而不是四次，但原理是不变的。下面以Java 8的源码为例解释，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java 8中的散列值优化函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);    <span class="comment">//key.hashCode()为哈希算法，返回初始哈希值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>大家都知道上面代码里的**key.hashCode()**函数调用的是key键值类型自带的哈希函数，返回int型散列值。</p>
<p>理论上散列值是一个int型，如果直接拿散列值作为下标访问HashMap主数组的话，考虑到2进制32位带符号的int表值范围从**-2147483648<strong>到</strong>2147483648**。前后加起来大概40亿的映射空间。只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。</p>
<p>但问题是一个40亿长度的数组，内存是放不下的。你想，HashMap扩容之前的数组初始大小才16。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来访问数组下标。源码中模运算是在这个**indexFor( )**函数里完成的。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bucketIndex = indexFor(hash, table.length);</span><br></pre></td></tr></table></figure>

<p>indexFor的代码也很简单，就是把散列值和数组长度做一个**”与”**操作，</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static int indexFor(int h, int length) &#123;</span><br><span class="line">        return h &amp; (length-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顺便说一下，这也正好解释了为什么HashMap的数组长度要取2的整次幂。因为这样（数组长度-1）正好相当于一个“<strong>低位掩码”。</strong>“与”操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问。以初始长度16为例，16-1=15。2进制表示是<strong>00000000 00000000 00001111</strong>。和某散列值做“与”操作如下，结果就是截取了最低的四位值。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">        10100101 11000100 00100101</span><br><span class="line">&amp;	00000000 00000000 00001111</span><br><span class="line">----------------------------------</span><br><span class="line">	00000000 00000000 00000101    //高位全部归零，只保留末四位</span><br></pre></td></tr></table></figure>



<p>但这时候问题就来了，这样就算我的散列值分布再松散，要是只取最后几位的话，碰撞也会很严重。更要命的是如果散列本身做得不好，分布上成等差数列的漏洞，恰好使最后几个低位呈现规律性重复，就无比蛋疼。</p>
<p>这时候“<strong>扰动函数</strong>”的价值就体现出来了，说到这里大家应该猜出来了。看下面这个图，</p>
<p><img src="https://pic3.zhimg.com/4acf898694b8fb53498542dc0c5f765a_b.png" alt="img"><img src="https://pic3.zhimg.com/80/4acf898694b8fb53498542dc0c5f765a_720w.png" alt="img"></p>
<p>右位移16位，正好是32bit的一半，自己的高半区和低半区做异或，就是为了<strong>混合原始哈希码的高位和低位，以此来加大低位的随机性</strong>。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。</p>
<p>最后我们来看一下<strong>Peter</strong> <strong>Lawley</strong>的一篇专栏文章《An introduction to optimising a hashing strategy》里的的一个实验：他随机选取了352个字符串，在他们散列值完全没有冲突的前提下，对它们做低位掩码，取数组下标。</p>
<p><img src="https://pic3.zhimg.com/e790d0e17917824d49cd0fe71d041d86_b.png" alt="img"><img src="https://pic3.zhimg.com/80/e790d0e17917824d49cd0fe71d041d86_720w.png" alt="img"></p>
<p>结果显示，当HashMap数组长度为512的时候，也就是用掩码取低9位的时候，在没有扰动函数的情况下，发生了103次碰撞，接近30%。而在使用了扰动函数之后只有92次碰撞。碰撞减少了将近10%。看来扰动函数确实还是有功效的。</p>
<p>但明显Java 8觉得扰动做一次就够了，做4次的话，多了可能边际效用也不大，所谓为了效率考虑就改成一次了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://crazyStrome.github.io/2020/11/04/container/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="crazyStrome的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/11/04/container/" itemprop="url">Container包</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-11-04T18:24:59+08:00">
                2020-11-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Golang/" itemprop="url" rel="index">
                    <span itemprop="name">Golang</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="container"><a href="#container" class="headerlink" title="container"></a>container</h1><p>container包下有三个子包：ring、heap、list，分别代表了环形链表、堆、链表的数据结构实现。</p>
<h2 id="ring"><a href="#ring" class="headerlink" title="ring"></a>ring</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://crazyStrome.github.io/2020/10/15/java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="crazyStrome的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/10/15/java%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98/" itemprop="url">Java并发实战内容</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-10-15T08:58:32+08:00">
                2020-10-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="2-3-1-内部锁"><a href="#2-3-1-内部锁" class="headerlink" title="2.3.1.  内部锁"></a>2.3.1.  内部锁</h3><p>每个Java对象都可以隐式地扮演一个用于同步的锁的角色；这些内置的锁成为内部锁或者监视器锁。内部锁在Java中扮演了互斥锁的角色。</p>
<h3 id="2-3-2-可重入锁"><a href="#2-3-2-可重入锁" class="headerlink" title="2.3.2.  可重入锁"></a>2.3.2.  可重入锁</h3><p>当一个线程请求其他线程已经占有的锁时，请求线程将被阻塞。然而内部锁时可重入的，因此线程在试图获得它自己占有的锁时，请求会成功。可重入意味着所请求的是基于每线程而不是基于每调用的。可重入的实现是通过为每一个锁关联一个请求计数和一个占有它的线程。当计数为0时，认为锁是未被占有的。线程请求一个未被占有的锁时，JVM将记录锁的占有者，并将请求计数置为一。如果同一线程再次请求这个锁，计数将递增；每次占用线程退出同步块，计数器值将递减。直到计数器达到0，锁被释放。</p>
<h3 id="3-1-4-Volatile变量"><a href="#3-1-4-Volatile变量" class="headerlink" title="3.1.4.  Volatile变量"></a>3.1.4.  Volatile变量</h3><p>Volatile确保对一个变量的更新以可预见的方式告知其他的线程。访问Volatile变量不会加锁，也就不会引起线程的阻塞，这使得Volatile相对于sychronized而言，是轻量级的同步。</p>
<p>Volatile通常用作标识完成、中断、状态的标记使用。</p>
<p>加锁可以保证可见性与原子性，volatile只能保证可见性。</p>
<h2 id="3-2-发布和逸出"><a href="#3-2-发布和逸出" class="headerlink" title="3.2.  发布和逸出"></a>3.2.  发布和逸出</h2><p>发布一个对象的意思是它能够被当前范围之外的代码所使用。比如将一个引用存储到其他代码可以访问的地方，在一个非私有的方法中返回这个引用，也可以把它传递到其他类的方法中。</p>
<p>一个对象在尚未准备好时就将它发布，这种情况称作逸出。</p>
<h3 id="3-3-3-ThreadLocal"><a href="#3-3-3-ThreadLocal" class="headerlink" title="3.3.3.  ThreadLocal"></a>3.3.3.  ThreadLocal</h3><p>ThreadLocal提供了get和set访问器，为每个使用它的线程维护一份单独的拷贝。所以get总是返回由当前执行线程通过set设置的最新值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadLocal&lt;String&gt; local = <span class="keyword">new</span> ThreadLocal&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> String <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;this is threadlocal initialization&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;hi&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;11111&quot;</span>);</span><br><span class="line">        System.out.println(local.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程首次调用ThreadLocal.get方法时，会请求initialValue提供一个初始值。</p>
<h2 id="3-4-不可变性"><a href="#3-4-不可变性" class="headerlink" title="3.4.  不可变性"></a>3.4.  不可变性</h2><p>不可变对象天生是安全的。</p>
<p>只有满足如下状态，一个对象才是不可变的：</p>
<ul>
<li>它的状态不能在创建后再被修改</li>
<li>所有域都是final类型</li>
<li>它被正确创建（创建期间没有发生this引用的逸出）</li>
</ul>
<h3 id="3-4-1-Final域"><a href="#3-4-1-Final域" class="headerlink" title="3.4.1.  Final域"></a>3.4.1.  Final域</h3><p>final关键字对不可变对象的创建提供了支持。final域是不能修改的，尽管如果final域指向的对象是可变的，这个对象仍然可以被修改。</p>
<h3 id="3-5-4-高效不可变对象"><a href="#3-5-4-高效不可变对象" class="headerlink" title="3.5.4.  高效不可变对象"></a>3.5.4.  高效不可变对象</h3><p>一个对象在技术上不是不可变的，但是它的状态不会在发布后被修改，这样的对象成为高效不可变对象。</p>
<h3 id="3-5-5-可变对象"><a href="#3-5-5-可变对象" class="headerlink" title="3.5.5.  可变对象"></a>3.5.5.  可变对象</h3><p>发布对象的必要条件依赖于对象的可变性：</p>
<ul>
<li>不可变对象可以通过任意机制发布</li>
<li>高效不可变对象必须要安全发布</li>
<li>可变对象必须要安全发布，同时必须要线程安全或者是被锁保护</li>
</ul>
<h3 id="3-5-6-安全地共享对象"><a href="#3-5-6-安全地共享对象" class="headerlink" title="3.5.6.  安全地共享对象"></a>3.5.6.  安全地共享对象</h3><p>在并发程序中，使用和共享对象的一些最有效的策略如下：</p>
<p>线程限制：一个线程限制的对象，通过限制在线程里，而被线程独占，只能被占有它的线程修改。</p>
<p>共享只读：一个共享的只读对象，在没有额外同步的情况下，可以被多个线程并发地访问，但是任何线程都不能修改它。共享只读对象包括不可变对象和高效不可变对象。</p>
<p>共享线程安全：一个线程安全的对象在内部进行同步，所以其他线程无需额外同步，就可以通过公共接口随意地访问他。</p>
<p>被守护的：一个被守护的对象只能通过特定的锁来访问。被守护的对象包括那些被线程安全对象封装的对象，和已知被特定的锁保护起来的已发布对象。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">crazyStrome</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
