<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"crazystrome.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="啥都写">
<meta property="og:type" content="website">
<meta property="og:title" content="crazyStrome的博客">
<meta property="og:url" content="http://crazystrome.github.io/page/3/index.html">
<meta property="og:site_name" content="crazyStrome的博客">
<meta property="og:description" content="啥都写">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="crazyStrome">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://crazystrome.github.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>crazyStrome的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">crazyStrome的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/crazyStrome" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://crazystrome.github.io/2020/10/14/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="crazyStrome">
      <meta itemprop="description" content="啥都写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="crazyStrome的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/14/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-14 18:23:20" itemprop="dateCreated datePublished" datetime="2020-10-14T18:23:20+08:00">2020-10-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-25 16:05:46" itemprop="dateModified" datetime="2020-03-25T16:05:46+08:00">2020-03-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- TOC -->

<ul>
<li><a href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95">排序算法</a><ul>
<li><a href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">冒泡排序</a></li>
<li><a href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">选择排序</a></li>
<li><a href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">希尔排序</a></li>
<li><a href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序</a></li>
<li><a href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">归并排序</a></li>
<li><a href="#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F">计数排序</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><hr>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ul>
<li>冒泡排序是通过比较两个相邻元素的大小实现排序，如果前一个元素大于后一个元素，就交换这两个元素。这样就会让每一趟冒泡都能找到最大一个元素并放到最后。</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSort</span><span class="params">(nums []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span>-i; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> nums[j] &gt; nums[j+<span class="number">1</span>] &#123;</span><br><span class="line">				nums[j], nums[j+<span class="number">1</span>] = nums[j+<span class="number">1</span>], nums[j]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>稳定性：它是指对同样的数据进行排序，会不会改变它的相对位置。比如 [ 1, 3, 2, 4, 2 ] 经过排序后，两个相同的元素 2 位置会不会被交换。冒泡排序是比较相邻两个元素的大小，显然不会破坏稳定性。</p>
</li>
<li><p>空间复杂度：由于整个排序过程是在原数据上进行操作，故为 O(1);</p>
</li>
<li><p>时间复杂度：由于嵌套了 2 层循环，故为 O(n*n);</p>
<hr>
</li>
</ul>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><ul>
<li>选择排序是每次循环选择最大值，在该次循环结束时将最大值同数组最后的数进行交换</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectSort</span><span class="params">(nums []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">var</span> idx <span class="keyword">int</span></span><br><span class="line">		<span class="keyword">var</span> m = nums[<span class="number">0</span>]</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">1</span>; j &lt; <span class="built_in">len</span>(nums)-i; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> nums[j] &gt; m &#123;</span><br><span class="line">				m = nums[j]</span><br><span class="line">				idx = j</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		nums[<span class="built_in">len</span>(nums)-i<span class="number">-1</span>], nums[idx] = nums[idx], nums[<span class="built_in">len</span>(nums)-i<span class="number">-1</span>]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>稳定性：它是从后往前遍历已排序好的序列，相同元素不会改变位置，故为稳定排序；</p>
</li>
<li><p>空间复杂度：它是在原序列进行排序，故为 O ( 1 );</p>
</li>
<li><p>时间复杂度：排序的过程中，首先要遍历所有的元素，然后在已排序序列中找到合适的位置并插入。共需要 2 层循环，故为 O ( n * n );</p>
<hr>
</li>
</ul>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><ul>
<li>它的核心思想是把一个序列分组，对分组后的内容进行插入排序，这里的分组只是逻辑上的分组，不会重新开辟存储空间。它其实是插入排序的优化版，插入排序对基本有序的序列性能好，希尔排序利用这一特性把原序列分组，对每个分组进行排序，逐步完成排序。</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shellSort</span><span class="params">(nums []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// l = 9</span></span><br><span class="line">	l := <span class="built_in">len</span>(nums)</span><br><span class="line">	<span class="keyword">for</span> gap := l / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap = gap / <span class="number">2</span> &#123;</span><br><span class="line">		<span class="comment">// i = 4; i &lt; 9; i ++</span></span><br><span class="line">		<span class="keyword">for</span> i := gap; i &lt; l; i++ &#123;</span><br><span class="line">			<span class="comment">// j=0,1,2,3,4</span></span><br><span class="line">			<span class="comment">// [0]-[4] [1]-[5] [2]-[6] [3]-[7] [4]-[8]</span></span><br><span class="line">			<span class="keyword">for</span> j := i - gap; j &gt;= <span class="number">0</span>; j = j - gap &#123;</span><br><span class="line">				<span class="keyword">if</span> nums[j] &gt; nums[j+gap] &#123;</span><br><span class="line">					nums[j], nums[j+gap] = nums[j+gap], nums[j]</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>稳定性：它可能会把相同元素分到不同的组中，那么两个相同的元素就有可能调换相对位置，故不稳定。</p>
</li>
<li><p>空间复杂度：由于整个排序过程是在原数据上进行操作，故为 O(1);</p>
</li>
<li><p>时间复杂度：希尔排序的时间复杂度与增量序列的选取有关，例如希尔增量时间复杂度为O(n²)，而Hibbard增量的希尔排序的时间复杂度为O(log n的3/2)，希尔排序时间复杂度的下界是n*log2n</p>
<hr>
</li>
</ul>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><ul>
<li>首先选择一个点作为base，通过从左侧和从右侧遍历，把小于base的数放在左侧，把大于base的数放在右侧，中间是base；接下来以base为中心，分为两部分，每部分再进行快速排序。</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fastSort</span><span class="params">(nums []<span class="keyword">int</span>, start, end <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> end == start &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	base := nums[start]</span><br><span class="line">	left := start</span><br><span class="line">	right := end</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">		<span class="keyword">for</span> left &lt; right &amp;&amp; nums[right] &gt; base &#123;</span><br><span class="line">			right--</span><br><span class="line">		&#125;</span><br><span class="line">		nums[left] = nums[right]</span><br><span class="line">		<span class="keyword">for</span> left &lt; right &amp;&amp; nums[left] &lt;= base &#123;</span><br><span class="line">			left++</span><br><span class="line">		&#125;</span><br><span class="line">		nums[right] = nums[left]</span><br><span class="line">	&#125;</span><br><span class="line">	nums[left] = base</span><br><span class="line">	fastSort(nums, start, left<span class="number">-1</span>)</span><br><span class="line">	fastSort(nums, left+<span class="number">1</span>, end)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>稳定性：不稳定</p>
</li>
<li><p>空间复杂度：不使用额外空间，O(1)</p>
</li>
<li><p>时间复杂度：需要使用递归，时间复杂度nlgn</p>
<hr>
</li>
</ul>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><ul>
<li>采用分治的思想，把数组分为一个一个子序列，直到子序列只有一个元素停止拆分，然后对每个子序列进行边排序边合并。</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeSort</span><span class="params">(nums []<span class="keyword">int</span>, start, end <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> end == start &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	mid := start + (end-start)/<span class="number">2</span></span><br><span class="line">	mergeSort(nums, start, mid)</span><br><span class="line">	mergeSort(nums, mid+<span class="number">1</span>, end)</span><br><span class="line">	merge(nums, start, mid, end)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(nums []<span class="keyword">int</span>, start, mid, end <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := mid + <span class="number">1</span>; i &lt;= end; i++ &#123;</span><br><span class="line">		base := nums[i]</span><br><span class="line">		j := i - <span class="number">1</span></span><br><span class="line">		<span class="keyword">for</span> j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; base &#123;</span><br><span class="line">			nums[j+<span class="number">1</span>] = nums[j]</span><br><span class="line">			j--</span><br><span class="line">		&#125;</span><br><span class="line">		nums[j+<span class="number">1</span>] = base</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>稳定性：在元素拆分的时候，虽然相同元素可能被分到不同的组中，但是合并的时候相同元素相对位置不会发生变化，故稳定。</p>
</li>
<li><p>空间复杂度：需要用到一个数组保存排序结果，也就是合并的时候，需要开辟空间来存储排序结果，故为 O ( n );</p>
</li>
<li><p>时间复杂度：最好最坏都为 O(nlogn);</p>
<hr>
</li>
</ul>
<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><ul>
<li>使用和需排序数组的最大最小值相关的下标数组进行计数，最后根据计数得出排序后的数组。</li>
<li>比如nums[8,1,4,6,2,3,5,4]，那么下标数组为atr[1,1,1,2,1,1,0,1]</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countSort</span><span class="params">(nums []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	big := nums[<span class="number">0</span>]</span><br><span class="line">	small := nums[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">		big = max(nums[i], big)</span><br><span class="line">		small = min(nums[i], small)</span><br><span class="line">	&#125;</span><br><span class="line">	atr := <span class="built_in">make</span>([]<span class="keyword">int</span>, big-small+<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> _, n := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		atr[n-small]++</span><br><span class="line">	&#125;</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> j, n := <span class="keyword">range</span> atr &#123;</span><br><span class="line">		<span class="keyword">if</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> k := <span class="number">0</span>; k &lt; n; k++ &#123;</span><br><span class="line">				nums[i] = j + small</span><br><span class="line">				i++</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b - max(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>稳定性：在元素往 countArr 中记录时按顺序遍历，从 countArr 中取出元素也是按顺序取出，相同元素相对位置不会发生变化，故稳定。</p>
</li>
<li><p>空间复杂度：需要额外申请空间，复杂度为“桶”的个数，故为 O ( k )， k 为“桶”的个数，也就是 countArr 的长度;</p>
</li>
<li><p>时间复杂度：最好最坏都为 O(n+k)， k 为“桶”的个数，也就是 countArr 的长度;</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://crazystrome.github.io/2020/10/14/%E9%9D%A2%E7%BB%8F-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="crazyStrome">
      <meta itemprop="description" content="啥都写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="crazyStrome的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/14/%E9%9D%A2%E7%BB%8F-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-14 18:23:20" itemprop="dateCreated datePublished" datetime="2020-10-14T18:23:20+08:00">2020-10-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-12 09:35:31" itemprop="dateModified" datetime="2020-07-12T09:35:31+08:00">2020-07-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- TOC -->

<ul>
<li><a href="#1-selectpoll%E5%92%8Cepoll">1. Select、Poll和Epoll</a><ul>
<li><a href="#11-select%E6%9C%BA%E5%88%B6">1.1. Select机制</a></li>
<li><a href="#12-api">1.2. API</a><ul>
<li><a href="#121-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6">1.2.1. 运行机制</a></li>
<li><a href="#122-select%E7%9A%84%E7%BC%BA%E9%99%B7">1.2.2. Select的缺陷</a></li>
</ul>
</li>
<li><a href="#13-poll%E6%9C%BA%E5%88%B6">1.3. Poll机制</a><ul>
<li><a href="#131-api%E7%AE%80%E4%BB%8B">1.3.1. API简介</a></li>
<li><a href="#132-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6">1.3.2. 运行机制</a></li>
<li><a href="#133-poll%E7%9A%84%E7%BC%BA%E9%99%B7">1.3.3. Poll的缺陷</a></li>
</ul>
</li>
<li><a href="#14-epoll%E6%9C%BA%E5%88%B6">1.4. Epoll机制</a><ul>
<li><a href="#141-api%E7%AE%80%E4%BB%8B">1.4.1. API简介</a></li>
<li><a href="#142-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6">1.4.2. 运行机制</a></li>
<li><a href="#143-%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F">1.4.3. 工作模式</a></li>
<li><a href="#144-epoll%E7%9A%84%E4%BC%98%E7%82%B9">1.4.4. Epoll的优点</a></li>
</ul>
</li>
<li><a href="#15-%E5%9B%9Bselectpollepoll%E6%9C%BA%E5%88%B6%E7%9A%84%E5%AF%B9%E6%AF%94">1.5. 四、Select、Poll、Epoll机制的对比</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h1 id="1-Select、Poll和Epoll"><a href="#1-Select、Poll和Epoll" class="headerlink" title="1. Select、Poll和Epoll"></a>1. Select、Poll和Epoll</h1><p>select、poll和epoll都是IO多路复用的机制。一个进程可以监控多个文件描述符，一旦某一个描述符就绪（读就绪或写就绪），能够通知程序进行相应的读写操作。</p>
<p>select、poll和epoll都是同步IO，因为他们都是需要在读写就绪后自己进行读写，读写的过程是阻塞的。而异步IO的实现是系统会把负责读写的数据从内核空间拷贝到用户空间，无需线程自己进行阻塞的读写。</p>
<h2 id="1-1-Select机制"><a href="#1-1-Select机制" class="headerlink" title="1.1. Select机制"></a>1.1. Select机制</h2><h2 id="1-2-API"><a href="#1-2-API" class="headerlink" title="1.2. API"></a>1.2. API</h2><p>Linux系统中，对select方法的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* fd_set for select and pselect.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span> </span><br><span class="line">    <span class="comment">/* XPG4.2 requires this member name.  Otherwise avoid the name</span></span><br><span class="line"><span class="comment">       from the global namespace.  */</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> __USE_XOPEN</span></span><br><span class="line">        __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];</span><br><span class="line">    <span class="meta"># <span class="meta-keyword">define</span> __FDS_BITS(set) ((set)-&gt;fds_bits)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        __fd_mask __fds_bits[__FD_SETSIZE / __NFDBITS];</span><br><span class="line">    <span class="meta"># <span class="meta-keyword">define</span> __FDS_BITS(set) ((set)-&gt;__fds_bits)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125; fd_set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check the first NFDS descriptors each in READFDS (if not NULL) for read</span></span><br><span class="line"><span class="comment">   readiness, in WRITEFDS (if not NULL) for write readiness, and in EXCEPTFDS</span></span><br><span class="line"><span class="comment">   (if not NULL) for exceptional conditions.  If TIMEOUT is not NULL, time out</span></span><br><span class="line"><span class="comment">   after waiting the interval specified therein.  Returns the number of ready</span></span><br><span class="line"><span class="comment">   descriptors, or -1 for errors.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This function is a cancellation point and therefore not marked with</span></span><br><span class="line"><span class="comment">   __THROW.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">select</span> <span class="params">(<span class="keyword">int</span> __nfds, fd_set *__restrict __readfds,</span></span></span><br><span class="line"><span class="function"><span class="params">                   fd_set *__restrict __writefds,</span></span></span><br><span class="line"><span class="function"><span class="params">                   fd_set *__restrict __exceptfds,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct timeval *__restrict __timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>int __nfds</strong>是<code>fd_set</code>中最大的描述符+1，当调用select时，内核态会判断fd_set中描述符是否就绪，__nfds告诉内核最多判断到哪一个描述符。 </p>
<p><strong>__readfds、__writefds、__exceptfds</strong>都是结构体<code>fd_set</code>，fd_set可以看作是一个描述符的集合。 select函数中存在三个fd_set集合，分别代表三种事件，<code>readfds</code>表示读描述符集合，<code>writefds</code>表示写描述符集合，<code>exceptfds</code>表示异常描述符集合。当对应的fd_set = NULL时，表示不监听该类描述符。 </p>
<p><strong>timeval  __timeout</strong>用来指定select的工作方式，即当文件描述符尚未就绪时，select是永远等下去，还是等待一定的时间，或者是直接返回</p>
<p><strong>函数返回值int</strong>表示： 就绪描述符的数量，如果为-1表示产生错误 。</p>
<h3 id="1-2-1-运行机制"><a href="#1-2-1-运行机制" class="headerlink" title="1.2.1. 运行机制"></a>1.2.1. 运行机制</h3><p>Select会将全量<code>fd_set</code>从用户空间拷贝到内核空间，并注册回调函数， 在内核态空间来判断每个请求是否准备好数据 。select在没有查询到有文件描述符就绪的情况下，将一直阻塞（I/O多路服用中提过：select是一个阻塞函数）。如果有一个或者多个描述符就绪，那么select将就绪的文件描述符置位，然后select返回。返回后，由程序遍历查看哪个请求有数据。 </p>
<h3 id="1-2-2-Select的缺陷"><a href="#1-2-2-Select的缺陷" class="headerlink" title="1.2.2. Select的缺陷"></a>1.2.2. Select的缺陷</h3><ul>
<li>每次调用select，都需要把fd集合从用户态拷贝到内核态，fd越多开销则越大；</li>
<li>每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</li>
<li>select支持的文件描述符数量有限，默认是1024。参见<code>/usr/include/linux/posix_types.h</code>中的定义： </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __FD_SETSIZE  1024</span></span><br></pre></td></tr></table></figure>



<h2 id="1-3-Poll机制"><a href="#1-3-Poll机制" class="headerlink" title="1.3. Poll机制"></a>1.3. Poll机制</h2><h3 id="1-3-1-API简介"><a href="#1-3-1-API简介" class="headerlink" title="1.3.1. API简介"></a>1.3.1. API简介</h3><p>linux系统中<code>/usr/include/sys/poll.h</code>文件中对<code>poll</code>方法的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Data structure describing a polling request.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd;                     <span class="comment">/* File descriptor to poll.  */</span></span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> events;           <span class="comment">/* Types of events poller cares about.  */</span></span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> revents;          <span class="comment">/* Types of events that actually occurred.  */</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Poll the file descriptors described by the NFDS structures starting at</span></span><br><span class="line"><span class="comment">   FDS.  If TIMEOUT is nonzero and not -1, allow TIMEOUT milliseconds for</span></span><br><span class="line"><span class="comment">   an event to occur; if TIMEOUT is -1, block until an event occurs.</span></span><br><span class="line"><span class="comment">   Returns the number of file descriptors with events, zero if timed out,</span></span><br><span class="line"><span class="comment">   or -1 for errors.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This function is a cancellation point and therefore not marked with</span></span><br><span class="line"><span class="comment">   __THROW.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">poll</span> <span class="params">(struct pollfd *__fds, <span class="keyword">nfds_t</span> __nfds, <span class="keyword">int</span> __timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>__fds</strong>参数时Poll机制中定义的结构体<code>pollfd</code>，用来指定一个需要监听的描述符。结构体中fd为需要监听的文件描述符，events为需要监听的事件类型，而revents为经过poll调用之后返回的事件类型，在调用poll的时候，一般会传入一个pollfd的结构体数组，数组的元素个数表示监控的描述符个数。</p>
<p><strong>__nfds</strong>和<strong>__timeout</strong>参数都和Select机制中的同名参数含义类似</p>
<h3 id="1-3-2-运行机制"><a href="#1-3-2-运行机制" class="headerlink" title="1.3.2. 运行机制"></a>1.3.2. 运行机制</h3><p>poll的实现和select非常相似，只是描述fd集合的方式不同，poll使用<code>pollfd</code>结构代替select的<code>fd_set</code>（网上讲：类似于位图）结构，其他的本质上都差不多。所以<strong>Poll机制突破了Select机制中的文件描述符数量最大为1024的限制</strong>。</p>
<h3 id="1-3-3-Poll的缺陷"><a href="#1-3-3-Poll的缺陷" class="headerlink" title="1.3.3. Poll的缺陷"></a>1.3.3. Poll的缺陷</h3><p>Poll机制相较于Select机制中，解决了文件描述符数量上限为1024的缺陷。但另外两点缺陷依然存在：</p>
<ul>
<li>每次调用poll，都需要把fd集合从用户态拷贝到内核态，fd越多开销则越大；</li>
<li>每次调用poll，都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</li>
</ul>
<h2 id="1-4-Epoll机制"><a href="#1-4-Epoll机制" class="headerlink" title="1.4. Epoll机制"></a>1.4. Epoll机制</h2><p>Epoll在Linux2.6内核正式提出，是基于事件驱动的I/O方式。相对于select来说，epoll没有描述符个数限制；使用一个文件描述符管理多个描述符，将用户关心的文件描述符的事件存放到内核的一个事件表中，通过内存映射，使其在用户空间也可直接访问，省去了拷贝带来的资源消耗。</p>
<h3 id="1-4-1-API简介"><a href="#1-4-1-API简介" class="headerlink" title="1.4.1. API简介"></a>1.4.1. API简介</h3><p>linux系统中<code>/usr/include/sys/epoll.h</code>文件中有如下方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Creates an epoll instance.  Returns an fd for the new instance.</span></span><br><span class="line"><span class="comment">   The &quot;size&quot; parameter is a hint specifying the number of file</span></span><br><span class="line"><span class="comment">   descriptors to be associated with the new instance.  The fd</span></span><br><span class="line"><span class="comment">   returned by epoll_create() should be closed with close().  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">epoll_create</span> <span class="params">(<span class="keyword">int</span> __size)</span> __THROW</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Manipulate an epoll instance &quot;epfd&quot;. Returns 0 in case of success,</span></span><br><span class="line"><span class="comment">   -1 in case of error ( the &quot;errno&quot; variable will contain the</span></span><br><span class="line"><span class="comment">   specific error code ) The &quot;op&quot; parameter is one of the EPOLL_CTL_*</span></span><br><span class="line"><span class="comment">   constants defined above. The &quot;fd&quot; parameter is the target of the</span></span><br><span class="line"><span class="comment">   operation. The &quot;event&quot; parameter describes which events the caller</span></span><br><span class="line"><span class="comment">   is interested in and any associated user data.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">epoll_ctl</span> <span class="params">(<span class="keyword">int</span> __epfd, <span class="keyword">int</span> __op, <span class="keyword">int</span> __fd,</span></span></span><br><span class="line"><span class="function"><span class="params">                      struct epoll_event *__event)</span> __THROW</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wait for events on an epoll instance &quot;epfd&quot;. Returns the number of</span></span><br><span class="line"><span class="comment">   triggered events returned in &quot;events&quot; buffer. Or -1 in case of</span></span><br><span class="line"><span class="comment">   error with the &quot;errno&quot; variable set to the specific error code. The</span></span><br><span class="line"><span class="comment">   &quot;events&quot; parameter is a buffer that will contain triggered</span></span><br><span class="line"><span class="comment">   events. The &quot;maxevents&quot; is the maximum number of events to be</span></span><br><span class="line"><span class="comment">   returned ( usually size of &quot;events&quot; ). The &quot;timeout&quot; parameter</span></span><br><span class="line"><span class="comment">   specifies the maximum wait time in milliseconds (-1 == infinite).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This function is a cancellation point and therefore not marked with</span></span><br><span class="line"><span class="comment">   __THROW.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">epoll_wait</span> <span class="params">(<span class="keyword">int</span> __epfd, struct epoll_event *__events,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span> __maxevents, <span class="keyword">int</span> __timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>epoll_create</strong>函数：创建一个epoll实例并返回，该实例可以用于监控__size个文件描述符 </p>
<p><strong>epoll_ctl</strong>函数：向epoll中注册事件，该函数如果调用成功返回0，否则返回-1。</p>
<ul>
<li>__epfd为epoll_create返回的epoll实例</li>
<li>__op表示要进行的操作</li>
<li>__fd为要进行监控的文件描述符</li>
<li>__event要监控的事件</li>
</ul>
<p><strong>epoll_wait</strong>函数：类似与select机制中的select函数、poll机制中的poll函数，等待内核返回监听描述符的事件产生。该函数返回已经就绪的事件的数量，如果为-1表示出错。 </p>
<ul>
<li>__epfd为epoll_create返回的epoll实例</li>
<li>__events数组为 epoll_wait要返回的已经产生的事件集合</li>
<li>__maxevents为希望返回的最大的事件数量（通常为__events的大小）</li>
<li>__timeout和select、poll机制中的同名参数含义相同</li>
</ul>
<h3 id="1-4-2-运行机制"><a href="#1-4-2-运行机制" class="headerlink" title="1.4.2. 运行机制"></a>1.4.2. 运行机制</h3><p>epoll操作过程需要上述三个函数，也正是通过三个函数完成Select机制中一个函数完成的事情，解决了Select机制的三大缺陷。epoll的工作机制更为复杂，我们就解释一下，它是如何解决Select机制的三大缺陷的。</p>
<ol>
<li>对于第一个缺点，epoll的解决方案是：它的<strong>fd是共享在用户态和内核态之间</strong>的，所以可以不必进行从用户态到内核态的一个拷贝，大大节约系统资源。至于如何做到用户态和内核态，大家可以查一下“<strong>mmap</strong>”，它是一种内存映射的方法。</li>
<li>对于第二个缺点，epoll的解决方案不像select或poll一样每次都把当前线程轮流加入fd对应的设备等待队列中，而只在epoll_ctl时把当前线程挂一遍（这一遍必不可少），并为每个fd指定一个回调函数。当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而<strong>这个回调函数会把就绪的fd加入一个就绪链表。那么当我们调用epoll_wait时，epoll_wait只需要检查链表中是否有存在就绪的fd即可，效率非常可观</strong>。 </li>
<li>对于第三个缺点，fd数量的限制，也只有Select存在，Poll和Epoll都不存在。由于Epoll机制中只关心就绪的fd，它相较于Poll需要关心所有fd，在连接较多的场景下，效率更高。在1GB内存的机器上大约是10万左右，一般来说这个数目和系统内存关系很大。 </li>
</ol>
<h3 id="1-4-3-工作模式"><a href="#1-4-3-工作模式" class="headerlink" title="1.4.3. 工作模式"></a>1.4.3. 工作模式</h3><p>相较于Select和Poll，Epoll内部还分为两种工作模式： <strong>LT水平触发（level trigger）</strong>和<strong>ET边缘触发（edge trigger）</strong>。</p>
<ul>
<li><strong>LT模式：</strong> 默认的工作模式，即当epoll_wait检测到某描述符事件就绪并通知应用程序时，应用程序<strong>可以不立即处理</strong>该事件；事件会被放回到就绪链表中，下次调用epoll_wait时，会再次通知此事件。</li>
<li><strong>ET模式：</strong> 当epoll_wait检测到某描述符事件就绪并通知应用程序时，应用程序<strong>必须立即处理</strong>该事件。如果不处理，下次调用epoll_wait时，不会再次响应并通知此事件。 </li>
</ul>
<p>由于上述两种工作模式的区别，LT模式同时支持block和no-block socket两种，而ET模式下仅支持no-block socket。即epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个fd的阻塞I/O操作把多个处理其他文件描述符的任务饿死。ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。</p>
<h3 id="1-4-4-Epoll的优点"><a href="#1-4-4-Epoll的优点" class="headerlink" title="1.4.4. Epoll的优点"></a>1.4.4. Epoll的优点</h3><ul>
<li>使用内存映射技术，节省了用户态和内核态间数据拷贝的资源消耗；</li>
<li>通过每个fd定义的回调函数来实现的，只有就绪的fd才会执行回调函数。I/O的效率不会随着监视fd的数量的增长而下降；</li>
<li>文件描述符数量不再受限；</li>
</ul>
<h2 id="1-5-四、Select、Poll、Epoll机制的对比"><a href="#1-5-四、Select、Poll、Epoll机制的对比" class="headerlink" title="1.5. 四、Select、Poll、Epoll机制的对比"></a>1.5. 四、Select、Poll、Epoll机制的对比</h2><p>下图主流I/O多路复用机制的benchmark： </p>
<p><img src="https://pic4.zhimg.com/v2-b89e1b4d3869eff5ed1cfe3aec2512eb_b.jpg" alt="img"></p>
<p>当并发fd较小时，Select、Poll、Epoll的响应效率想差无几，甚至Select和Poll更胜一筹。但是当并发连接（fd）较多时，Epoll的优势便真正展现出来。</p>
<p>下面一张表格总结三种模式的区别：</p>
<p><img src="https://pic3.zhimg.com/v2-b23f9ccc4a82c26cc447779aa4427a0e_b.jpg" alt="img"></p>
<p>通过上述的一些总结，希望我们对I/O多路复用的Select、Poll、Epoll机制有一个更深刻的认识。也要明白为什么epoll会成为Linux平台下实现高性能网络服务器的首选I/O多路复用机制。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://crazystrome.github.io/2020/10/14/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%95%E9%A2%98II/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="crazyStrome">
      <meta itemprop="description" content="啥都写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="crazyStrome的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/14/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%95%E9%A2%98II/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-14 18:23:20" itemprop="dateCreated datePublished" datetime="2020-10-14T18:23:20+08:00">2020-10-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-12 09:47:55" itemprop="dateModified" datetime="2020-04-12T09:47:55+08:00">2020-04-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- TOC -->

<ul>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%9840%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0">面试题40：最小的k个数</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%9841%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0">面试题41：数据流中的中位数</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%9842%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C">面试题42：连续子数组的最大和</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%98431n%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0">面试题43：1~n整数中1出现的次数</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%9844%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97">面试题44：数字序列中某一位的数字</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%9845%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0">面试题45：把数组排成最小的数</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%9846%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2">面试题46：把数字翻译成字符串</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%9847%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC">面试题47：礼物的最大价值</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%9848%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2">面试题48：最长不含重复字符的子字符串</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%9849%E4%B8%91%E6%95%B0">面试题49：丑数</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%9850%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6">面试题50：第一个只出现一次的字符</a><ul>
<li><a href="#%E9%A2%98%E7%9B%AE%E4%B8%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6">题目一：字符串中第一个只出现一次的字符</a></li>
</ul>
</li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%9851%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9">面试题51：数组中的逆序对</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%9852%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9">面试题52：两个链表的第一个公共节点</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%9853%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97">面试题53：在排序数组中查找数字</a><ul>
<li><a href="#%E9%A2%98%E7%9B%AE%E4%B8%80%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0">题目一：数字在排序数组中出现的次数</a></li>
<li><a href="#%E9%A2%98%E7%9B%AE%E4%BA%8C0n-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97">题目二：0~n-1中缺失的数字</a></li>
</ul>
</li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%9854%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E4%B8%AA%E8%8A%82%E7%82%B9">面试题54：二叉搜索树的第k大个节点</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%9855%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6">面试题55：二叉树的深度</a><ul>
<li><a href="#%E9%A2%98%E7%9B%AE%E4%B8%80%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6">题目一：二叉树的深度</a></li>
<li><a href="#%E9%A2%98%E7%9B%AE%E4%BA%8C%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91">题目二：平衡二叉树</a></li>
</ul>
</li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%9856%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0">面试题56：数组中数字出现的次数</a><ul>
<li><a href="#%E9%A2%98%E7%9B%AE%E4%B8%80%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97">题目一：数组中只出现一次的两个数字</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h1 id="面试题40：最小的k个数"><a href="#面试题40：最小的k个数" class="headerlink" title="面试题40：最小的k个数"></a>面试题40：最小的k个数</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">leetcode</a></p>
<p>描述：输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>
<p>思路：可以使用最大堆，或者用快排的思想，每次排一下，判断当前base的位置是不是k，如果是的话，就直接返回，负责调整区间</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getLeastNumbers</span><span class="params">(arr []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[:<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> k == <span class="built_in">len</span>(arr) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    &#125;</span><br><span class="line">    start := <span class="number">0</span></span><br><span class="line">    end := <span class="built_in">len</span>(arr)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">//循环终止条件</span></span><br><span class="line">        <span class="keyword">if</span> start &gt;= end &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        left := start</span><br><span class="line">        right := end</span><br><span class="line">        base := arr[left]</span><br><span class="line">        <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">            <span class="keyword">for</span> right &gt; left &amp;&amp; arr[right] &gt; base &#123;</span><br><span class="line">                right --</span><br><span class="line">            &#125;</span><br><span class="line">            arr[left] = arr[right]</span><br><span class="line">            <span class="keyword">for</span> left &lt; right &amp;&amp; arr[left] &lt;= base &#123;</span><br><span class="line">                left ++</span><br><span class="line">            &#125;</span><br><span class="line">            arr[right] = arr[left]</span><br><span class="line">        &#125;</span><br><span class="line">        arr[left] = base</span><br><span class="line">        fmt.Println(arr,left)</span><br><span class="line">        <span class="keyword">if</span> left == k<span class="number">-1</span> &#123;</span><br><span class="line">            <span class="comment">//循环终止条件</span></span><br><span class="line">            <span class="keyword">return</span> arr[:k]</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> left &lt; k<span class="number">-1</span> &#123;</span><br><span class="line">            start = left+<span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            end = left<span class="number">-1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[:k]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题41：数据流中的中位数"><a href="#面试题41：数据流中的中位数" class="headerlink" title="面试题41：数据流中的中位数"></a>面试题41：数据流中的中位数</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/">leetcode</a></p>
<p>描述：如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>
<p>思路：将流中的元素中，中位数字左边使用最大堆储存，中位数字右边使用最小堆储存。取中位数时，当总个数为偶数时，就返回最大堆的堆顶和最小堆的堆顶之和的二分之一，当总个数为奇数时，就返回最小堆的堆顶元素。插入元素时，如果当前总个数为偶数个，则先插入最大堆，然后弹出插入最小堆；度过为奇数个，则先插入最小堆，然后弹出插入最大堆。</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MedianFinder <span class="keyword">struct</span> &#123;</span><br><span class="line">    min *MinHeap</span><br><span class="line">    max *MaxHeap</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** initialize your data structure here. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">MedianFinder</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> MedianFinder&#123;</span><br><span class="line">        min:NewMinHeap(),</span><br><span class="line">        max:NewMaxHeap(),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MedianFinder)</span> <span class="title">AddNum</span><span class="params">(num <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">if</span> this.min.Size() != this.max.Size() &#123;</span><br><span class="line">        this.min.PushHeap(num)</span><br><span class="line">        this.max.PushHeap(this.min.PopHeap())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        this.max.PushHeap(num)</span><br><span class="line">        this.min.PushHeap(this.max.PopHeap())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MedianFinder)</span> <span class="title">FindMedian</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> this.min.Size() != this.max.Size() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">float64</span>(this.min.TopHeap())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">float64</span>(this.max.TopHeap())+<span class="keyword">float64</span>(this.min.TopHeap()))/<span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// MaxHeap 最大堆结构体</span></span><br><span class="line"><span class="keyword">type</span> MaxHeap <span class="keyword">struct</span> &#123;</span><br><span class="line">	data []<span class="keyword">int</span></span><br><span class="line">	size <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewMaxHeap 建立一个最大堆</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMaxHeap</span><span class="params">()</span> *<span class="title">MaxHeap</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;MaxHeap&#123;</span><br><span class="line">		data: <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">16</span>)[:<span class="number">0</span>],</span><br><span class="line">		size: <span class="number">0</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PushHeap 向最大堆压入一个数字</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mh *MaxHeap)</span> <span class="title">PushHeap</span><span class="params">(val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> mh.size == <span class="number">0</span> &#123;</span><br><span class="line">		mh.data = <span class="built_in">append</span>(mh.data, val)</span><br><span class="line">		mh.size++</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	mh.data = <span class="built_in">append</span>(mh.data, val)</span><br><span class="line">	mh.size++</span><br><span class="line">	mh.shiftUp()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PopHeap 用来弹出堆顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mh *MaxHeap)</span> <span class="title">PopHeap</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> mh.size == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	res := mh.data[<span class="number">0</span>]</span><br><span class="line">	mh.size--</span><br><span class="line">	mh.data[<span class="number">0</span>] = mh.data[mh.size]</span><br><span class="line">	mh.data = mh.data[:mh.size]</span><br><span class="line">	<span class="keyword">if</span> mh.size &lt;= <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> res</span><br><span class="line">	&#125;</span><br><span class="line">	mh.shiftDown()</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把最后一个数字依次向父节点挪动</span></span><br><span class="line"><span class="comment">// 维持最大堆的特性</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mh *MaxHeap)</span> <span class="title">shiftUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">	idx := <span class="built_in">len</span>(mh.data) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> idx &gt;= <span class="number">0</span> &#123;</span><br><span class="line">		fidx := (idx - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">		<span class="keyword">if</span> mh.data[fidx] &lt; mh.data[idx] &#123;</span><br><span class="line">			mh.data[fidx], mh.data[idx] = mh.data[idx], mh.data[fidx]</span><br><span class="line">			idx = fidx</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把第一个数字向下移动</span></span><br><span class="line"><span class="comment">// 维持最大堆</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mh *MaxHeap)</span> <span class="title">shiftDown</span><span class="params">()</span></span> &#123;</span><br><span class="line">	idx := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> idx &lt; <span class="built_in">len</span>(mh.data) &#123;</span><br><span class="line">		lidx := idx*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">		ridx := idx*<span class="number">2</span> + <span class="number">2</span></span><br><span class="line">		largeidx := idx</span><br><span class="line">		<span class="keyword">if</span> lidx &lt; mh.size &amp;&amp; mh.data[lidx] &gt; mh.data[largeidx] &#123;</span><br><span class="line">			largeidx = lidx</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ridx &lt; mh.size &amp;&amp; mh.data[ridx] &gt; mh.data[largeidx] &#123;</span><br><span class="line">			largeidx = ridx</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> largeidx == idx &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		mh.data[largeidx], mh.data[idx] = mh.data[idx], mh.data[largeidx]</span><br><span class="line">		idx = largeidx</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TopHeap 返回堆顶元素但不弹出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mh *MaxHeap)</span> <span class="title">TopHeap</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> mh.size == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> mh.data[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Size 返回堆的大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mh *MaxHeap)</span> <span class="title">Size</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> mh.size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MinHeap 最小堆结构体</span></span><br><span class="line"><span class="keyword">type</span> MinHeap <span class="keyword">struct</span> &#123;</span><br><span class="line">	data []<span class="keyword">int</span></span><br><span class="line">	size <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewMinHeap 建立一个最小堆</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMinHeap</span><span class="params">()</span> *<span class="title">MinHeap</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;MinHeap&#123;</span><br><span class="line">		data: <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">16</span>)[:<span class="number">0</span>],</span><br><span class="line">		size: <span class="number">0</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PushHeap 向最小堆压入一个数字</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mh *MinHeap)</span> <span class="title">PushHeap</span><span class="params">(val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> mh.size == <span class="number">0</span> &#123;</span><br><span class="line">		mh.data = <span class="built_in">append</span>(mh.data, val)</span><br><span class="line">		mh.size++</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	mh.data = <span class="built_in">append</span>(mh.data, val)</span><br><span class="line">	mh.size++</span><br><span class="line">	mh.shiftUp()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PopHeap 用来弹出堆顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mh *MinHeap)</span> <span class="title">PopHeap</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> mh.size == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	res := mh.data[<span class="number">0</span>]</span><br><span class="line">	mh.size--</span><br><span class="line">	mh.data[<span class="number">0</span>] = mh.data[mh.size]</span><br><span class="line">	mh.data = mh.data[:mh.size]</span><br><span class="line">	<span class="keyword">if</span> mh.size &lt;= <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> res</span><br><span class="line">	&#125;</span><br><span class="line">	mh.shiftDown()</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把最后一个数字依次向父节点挪动</span></span><br><span class="line"><span class="comment">// 维持最小堆的特性</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mh *MinHeap)</span> <span class="title">shiftUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">	idx := <span class="built_in">len</span>(mh.data) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> idx &gt;= <span class="number">0</span> &#123;</span><br><span class="line">		fidx := (idx - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">		<span class="keyword">if</span> mh.data[fidx] &gt; mh.data[idx] &#123;</span><br><span class="line">			mh.data[fidx], mh.data[idx] = mh.data[idx], mh.data[fidx]</span><br><span class="line">			idx = fidx</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把第一个数字向下移动</span></span><br><span class="line"><span class="comment">// 维持最小堆</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mh *MinHeap)</span> <span class="title">shiftDown</span><span class="params">()</span></span> &#123;</span><br><span class="line">	idx := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> idx &lt; <span class="built_in">len</span>(mh.data) &#123;</span><br><span class="line">		lidx := idx*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">		ridx := idx*<span class="number">2</span> + <span class="number">2</span></span><br><span class="line">		smallidx := idx</span><br><span class="line">		<span class="keyword">if</span> lidx &lt; mh.size &amp;&amp; mh.data[lidx] &lt; mh.data[smallidx] &#123;</span><br><span class="line">			smallidx = lidx</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ridx &lt; mh.size &amp;&amp; mh.data[ridx] &lt; mh.data[smallidx] &#123;</span><br><span class="line">			smallidx = ridx</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> smallidx == idx &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		mh.data[smallidx], mh.data[idx] = mh.data[idx], mh.data[smallidx]</span><br><span class="line">		idx = smallidx</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TopHeap 返回堆顶元素但不弹出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mh *MinHeap)</span> <span class="title">TopHeap</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> mh.size == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> mh.data[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Size 返回堆的大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mh *MinHeap)</span> <span class="title">Size</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> mh.size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * obj.AddNum(num);</span></span><br><span class="line"><span class="comment"> * param_2 := obj.FindMedian();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h1 id="面试题42：连续子数组的最大和"><a href="#面试题42：连续子数组的最大和" class="headerlink" title="面试题42：连续子数组的最大和"></a>面试题42：连续子数组的最大和</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">leetcode</a></p>
<p>描述：输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>
<p>思路：使用动态规划，实现一个dp数组和globalmax变量，其中dp[i]=max(nums[i], dp[i-1]+nums[i])，每次循环时如果dp[i]大于globalmax，则更新globalmax字段。</p>
<p>进一步优化可以把dp数组变为pre1和pre2变量，因为dp[i]只和dp[i-1]有关，即在一次循环中只需要其中的两个变量即可。</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    pre1 := nums[<span class="number">0</span>]</span><br><span class="line">    pre2 := <span class="number">0</span></span><br><span class="line">    globalmax := nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i ++ &#123;</span><br><span class="line">        pre2 = max(<span class="number">0</span>, pre1) + nums[i]</span><br><span class="line">        globalmax = max(globalmax, pre2)</span><br><span class="line">        pre1 = pre2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> globalmax</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题43：1-n整数中1出现的次数"><a href="#面试题43：1-n整数中1出现的次数" class="headerlink" title="面试题43：1~n整数中1出现的次数"></a>面试题43：1~n整数中1出现的次数</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/">leetcode</a></p>
<p>描述：输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。</p>
<p>例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countDigitOne</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    count, pow := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> n &gt;= pow &#123;</span><br><span class="line">	count += n / (pow * <span class="number">10</span>) * pow</span><br><span class="line">	<span class="keyword">if</span> incr := n%(pow*<span class="number">10</span>) - pow + <span class="number">1</span>; incr &gt; pow &#123;</span><br><span class="line">	    count += pow</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> incr &gt; <span class="number">0</span> &#123;</span><br><span class="line">	    count += incr</span><br><span class="line">	&#125;</span><br><span class="line">	pow *= <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：cmatrix</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/solution/zhao-gui-lu-tong-su-yi-dong-by-cmatrix/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="面试题44：数字序列中某一位的数字"><a href="#面试题44：数字序列中某一位的数字" class="headerlink" title="面试题44：数字序列中某一位的数字"></a>面试题44：数字序列中某一位的数字</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/">leetcode</a></p>
<p>描述：数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</p>
<p>请写一个函数，求任意第n位对应的数字。</p>
<p>思路：一位数有10个，但是从1开始的话有九个，两位数的话有90个，三位数有900个，根据个数乘位数依次循环检查n所在的区间，然后取余操作。</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findNthDigit</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">9</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    i := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        x := <span class="number">9</span> * <span class="keyword">int</span>(math.Pow(<span class="number">10</span>, <span class="keyword">float64</span>(i<span class="number">-1</span>))) * i</span><br><span class="line">        <span class="keyword">if</span> n &lt; x &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        n -= x</span><br><span class="line">        i ++</span><br><span class="line">    &#125;</span><br><span class="line">    n--</span><br><span class="line">	number := <span class="keyword">int</span>(math.Pow10(i<span class="number">-1</span>)) + n/i</span><br><span class="line">	index := n % i</span><br><span class="line">	s := strconv.Itoa(number)</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">int</span>(s[index] - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="面试题45：把数组排成最小的数"><a href="#面试题45：把数组排成最小的数" class="headerlink" title="面试题45：把数组排成最小的数"></a>面试题45：把数组排成最小的数</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">leetcode</a></p>
<p>描述：输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>
<p>思路：自定义排序规则，实现sort的接口</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minNumber</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    as := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(nums))[:<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> _, n := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        as = <span class="built_in">append</span>(as, strconv.Itoa(n))</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Sort(Arrs(as))</span><br><span class="line">    res := <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> _, a := <span class="keyword">range</span> as &#123;</span><br><span class="line">        res += a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Arrs []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(as Arrs)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(as)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(as Arrs)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    as[i], as[j] = as[j], as[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(as Arrs)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    a := as[i]+as[j]</span><br><span class="line">    b := as[j]+as[i]</span><br><span class="line">    <span class="keyword">return</span> a &lt; b</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="面试题46：把数字翻译成字符串"><a href="#面试题46：把数字翻译成字符串" class="headerlink" title="面试题46：把数字翻译成字符串"></a>面试题46：把数字翻译成字符串</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">leetcode</a></p>
<p>描述：给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
<p>思路：使用动态规划，从个位一次向上查询，dp[i]为第i位可以构成的序列的个数，当第i位和第i-1位构成的数字在26以内而且第i位大于0时，dp[i]=dp[i-1]+dp[i-2]，否则的话dp[i] = dp[i-1]，可以知道dp只需要三个变量就可以了，所以设为pre1、pre2和curtimes，而且在循环中需要记录上一位的数字，所以使用preNum记录。</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">translateNum</span><span class="params">(num <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> num / <span class="number">10</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    preNum := num%<span class="number">10</span></span><br><span class="line">    pre1 := <span class="number">1</span></span><br><span class="line">    pre2 := <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    num /= <span class="number">10</span></span><br><span class="line">    <span class="keyword">for</span> num != <span class="number">0</span> &#123;</span><br><span class="line">        curNum := num%<span class="number">10</span></span><br><span class="line">        curTimes := <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> curNum == <span class="number">1</span> || (curNum == <span class="number">2</span> &amp;&amp; preNum &lt; <span class="number">6</span>)&#123;</span><br><span class="line">            curTimes = pre1+pre2</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curTimes = pre2</span><br><span class="line">        &#125;</span><br><span class="line">        pre1 = pre2</span><br><span class="line">        pre2= curTimes</span><br><span class="line">        fmt.Println(pre2)</span><br><span class="line">        num /= <span class="number">10</span></span><br><span class="line">        preNum = curNum</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题47：礼物的最大价值"><a href="#面试题47：礼物的最大价值" class="headerlink" title="面试题47：礼物的最大价值"></a>面试题47：礼物的最大价值</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">leetcode</a></p>
<p>描述：在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p>
<p>思路：使用一个相同的二维数组，从右下角开始往左和向上走，每个位置i,j的值为grid[i][j] +max(dp[i+1][j],dp[i][j+1])，在边缘的话分别讨论。</p>
<p>例如输入[[1,3,1],[1,5,1],[4,2,1]]，dp=[[12,11,3],[9,8,2],[7,3,1]]</p>
<p>进阶的话只需要一个一维数组就可以实现。</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxValue</span><span class="params">(grid [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(grid) == <span class="number">0</span> || <span class="built_in">len</span>(grid[<span class="number">0</span>]) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    m := <span class="built_in">len</span>(grid)</span><br><span class="line">    n := <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := m<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i -- &#123;</span><br><span class="line">        dp[n<span class="number">-1</span>] = dp[n<span class="number">-1</span>] + grid[i][n<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> j := n<span class="number">-2</span>; j &gt;= <span class="number">0</span>; j -- &#123;</span><br><span class="line">            dp[j] = max(dp[j+<span class="number">1</span>], dp[j])+grid[i][j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题48：最长不含重复字符的子字符串"><a href="#面试题48：最长不含重复字符的子字符串" class="headerlink" title="面试题48：最长不含重复字符的子字符串"></a>面试题48：最长不含重复字符的子字符串</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">leetcode</a></p>
<p>描述：请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p>
<p>思路：使用滑动窗口</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">    &#125;</span><br><span class="line">    left, right := <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    res := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> right &lt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line">        idx := right<span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> idx &gt;= left &#123;</span><br><span class="line">            <span class="keyword">if</span> s[idx] == s[right] &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            idx --</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> idx &lt; left &#123;</span><br><span class="line">            left = left</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = idx+<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        res = max(res, right-left+<span class="number">1</span>)</span><br><span class="line">        right++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题49：丑数"><a href="#面试题49：丑数" class="headerlink" title="面试题49：丑数"></a>面试题49：丑数</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/chou-shu-lcof/">leetcode</a></p>
<p>描述：我们把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p>
<p>思路：把一批数字乘2、3、5，然后再，选最小的数，再乘2、3、5</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nthUglyNumber</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    res := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    res = <span class="built_in">append</span>(res,<span class="number">1</span>)</span><br><span class="line">    i2,i3,i5:= <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    index := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> index&lt;n&#123;</span><br><span class="line">        res = <span class="built_in">append</span>(res,<span class="keyword">int</span>(math.Min(<span class="keyword">float64</span>(<span class="number">2</span>*res[i2]),math.Min(<span class="keyword">float64</span>(<span class="number">3</span>*res[i3]),<span class="keyword">float64</span>(<span class="number">5</span>*res[i5])))))</span><br><span class="line">        <span class="keyword">if</span> res[index]==<span class="number">2</span>*res[i2]&#123;</span><br><span class="line">            i2++</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">if</span> res[index]==<span class="number">3</span>*res[i3]&#123;</span><br><span class="line">            i3++</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">if</span> res[index]==<span class="number">5</span>*res[i5]&#123;</span><br><span class="line">            i5++</span><br><span class="line">        &#125;</span><br><span class="line">        index++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res[index<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="面试题50：第一个只出现一次的字符"><a href="#面试题50：第一个只出现一次的字符" class="headerlink" title="面试题50：第一个只出现一次的字符"></a>面试题50：第一个只出现一次的字符</h1><h2 id="题目一：字符串中第一个只出现一次的字符"><a href="#题目一：字符串中第一个只出现一次的字符" class="headerlink" title="题目一：字符串中第一个只出现一次的字符"></a>题目一：字符串中第一个只出现一次的字符</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">leetcode</a></p>
<p>描述：在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格</p>
<p>思路：两次循环，第一次循环把字符添加到map中，第二次循环判断map中字符出现的次数，如果为1则返回</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">firstUniqChar</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">byte</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">rune</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> s &#123;</span><br><span class="line">        m[c] ++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="keyword">if</span> m[c] == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">byte</span>(c)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题51：数组中的逆序对"><a href="#面试题51：数组中的逆序对" class="headerlink" title="面试题51：数组中的逆序对"></a>面试题51：数组中的逆序对</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">leetcode</a></p>
<p>描述：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数</p>
<p>思路：使用归并排序，在merge的过程中计算逆序对。比如使用cnt字段计数，初始数组为[7,5,6,4]，那么归完之后为l=[5,7]、r=[4,6]，每个子数组从头开始递归，i=0,j=0;如果l[i]&gt;r[j]的话，那么l剩下的数字都可以和r[j]构成逆序对。</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reversePairs</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 分治的思想</span></span><br><span class="line">	cnt := <span class="number">0</span></span><br><span class="line">	<span class="keyword">var</span> merge <span class="function"><span class="keyword">func</span><span class="params">([]<span class="keyword">int</span>, []<span class="keyword">int</span>)</span> []<span class="title">int</span></span></span><br><span class="line">	<span class="keyword">var</span> mergeSort <span class="function"><span class="keyword">func</span><span class="params">([]<span class="keyword">int</span>)</span> []<span class="title">int</span></span></span><br><span class="line"></span><br><span class="line">	mergeSort = <span class="function"><span class="keyword">func</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">2</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> nums</span><br><span class="line">		&#125;</span><br><span class="line">		n := <span class="built_in">len</span>(nums)</span><br><span class="line">		mid := n &gt;&gt; <span class="number">1</span></span><br><span class="line">		left := mergeSort(nums[:mid])</span><br><span class="line">		right := mergeSort(nums[mid:])</span><br><span class="line">		<span class="keyword">return</span> merge(left, right)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	merge = <span class="function"><span class="keyword">func</span><span class="params">(ar1, ar2 []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> res = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">		sz1, sz2 := <span class="built_in">len</span>(ar1), <span class="built_in">len</span>(ar2)</span><br><span class="line">		i, j  := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> i &lt; sz1 &amp;&amp; j &lt; sz2 &#123;</span><br><span class="line">			<span class="keyword">if</span> ar1[i] &lt;= ar2[j] &#123;</span><br><span class="line">				res = <span class="built_in">append</span>(res, ar1[i])</span><br><span class="line">				i++</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				res = <span class="built_in">append</span>(res, ar2[j])</span><br><span class="line">				cnt = cnt + sz1 - i</span><br><span class="line">				j++</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> i &lt; sz1 &#123;</span><br><span class="line">			res = <span class="built_in">append</span>(res, ar1[i])</span><br><span class="line">			i++</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> j &lt; sz2 &#123;</span><br><span class="line">			res = <span class="built_in">append</span>(res, ar2[j])</span><br><span class="line">			j++</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mergeSort(nums)</span><br><span class="line">	<span class="keyword">return</span> cnt</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="面试题52：两个链表的第一个公共节点"><a href="#面试题52：两个链表的第一个公共节点" class="headerlink" title="面试题52：两个链表的第一个公共节点"></a>面试题52：两个链表的第一个公共节点</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">leetcode</a></p>
<p>描述：输入两个链表，找出他们的第一个公共节点。</p>
<p>思路：因为链表是单向的，所以在公共节点之后的结点都是相同的。可以把两个链表的长度都求出来，然后长的链表首先走几步，之后两个链表一起走，直到遍历到的结点相同，则为第一个公共节点。</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntersectionNode</span><span class="params">(headA, headB *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    la := <span class="number">0</span></span><br><span class="line">    lb := <span class="number">0</span></span><br><span class="line">    t := headA</span><br><span class="line">    <span class="keyword">for</span> t != <span class="literal">nil</span> &#123;</span><br><span class="line">        la ++</span><br><span class="line">        t = t.Next</span><br><span class="line">    &#125;</span><br><span class="line">    t = headB</span><br><span class="line">    <span class="keyword">for</span> t != <span class="literal">nil</span> &#123;</span><br><span class="line">        lb ++</span><br><span class="line">        t = t.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> la &lt; lb &#123;</span><br><span class="line">        headA, headB = headB, headA</span><br><span class="line">        la, lb = lb, la</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; la-lb; i ++ &#123;</span><br><span class="line">        headA = headA.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> headA != <span class="literal">nil</span> &amp;&amp; headB != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> headB==headA &#123;</span><br><span class="line">            <span class="keyword">return</span> headA</span><br><span class="line">        &#125;</span><br><span class="line">        headA = headA.Next</span><br><span class="line">        headB = headB.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题53：在排序数组中查找数字"><a href="#面试题53：在排序数组中查找数字" class="headerlink" title="面试题53：在排序数组中查找数字"></a>面试题53：在排序数组中查找数字</h1><h2 id="题目一：数字在排序数组中出现的次数"><a href="#题目一：数字在排序数组中出现的次数" class="headerlink" title="题目一：数字在排序数组中出现的次数"></a>题目一：数字在排序数组中出现的次数</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">leetcode</a></p>
<p>描述：统计一个数字在排序数组中出现的次数。</p>
<p>思路：使用二分查找该数字，然后向左向右扩散求出大小。</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> l, h = <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> l &lt;= h &#123;</span><br><span class="line">        mid := l + (h-l)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">            i := mid</span><br><span class="line">            <span class="keyword">for</span> i &lt; <span class="built_in">len</span>(nums) &amp;&amp; nums[i] == target &#123;</span><br><span class="line">                i ++</span><br><span class="line">                count ++</span><br><span class="line">            &#125;</span><br><span class="line">            i = mid<span class="number">-1</span></span><br><span class="line">            <span class="keyword">for</span> i &gt;= <span class="number">0</span> &amp;&amp; nums[i] == target &#123;</span><br><span class="line">                count ++</span><br><span class="line">                i --</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> count</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">            l = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            h = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="题目二：0-n-1中缺失的数字"><a href="#题目二：0-n-1中缺失的数字" class="headerlink" title="题目二：0~n-1中缺失的数字"></a>题目二：0~n-1中缺失的数字</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/">leetcode</a></p>
<p>描述：一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>
<p>思路：因为数组使递增的，那么正常情况下，idx对应的数字和idx是相等的，如果不想等的话，就把nums[idx]和nums[nums[idx]]进行交换，如果nums[idx]超过了len(nums)的话，交换会导致越界，那么直接返回该idx</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">missingNumber</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    idx := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> idx &lt; <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[idx] == idx &#123;</span><br><span class="line">            idx ++</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[idx] &gt;= <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">            <span class="keyword">return</span> idx</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums[nums[idx]], nums[idx] = nums[idx], nums[nums[idx]]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题54：二叉搜索树的第k大个节点"><a href="#面试题54：二叉搜索树的第k大个节点" class="headerlink" title="面试题54：二叉搜索树的第k大个节点"></a>面试题54：二叉搜索树的第k大个节点</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">leetcode</a></p>
<p>描述：给定一个二叉搜索树，请找出第k大的结点</p>
<p>思路：使用循环遍历二叉树，先遍历右节点，在父结点，然后左节点，这样最开始的是最大的，遍历到一个结点时k–，直到k==1时返回当前节点的val</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 中序遍历,不过先遍历右子树</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">kthLargest</span><span class="params">(root *TreeNode, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    head := root</span><br><span class="line">    s := NewStack()</span><br><span class="line">    <span class="keyword">for</span> head != <span class="literal">nil</span> || !s.Empty()&#123;</span><br><span class="line">        <span class="keyword">for</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line">            s.Push(head)</span><br><span class="line">            head = head.Right</span><br><span class="line">        &#125;</span><br><span class="line">        head = s.Pop().(*TreeNode)</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> head.Val</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.Left</span><br><span class="line">        k --</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> stack <span class="keyword">struct</span> &#123;</span><br><span class="line">	root *node</span><br><span class="line">	size <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">	val  <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	next *node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStack</span><span class="params">()</span> *<span class="title">stack</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;stack&#123;</span><br><span class="line">		root: <span class="built_in">new</span>(node),</span><br><span class="line">		size: <span class="number">0</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">Push</span><span class="params">(value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	tmp := <span class="built_in">new</span>(node)</span><br><span class="line">	tmp.val = value</span><br><span class="line">	tmp.next = s.root</span><br><span class="line">	s.root = tmp</span><br><span class="line">	s.size++</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">if</span> s.root != <span class="literal">nil</span> &#123;</span><br><span class="line">		v := s.root.val</span><br><span class="line">		s.root = s.root.next</span><br><span class="line">		s.size--</span><br><span class="line">		<span class="keyword">return</span> v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">Top</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">if</span> s.root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s.root.val</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">Size</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s.size</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">Empty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s.size == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.3.7 为stack添加一个peek() 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">Peek</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">return</span> s.Top()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题55：二叉树的深度"><a href="#面试题55：二叉树的深度" class="headerlink" title="面试题55：二叉树的深度"></a>面试题55：二叉树的深度</h1><h2 id="题目一：二叉树的深度"><a href="#题目一：二叉树的深度" class="headerlink" title="题目一：二叉树的深度"></a>题目一：二叉树的深度</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/">leetcode</a></p>
<p>描述：输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p>
<p>思路：递归，当到叶结点时返回1，否则返回最大的子节点深度加一。</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    l := maxDepth(root.Left)</span><br><span class="line">    r := maxDepth(root.Right)</span><br><span class="line">    <span class="keyword">return</span> max(l, r)+<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目二：平衡二叉树"><a href="#题目二：平衡二叉树" class="headerlink" title="题目二：平衡二叉树"></a>题目二：平衡二叉树</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/">leetcode</a></p>
<p>描述：输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p>
<p>思路：使用一个辅助函数，从叶结点向上走，返回值表示该结点是否为平衡的以及该结点的深度。</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isBalanced</span><span class="params">(root *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    ok, _ := helper(root)</span><br><span class="line">    <span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(root *TreeNode)</span> <span class="params">(<span class="keyword">bool</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>, <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>, <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    ok, l := helper(root.Left)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> ok,l</span><br><span class="line">    &#125;</span><br><span class="line">    ok, r := helper(root.Right)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> ok,r</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> abs(l-r) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>,max(l,r)+<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>, max(l,r)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">abs</span><span class="params">(a <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题56：数组中数字出现的次数"><a href="#面试题56：数组中数字出现的次数" class="headerlink" title="面试题56：数组中数字出现的次数"></a>面试题56：数组中数字出现的次数</h1><h2 id="题目一：数组中只出现一次的两个数字"><a href="#题目一：数组中只出现一次的两个数字" class="headerlink" title="题目一：数组中只出现一次的两个数字"></a>题目一：数组中只出现一次的两个数字</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">leetcode</a></p>
<p>描述：一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p>
<p>思路：直接所有数字异或，相同的数字异或为0，一个数字和o异或还是它本身，最后剩下的就是这两个数字的异或，其结果肯定不为0，那么就在二进制位中找到第一个为1的位的位置，通过判断数组中数字的该位是否为1，可以把数组分为两部分，每个部分都有一个单独的只出现一次的数字，这样分别找出。</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">singleNumbers</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, n := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        res ^= n</span><br><span class="line">    &#125;</span><br><span class="line">    testNum := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">32</span>; i ++ &#123;</span><br><span class="line">        <span class="keyword">if</span> testNum &amp; res != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        testNum = testNum &lt;&lt; <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    num1 := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    num2 := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, n := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> n &amp; testNum == <span class="number">0</span> &#123;</span><br><span class="line">            num1 = <span class="built_in">append</span>(num1, n)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            num2 = <span class="built_in">append</span>(num2, n)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> []<span class="keyword">int</span>&#123;findNum(num1), findNum(num2)&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findNum</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, n := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        res ^= n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目二：数组中唯一只出现一次的数字"><a href="#题目二：数组中唯一只出现一次的数字" class="headerlink" title="题目二：数组中唯一只出现一次的数字"></a>题目二：数组中唯一只出现一次的数字</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">leetcode</a></p>
<p>描述：在一个数组 <code>nums</code> 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p>
<p>思路：把每个数字的每一位都加起来，如果有数字出现三次，那么每一位上都能被三整除。</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">singleNumber</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bits := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">32</span>)</span><br><span class="line">    <span class="keyword">for</span> _, n := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        mask := <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">32</span>; i ++ &#123;</span><br><span class="line">            bits[i] += mask&amp;n</span><br><span class="line">            mask &lt;&lt;= <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(bits)<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i -- &#123;</span><br><span class="line">        <span class="keyword">if</span> bits[i] % <span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">            res = <span class="number">2</span>*res</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res = <span class="number">2</span>*res+<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题57：和为s的数字"><a href="#面试题57：和为s的数字" class="headerlink" title="面试题57：和为s的数字"></a>面试题57：和为s的数字</h1><h2 id="题目一：和为s的两个数字"><a href="#题目一：和为s的两个数字" class="headerlink" title="题目一：和为s的两个数字"></a>题目一：和为s的两个数字</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/">leetcode</a></p>
<p>描述：输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p>
<p>思路：双指针查找</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    &#125;</span><br><span class="line">    left := <span class="number">0</span></span><br><span class="line">    right := <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        t := nums[left]+nums[right]</span><br><span class="line">        <span class="keyword">if</span> t == target &#123;</span><br><span class="line">            <span class="keyword">return</span> []<span class="keyword">int</span>&#123;nums[left], nums[right]&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> t &gt; target &#123;</span><br><span class="line">            right --</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> []<span class="keyword">int</span>&#123;nums[left], nums[right]&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目二：和为s的连续正数序列"><a href="#题目二：和为s的连续正数序列" class="headerlink" title="题目二：和为s的连续正数序列"></a>题目二：和为s的连续正数序列</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/">leetcode</a></p>
<p>描述：输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p>
<p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p>
<p>思路：滑动窗口</p>
<p>small设置为1，large设置为2，如果当前窗口和小于target，则增大large，如果相等，则增大large，如果大于target则增大target</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findContinuousSequence</span><span class="params">(target <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> target &lt;= <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    small := <span class="number">1</span></span><br><span class="line">    large := <span class="number">2</span></span><br><span class="line">    sum := small + large</span><br><span class="line">    res := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> small &lt;= (<span class="number">1</span>+target)/<span class="number">2</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> sum == target &#123;</span><br><span class="line">            t := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> i := small; i &lt;= large; i ++ &#123;</span><br><span class="line">                t = <span class="built_in">append</span>(t, i)</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">append</span>(res, t)</span><br><span class="line">            large ++</span><br><span class="line">            sum += large</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> sum &lt; target &#123;</span><br><span class="line">            large ++</span><br><span class="line">            sum += large</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sum -= small</span><br><span class="line">            small ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题58：翻转字符串"><a href="#面试题58：翻转字符串" class="headerlink" title="面试题58：翻转字符串"></a>面试题58：翻转字符串</h1><h2 id="题目一：翻转单词顺序"><a href="#题目一：翻转单词顺序" class="headerlink" title="题目一：翻转单词顺序"></a>题目一：翻转单词顺序</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/">leetcode</a></p>
<p>描述：输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p>
<p>思路：第一步翻转所有的字符，第二步翻转每个单词</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseWords</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    &#125;</span><br><span class="line">    s = strings.Trim(s, <span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    &#125;</span><br><span class="line">    bs := []<span class="keyword">byte</span>(s)</span><br><span class="line">    reverse(bs)</span><br><span class="line">    start := <span class="number">0</span></span><br><span class="line">    end := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> end &lt; <span class="built_in">len</span>(bs) &#123;</span><br><span class="line">        <span class="keyword">if</span> end == <span class="built_in">len</span>(bs)<span class="number">-1</span> &#123;</span><br><span class="line">            reverse(bs[start:end+<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> bs[end] == <span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">            reverse(bs[start:end])</span><br><span class="line">            fmt.Println(<span class="keyword">string</span>(bs[start:end]))</span><br><span class="line">            i := end</span><br><span class="line">            <span class="keyword">for</span> i &lt; <span class="built_in">len</span>(bs)&#123;</span><br><span class="line">                <span class="keyword">if</span> bs[i] != <span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">                i ++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> i &gt; end+<span class="number">1</span> &#123;</span><br><span class="line">                bs = <span class="built_in">append</span>(bs[:end+<span class="number">1</span>], bs[i:]...)</span><br><span class="line">            &#125;</span><br><span class="line">            start = end+<span class="number">1</span></span><br><span class="line">            end = start</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            end ++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fmt.Println(string(bs))</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// aa := []byte(&quot;doog&quot;)</span></span><br><span class="line">    <span class="comment">// reverse(aa)</span></span><br><span class="line">    <span class="comment">// fmt.Println(string(aa))</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(bs)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(bs []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    j := <span class="built_in">len</span>(bs)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i &lt; j &#123;</span><br><span class="line">        bs[i], bs[j] = bs[j], bs[i]</span><br><span class="line">        i ++</span><br><span class="line">        j --</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目二：左旋字符串"><a href="#题目二：左旋字符串" class="headerlink" title="题目二：左旋字符串"></a>题目二：左旋字符串</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">leetcode</a></p>
<p>描述：字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p>
<p>思路：使用三次翻转操作，第一次翻转整个字符串，第二次翻转最后k个，第三次翻转前面的字符串。</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseLeftWords</span><span class="params">(s <span class="keyword">string</span>, n <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    bs := []<span class="keyword">byte</span>(s)</span><br><span class="line">    reverse(bs[:n])</span><br><span class="line">    reverse(bs[n:])</span><br><span class="line">    reverse(bs)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(bs)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(bs []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    j := <span class="built_in">len</span>(bs)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i &lt; j &#123;</span><br><span class="line">        bs[i], bs[j] = bs[j], bs[i]</span><br><span class="line">        i ++</span><br><span class="line">        j --</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题59：队列的最大值"><a href="#面试题59：队列的最大值" class="headerlink" title="面试题59：队列的最大值"></a>面试题59：队列的最大值</h1><h2 id="题目一：滑动窗口的最大值"><a href="#题目一：滑动窗口的最大值" class="headerlink" title="题目一：滑动窗口的最大值"></a>题目一：滑动窗口的最大值</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">leetcode</a></p>
<p>描述：给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p>
<p>思路：首先找出k窗口中的最大值，然后依次进行窗口滑动，每次判断是否出现更大值。如果丢失的是最大值，就遍历滑动窗口找最大值。</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSlidingWindow</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> k &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    &#125;</span><br><span class="line">    max := math.MinInt32</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i ++ &#123;</span><br><span class="line">        <span class="keyword">if</span> max &lt; nums[i] &#123;</span><br><span class="line">            max = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    start := <span class="number">0</span></span><br><span class="line">    end := k<span class="number">-1</span></span><br><span class="line">    res := []<span class="keyword">int</span>&#123;max&#125;</span><br><span class="line">    start ++</span><br><span class="line">    end ++</span><br><span class="line">    <span class="keyword">for</span> end &lt; <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">        <span class="comment">// var t int</span></span><br><span class="line">        <span class="keyword">if</span> nums[start<span class="number">-1</span>] == max &#123;</span><br><span class="line">            max = math.MinInt32</span><br><span class="line">            <span class="keyword">for</span> i := start; i &lt; end+<span class="number">1</span>; i ++ &#123;</span><br><span class="line">                <span class="keyword">if</span> max &lt; nums[i] &#123;</span><br><span class="line">                    max = nums[i]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[end] &gt; max &#123;</span><br><span class="line">            max = nums[end]</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">append</span>(res, max)</span><br><span class="line">        end ++</span><br><span class="line">        start ++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目二：队列的最大值"><a href="#题目二：队列的最大值" class="headerlink" title="题目二：队列的最大值"></a>题目二：队列的最大值</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/">leetcode</a></p>
<p>描述：请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p>
<p>若队列为空，pop_front 和 max_value 需要返回 -1</p>
<p>思路：使用一个主队列和一个辅助队列，主队列正常插入弹出。插入辅助队列时，如果当前元素大于辅助队列的第一个元素的话，就把辅助队列清空，然后把该元素压进去，否则的话就从辅助队列最后开始遍历，找到第一个比待插入元素大的元素，并把该元素插到后面，这样辅助队列维持从大到小递减。</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MaxQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">    Queue []<span class="keyword">int</span></span><br><span class="line">    Max []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">MaxQueue</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> MaxQueue&#123;</span><br><span class="line">        Queue: []<span class="keyword">int</span>&#123;&#125;,</span><br><span class="line">        Max: []<span class="keyword">int</span>&#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MaxQueue)</span> <span class="title">Max_value</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.Max) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> this.Max[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MaxQueue)</span> <span class="title">Push_back</span><span class="params">(value <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    this.Queue = <span class="built_in">append</span>(this.Queue, value)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.Max) == <span class="number">0</span> &#123;</span><br><span class="line">        this.Max = <span class="built_in">append</span>(this.Max, value)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> value &gt; this.Max[<span class="number">0</span>] &#123;</span><br><span class="line">        this.Max = this.Max[:<span class="number">0</span>]</span><br><span class="line">        this.Max = <span class="built_in">append</span>(this.Max, value)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    i := <span class="built_in">len</span>(this.Max)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> this.Max[i] &gt; value &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        i --</span><br><span class="line">    &#125;</span><br><span class="line">    this.Max = this.Max[:i+<span class="number">1</span>]</span><br><span class="line">    this.Max = <span class="built_in">append</span>(this.Max, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MaxQueue)</span> <span class="title">Pop_front</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.Queue) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    v := this.Queue[<span class="number">0</span>]</span><br><span class="line">    this.Queue = this.Queue[<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">if</span> v == this.Max[<span class="number">0</span>] &#123;</span><br><span class="line">        this.Max = this.Max[<span class="number">1</span>:]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MaxQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * param_1 := obj.Max_value();</span></span><br><span class="line"><span class="comment"> * obj.Push_back(value);</span></span><br><span class="line"><span class="comment"> * param_3 := obj.Pop_front();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h1 id="面试题60：n个骰子的点数"><a href="#面试题60：n个骰子的点数" class="headerlink" title="面试题60：n个骰子的点数"></a>面试题60：n个骰子的点数</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/">leetcode</a></p>
<p>描述：把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p>
<p>思路：使用两个数组存储骰子点数的每个总数出现的次数在一轮循环中，第一个数组中的第n个数字表示骰子和为n出现的次数。在下一轮循环中，加上一个新的骰子，此时和为你的骰子出现的次数应该等于上一轮循环中骰子点数和为n-1、n-2、n-3、n-4、n-5和n-6的次数的总和</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(n <span class="keyword">int</span>)</span> []<span class="title">float64</span></span> &#123;</span><br><span class="line">    total := math.Pow(<span class="number">6.0</span>, <span class="keyword">float64</span>(n))</span><br><span class="line"></span><br><span class="line">    nums := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">6</span>*n+<span class="number">1</span>)</span><br><span class="line">    tmp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">6</span>*n+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i ++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= i * <span class="number">6</span>; j ++ &#123;</span><br><span class="line">                nums[j] = <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            nums, tmp = tmp, nums</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= i * <span class="number">6</span>; j ++ &#123;</span><br><span class="line">            l := j<span class="number">-6</span></span><br><span class="line">            <span class="keyword">if</span> l &lt; <span class="number">0</span> &#123;</span><br><span class="line">                l = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            nums[j] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> k := l; k &lt;= j<span class="number">-1</span>; k ++ &#123;</span><br><span class="line">                nums[j] += tmp[k]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(nums)</span><br><span class="line">        nums, tmp = tmp, nums</span><br><span class="line">    &#125;</span><br><span class="line">    res := []<span class="keyword">float64</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, n := <span class="keyword">range</span> tmp &#123;</span><br><span class="line">        <span class="keyword">if</span> n != <span class="number">0</span> &#123;</span><br><span class="line">            res = <span class="built_in">append</span>(res, <span class="keyword">float64</span>(n)/total)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题61：扑克牌中的顺子"><a href="#面试题61：扑克牌中的顺子" class="headerlink" title="面试题61：扑克牌中的顺子"></a>面试题61：扑克牌中的顺子</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/">leetcode</a></p>
<p>描述：从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p>
<p>思路：0可以插在两个数字之间，使得两个数字和0代表的任意数成为连续队列。那么将数组排序后，首先统计0的个数，然后在非零数字中，如果两个之间的间隔大于1的话，就需要加入相应个数的0，最后进行统计，判断剩余的0的个数是否大于等于0.</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isStraight</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">    countZero := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, n := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">            countZero ++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> || nums[i<span class="number">-1</span>] == <span class="number">0</span>&#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> n - nums[i<span class="number">-1</span>] &gt;= <span class="number">1</span> &#123;</span><br><span class="line">                countZero -= (n-nums[i<span class="number">-1</span>]<span class="number">-1</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> countZero &gt;= <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题62：圆圈中最后剩下的数字"><a href="#面试题62：圆圈中最后剩下的数字" class="headerlink" title="面试题62：圆圈中最后剩下的数字"></a>面试题62：圆圈中最后剩下的数字</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">leetcode</a></p>
<p>描述：0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p>
<p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p>
<p>思路：数学推导</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lastRemaining</span><span class="params">(n <span class="keyword">int</span>, m <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">1</span> || m &lt; <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    last := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i ++ &#123;</span><br><span class="line">        last = (last+m)%i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题63：股票的最大利润"><a href="#面试题63：股票的最大利润" class="headerlink" title="面试题63：股票的最大利润"></a>面试题63：股票的最大利润</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/">leetcode</a></p>
<p>描述：假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p>
<p>思路：使用动态规划，dp数组。第i天的最大利润=max(前i-1天最大利润，第i天价格-前i天最低价格)，<em>d**p</em>[<em>i</em>]=max(<em>d**p</em>[<em>i</em>−1],<em>p<strong>r</strong>i<strong>c</strong>e**s</em>[<em>i</em>]−min(<em>p<strong>r</strong>i<strong>c</strong>e**s</em>[0:<em>i</em>]))</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(prices) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    preMin := prices[<span class="number">0</span>]</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(prices))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(dp); i ++ &#123;</span><br><span class="line">        dp[i] = max(dp[i<span class="number">-1</span>], prices[i]-preMin)</span><br><span class="line">        <span class="keyword">if</span> preMin &gt; prices[i] &#123;</span><br><span class="line">            preMin = prices[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="built_in">len</span>(dp)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题64：求1-2-…-n"><a href="#面试题64：求1-2-…-n" class="headerlink" title="面试题64：求1+2+…+n"></a>面试题64：求1+2+…+n</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/qiu-12n-lcof/">leetcode</a></p>
<p>描述：求 <code>1+2+...+n</code> ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<p>思路：使用递归，但是不能用if，就用&amp;&amp;的短路特性。</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumNums</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> f <span class="function"><span class="keyword">func</span><span class="params">(*<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">bool</span></span></span><br><span class="line">    f = <span class="function"><span class="keyword">func</span><span class="params">(ret *<span class="keyword">int</span>, n <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        *ret += n</span><br><span class="line">        <span class="keyword">return</span> n != <span class="number">0</span> &amp;&amp; f(ret, n<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> ans <span class="keyword">int</span></span><br><span class="line">    f(&amp;ans, n)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题65：不用加减乘除做加法"><a href="#面试题65：不用加减乘除做加法" class="headerlink" title="面试题65：不用加减乘除做加法"></a>面试题65：不用加减乘除做加法</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/solution/golang-by-br0w5e-2/">leetcode</a></p>
<p>描述：写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。</p>
<p>思路：使用异或，加法器</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> b != <span class="number">0</span> &#123;</span><br><span class="line">        t := a ^ b</span><br><span class="line">        b = (a&amp;b) &lt;&lt; <span class="number">1</span></span><br><span class="line">        a = t</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题66：构建乘积数组"><a href="#面试题66：构建乘积数组" class="headerlink" title="面试题66：构建乘积数组"></a>面试题66：构建乘积数组</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/">leetcode</a></p>
<p>描述：给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B 中的元素 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。</p>
<p>思路：使用两个数组，分别代表从左侧开始的乘积和从右侧开始的乘积</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constructArr</span><span class="params">(a []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(a) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    left := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(a))</span><br><span class="line">    right := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(a))</span><br><span class="line"></span><br><span class="line">    l := <span class="number">0</span></span><br><span class="line">    r := <span class="built_in">len</span>(a)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i ++ &#123;</span><br><span class="line">        <span class="keyword">if</span> l == <span class="number">0</span> &#123;</span><br><span class="line">            left[l] = <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left[l] = left[l<span class="number">-1</span>]*a[l<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> r == <span class="built_in">len</span>(a)<span class="number">-1</span> &#123;</span><br><span class="line">            right[r] = <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right[r] = right[r+<span class="number">1</span>]*a[r+<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        l ++</span><br><span class="line">        r --</span><br><span class="line">    &#125;</span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(a))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i ++ &#123;</span><br><span class="line">        res[i] = left[i]*right[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://crazystrome.github.io/2020/10/14/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="crazyStrome">
      <meta itemprop="description" content="啥都写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="crazyStrome的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/14/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%95%E9%A2%98/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-14 18:23:20" itemprop="dateCreated datePublished" datetime="2020-10-14T18:23:20+08:00">2020-10-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-04 09:11:04" itemprop="dateModified" datetime="2020-04-04T09:11:04+08:00">2020-04-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- TOC -->

<ul>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%983%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97">面试题3：数组中重复的数字</a><ul>
<li><a href="#%E9%A2%98%E7%9B%AE%E4%B8%80%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97">题目一：找出数组中重复的数字</a></li>
<li><a href="#%E9%A2%98%E7%9B%AE%E4%BA%8C%E4%B8%8D%E4%BF%AE%E6%94%B9%E6%95%B0%E7%BB%84%E6%89%BE%E5%87%BA%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97">题目二：不修改数组找出重复的数字</a></li>
</ul>
</li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%984%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE">面试题4：二维数组中的查找</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%985%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%A9%BA%E6%A0%BC">面试题5：替换字符串中的空格</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%986%E4%BB%8E%E5%A4%B4%E5%88%B0%E5%B0%BE%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8">面试题6：从头到尾打印链表</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%987%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91">面试题7：重建二叉树</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%988%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9">面试题8：二叉树的下一个节点</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%989%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97">面试题9：用栈实现队列</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%9810%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97">面试题10：斐波那契数列</a><ul>
<li><a href="#%E9%A2%98%E7%9B%AE%E4%B8%80%E6%B1%82%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E7%9A%84%E7%AC%ACn%E9%A1%B9">题目一：求斐波那契数列的第n项</a></li>
<li><a href="#%E9%A2%98%E7%9B%AE%E4%BA%8C%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98">题目二：青蛙跳台阶问题</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%9811%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97">面试题11：旋转数组的最小数字</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%9812%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84">面试题12：矩阵中的路径</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%9813%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4">面试题13：机器人的运动范围</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%9814%E5%89%AA%E7%BB%B3%E5%AD%90">面试题14：剪绳子</a></li>
</ul>
</li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%9815%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0">面试题15：二进制中1的个数</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%9816%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9">面试题16：数值的整数次方</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%9817%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0">面试题17：打印从1到最大的n位数</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%9819%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D">面试题19：正则表达式匹配</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%9820%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2">面试题20：表示数值的字符串</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%9821%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2">面试题21：调整数组顺序使奇数位于偶数前面</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%9822%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9">面试题22：链表中倒数第k个节点</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%9823%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9">面试题23：链表中环的入口节点</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%9824%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8">面试题24：反转链表</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%9825%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8">面试题25：合并两个排序的链表</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%9826%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84">面试题26：树的子结构</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%9827%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F">面试题27：二叉树的镜像</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%9828%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91">面试题28：对称的二叉树</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%9829%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5">面试题29：顺时针打印矩阵</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%9830%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88">面试题30：包含min函数的栈</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%9831%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97">面试题31：栈的压入、弹出序列</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%9832%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91">面试题32：从上到下打印二叉树</a><ul>
<li><a href="#%E9%A2%98%E7%9B%AE%E4%B8%80%E4%B8%8D%E5%88%86%E8%A1%8C%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91">题目一：不分行从上到下打印二叉树</a></li>
<li><a href="#%E9%A2%98%E7%9B%AE%E4%BA%8C%E5%88%86%E8%A1%8C%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91">题目二：分行从上到下打印二叉树</a></li>
<li><a href="#%E9%A2%98%E7%9B%AE%E4%B8%89%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91">题目三：从上到下打印二叉树</a></li>
</ul>
</li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%9833%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97">面试题33：二叉树的后序遍历序列</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%9834%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84">面试题34：二叉树中和为某一值的路径</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%9835%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6">面试题35：复杂链表的复制</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%9836%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8">面试题36：二叉搜索树与双向链表</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%9837%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91">面试题37：序列化二叉树</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%9838%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97">面试题38：字符串的排列</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%9839%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97">面试题39：数组中出现次数超过一半的数字</a></li>
</ul>
<!-- /TOC -->
<h1 id="面试题3：数组中重复的数字"><a href="#面试题3：数组中重复的数字" class="headerlink" title="面试题3：数组中重复的数字"></a>面试题3：数组中重复的数字</h1><h2 id="题目一：找出数组中重复的数字"><a href="#题目一：找出数组中重复的数字" class="headerlink" title="题目一：找出数组中重复的数字"></a>题目一：找出数组中重复的数字</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">leetcode</a></p>
<p>描述：在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字</p>
<p>示例：</p>
<p>输入：<br>[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3 </p>
<p>思路：通过遍历把数字放到对应下标的位置，如果该下标已经有该数字，则重复</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findRepeatNumber</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    idx := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> idx &lt; <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[idx] == idx &#123;</span><br><span class="line">            idx ++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[nums[idx]] == nums[idx] &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[idx]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[nums[idx]], nums[idx] = nums[idx], nums[nums[idx]]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目二：不修改数组找出重复的数字"><a href="#题目二：不修改数组找出重复的数字" class="headerlink" title="题目二：不修改数组找出重复的数字"></a>题目二：不修改数组找出重复的数字</h2><p>描述：在一个长度为n+1的数组里的所有数字都在1~n范围内，所以数组中至少有一个数字是重复的。找出任意一个重复的数字，但不能修改输入的数组。</p>
<p>示例：</p>
<p>输入：[2,3,5,4,3,2,6,7]</p>
<p>输出：2或3</p>
<p>思路：从1-n取中心点m，判断在1~m之间的数总数是否为m，如果大于m，就说明这个区间有重复数字。</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getDuplicateNum</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	n := <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">	start := <span class="number">1</span></span><br><span class="line">	end := n</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> start+<span class="number">1</span> &lt; end &#123;</span><br><span class="line">		mid := start + (end-start)/<span class="number">2</span></span><br><span class="line">		c := count(nums, start, mid)</span><br><span class="line">		<span class="keyword">if</span> c &gt; (mid - start + <span class="number">1</span>) &#123;</span><br><span class="line">			end = mid</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			start = mid + <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> count(nums, start, start) &gt; <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> start</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> count(nums, end, end) &gt; <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> end</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">count</span><span class="params">(nums []<span class="keyword">int</span>, start, end <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	res := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> nums[i] &gt;= start &amp;&amp; nums[i] &lt;= end &#123;</span><br><span class="line">			res++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="面试题4：二维数组中的查找"><a href="#面试题4：二维数组中的查找" class="headerlink" title="面试题4：二维数组中的查找"></a>面试题4：二维数组中的查找</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">leetcode</a></p>
<p>描述：在一个二维数组中，每一行从左到右递增，每一列从上到下递增，输入一个数组和整数，判断数组中是否有该整数。</p>
<p>示例：</p>
<p>现有矩阵 matrix 如下：</p>
<p>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]<br>给定 target = 5，返回 true。</p>
<p>给定 target = 20，返回 false。</p>
<p>思路：两种思路：</p>
<ol>
<li>从右上角开始，如果大于目标值，向左走，如果小于目标值，向下走</li>
<li>从左下角开始，如果小于目标值，向右走，否则向上走</li>
</ol>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findNumberIn2DArray</span><span class="params">(matrix [][]<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="comment">//从右上角开始</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span> || <span class="built_in">len</span>(matrix[<span class="number">0</span>]) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    m := <span class="built_in">len</span>(matrix)</span><br><span class="line">    n := <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">    x := <span class="number">0</span></span><br><span class="line">    y := n<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> matrix[x][y] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> matrix[x][y] &gt; target &#123;</span><br><span class="line">            y --</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            x ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题5：替换字符串中的空格"><a href="#面试题5：替换字符串中的空格" class="headerlink" title="面试题5：替换字符串中的空格"></a>面试题5：替换字符串中的空格</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">leetcode</a></p>
<p>描述：把字符串中的每个空格替换成“%20”</p>
<p>思路：使用空间换时间或者时间换空间</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">replaceSpace</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="keyword">if</span> c == <span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">            count ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(s)+count*<span class="number">3</span>)</span><br><span class="line">    idx := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="keyword">if</span> c == <span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">            <span class="built_in">copy</span>(res[idx:idx+<span class="number">3</span>], []<span class="keyword">byte</span>&#123;<span class="string">&#x27;%&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;0&#x27;</span>&#125;)</span><br><span class="line">            idx += <span class="number">3</span></span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res[idx] = <span class="keyword">byte</span>(c)</span><br><span class="line">            idx ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(res[:idx])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题6：从头到尾打印链表"><a href="#面试题6：从头到尾打印链表" class="headerlink" title="面试题6：从头到尾打印链表"></a>面试题6：从头到尾打印链表</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof">leetcode</a></p>
<p>描述：输入一个链表的头结点，从尾到头反过来打印每个结点的值。</p>
<p>思路：栈，或者递归</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reversePrint</span><span class="params">(head *ListNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">int</span>&#123;head.Val&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">append</span>(reversePrint(head.Next), head.Val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题7：重建二叉树"><a href="#面试题7：重建二叉树" class="headerlink" title="面试题7：重建二叉树"></a>面试题7：重建二叉树</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof">leetcode</a></p>
<p>描述：给出前序遍历和中序遍历，重建二叉树</p>
<p>思路：前序遍历的第一个数是根节点，然后在中序遍历中找到对应的左右子节点，递归遍历</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(preorder []<span class="keyword">int</span>, inorder []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(preorder) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(preorder) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;TreeNode&#123;Val:preorder[<span class="number">0</span>]&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rootNum := preorder[<span class="number">0</span>]</span><br><span class="line">    leftInorderArray, rightInorderArray := getChild(inorder, rootNum)</span><br><span class="line">    root := &amp;TreeNode&#123;Val:rootNum&#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(leftInorderArray) == <span class="number">0</span> &#123;</span><br><span class="line">        root.Right = buildTree(preorder[<span class="number">1</span>:], rightInorderArray)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(rightInorderArray) == <span class="number">0</span> &#123;</span><br><span class="line">        root.Left = buildTree(preorder[<span class="number">1</span>:], leftInorderArray)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// leftNodeLastIdx := findIndex(preorder, leftInorderArray[len(leftInorderArray)-1])</span></span><br><span class="line">        root.Left = buildTree(preorder[<span class="number">1</span>:<span class="built_in">len</span>(leftInorderArray)+<span class="number">1</span>], leftInorderArray)</span><br><span class="line">        root.Right = buildTree(preorder[<span class="built_in">len</span>(leftInorderArray)+<span class="number">1</span>:], rightInorderArray)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getChild</span><span class="params">(inorder []<span class="keyword">int</span>, root <span class="keyword">int</span>)</span> <span class="params">([]<span class="keyword">int</span>, []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(inorder) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;, []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    idx := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> idx &lt; <span class="built_in">len</span>(inorder) &#123;</span><br><span class="line">        <span class="keyword">if</span> inorder[idx] == root &#123;</span><br><span class="line">            <span class="keyword">return</span> inorder[:idx], inorder[idx+<span class="number">1</span>:]</span><br><span class="line">        &#125;</span><br><span class="line">        idx ++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;, []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题8：二叉树的下一个节点"><a href="#面试题8：二叉树的下一个节点" class="headerlink" title="面试题8：二叉树的下一个节点"></a>面试题8：二叉树的下一个节点</h1><p>描述：给定一个二叉树和其中一个节点，如何找出中序遍历的下一个节点？树节点除了有指向左右子节点的指针，还有指向父节点的指针。</p>
<p>思路：右子树的最左节点，如果没有子节点分两部分：</p>
<ul>
<li>是父节点的左节点，那么下一个值就是父节点</li>
<li>是父节点的右节点，那么一直向上遍历，找到一个节点，且该结点是其父节点的左子节点，那么下一个节点就是他的父节点。</li>
</ul>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	Val   <span class="keyword">int</span></span><br><span class="line">	Pre   *TreeNode</span><br><span class="line">	Left  *TreeNode</span><br><span class="line">	Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getNextInorder</span><span class="params">(head *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> head.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">		tmp := head.Right</span><br><span class="line">		<span class="keyword">for</span> tmp != <span class="literal">nil</span> &amp;&amp; tmp.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">			tmp = tmp.Left</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> tmp</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> head == head.Pre.Left &#123;</span><br><span class="line">			<span class="keyword">return</span> head.Pre</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			tmp := head.Pre</span><br><span class="line">			<span class="keyword">for</span> tmp != tmp.Pre.Left &#123;</span><br><span class="line">				tmp = tmp.Pre</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> tmp.Pre</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题9：用栈实现队列"><a href="#面试题9：用栈实现队列" class="headerlink" title="面试题9：用栈实现队列"></a>面试题9：用栈实现队列</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof">leetcode</a></p>
<p>描述：用栈实现队列，实现函数<code>appendTail</code>和<code>deleteHead</code>，分别完成在队列尾部插入结点和在头部删除结点</p>
<p>思路：使用stack和辅助栈helper</p>
<ul>
<li>插入操作：如果stack为空，直接插入；否则把stack弹出，压到helper中，将新值压入helper，然后把helper的弹出依次压入stack中，这样保证stack栈顶就是队列头</li>
<li>删除操作：直接删除stack的栈顶元素</li>
</ul>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">    s *stack</span><br><span class="line">    h *stack</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">CQueue</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> CQueue&#123;</span><br><span class="line">        s:NewStack(),</span><br><span class="line">        h:NewStack(),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *CQueue)</span> <span class="title">AppendTail</span><span class="params">(value <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">if</span> this.s.Empty() &#123;</span><br><span class="line">        this.s.Push(value)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> !this.s.Empty() &#123;</span><br><span class="line">        this.h.Push(this.s.Pop())</span><br><span class="line">    &#125;</span><br><span class="line">    this.h.Push(value)</span><br><span class="line">    <span class="keyword">for</span> !this.h.Empty() &#123;</span><br><span class="line">        this.s.Push(this.h.Pop())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *CQueue)</span> <span class="title">DeleteHead</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> this.s.Empty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> this.s.Pop().(<span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> stack <span class="keyword">struct</span> &#123;</span><br><span class="line">	root *node</span><br><span class="line">	size <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">	val  <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	next *node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStack</span><span class="params">()</span> *<span class="title">stack</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;stack&#123;</span><br><span class="line">		root: <span class="built_in">new</span>(node),</span><br><span class="line">		size: <span class="number">0</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">Push</span><span class="params">(value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	tmp := <span class="built_in">new</span>(node)</span><br><span class="line">	tmp.val = value</span><br><span class="line">	tmp.next = s.root</span><br><span class="line">	s.root = tmp</span><br><span class="line">	s.size++</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">if</span> s.root != <span class="literal">nil</span> &#123;</span><br><span class="line">		v := s.root.val</span><br><span class="line">		s.root = s.root.next</span><br><span class="line">		s.size--</span><br><span class="line">		<span class="keyword">return</span> v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">Top</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">if</span> s.root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s.root.val</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">Size</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s.size</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">Empty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s.size == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * obj.AppendTail(value);</span></span><br><span class="line"><span class="comment"> * param_2 := obj.DeleteHead();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h1 id="面试题10：斐波那契数列"><a href="#面试题10：斐波那契数列" class="headerlink" title="面试题10：斐波那契数列"></a>面试题10：斐波那契数列</h1><h2 id="题目一：求斐波那契数列的第n项"><a href="#题目一：求斐波那契数列的第n项" class="headerlink" title="题目一：求斐波那契数列的第n项"></a>题目一：求斐波那契数列的第n项</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">leetcode</a></p>
<p>描述：如题</p>
<p>思路：递归或者循环</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    n1 := <span class="number">1</span></span><br><span class="line">    n2 := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">3</span>; i &lt;= n; i ++ &#123;</span><br><span class="line">        sum := (n1+n2)%<span class="number">1000000007</span></span><br><span class="line">        n1 = n2</span><br><span class="line">        n2 = sum</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fmt.Println(1134903170%1000000007)</span></span><br><span class="line">    <span class="keyword">return</span> n2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目二：青蛙跳台阶问题"><a href="#题目二：青蛙跳台阶问题" class="headerlink" title="题目二：青蛙跳台阶问题"></a>题目二：青蛙跳台阶问题</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof">leetcode</a></p>
<p>描述：一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个n级台阶总共有多少种方法。</p>
<p>思路：和斐波那契数列相似，只不过初始条件不同</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numWays</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    n1 := <span class="number">1</span></span><br><span class="line">    n2 := <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">3</span>; i &lt;= n; i ++ &#123;</span><br><span class="line">        sum := (n1+n2)%<span class="number">1000000007</span></span><br><span class="line">        n1 = n2</span><br><span class="line">        n2 = sum</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="面试题11：旋转数组的最小数字"><a href="#面试题11：旋转数组的最小数字" class="headerlink" title="面试题11：旋转数组的最小数字"></a>面试题11：旋转数组的最小数字</h2><p>描述：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。</p>
<p>思路：减治的二分算法，使用mid位置的数字和left或者right比较。首先考虑和left比较，[3, 4, 5, 1, 2] 与 [1, 2, 3, 4, 5] ，此时，中间位置的值都比左边大，但最小值一个在后面，一个在前面，因此这种做法不能有效地减治。考虑和right比较，[1, 2, 3, 4, 5]、[3, 4, 5, 1, 2]、[2, 3, 4, 5 ,1]，用右边位置和中间位置的元素比较，可以进一步缩小搜索的范围。</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minArray</span><span class="params">(numbers []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(numbers) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    start := <span class="number">0</span></span><br><span class="line">    end := <span class="built_in">len</span>(numbers)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> start + <span class="number">1</span> &lt; end &#123;</span><br><span class="line">        mid := start + (end-start)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> numbers[mid] == numbers[end] &#123;</span><br><span class="line">            end --</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> numbers[mid] &gt; numbers[end] &#123;</span><br><span class="line">            start = mid+<span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            end = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> numbers[start] &lt; numbers[end] &#123;</span><br><span class="line">        <span class="keyword">return</span> numbers[start]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numbers[end]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题12：矩阵中的路径"><a href="#面试题12：矩阵中的路径" class="headerlink" title="面试题12：矩阵中的路径"></a>面试题12：矩阵中的路径</h2><p>描述：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p>
<p>[[“a”,”b”,”c”,”e”],<br>[“s”,”f”,”c”,”s”],<br>[“a”,”d”,”e”,”e”]]</p>
<p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。<br>思路：使用另外一个相同大小的二维数组record记录该路径是否走过，如果该路径失败，则将路径中的记录清除。<br>使用遍历判断字符是否和word的首字母相同，如果相同的话，把该位置的record设置为true，不过在判断之前需要进行边界的判定以及是否该路径走过的判定。之后判定该字符周围的字符是否在剩余word[1:]组成的路径中，如果是的话，就说明该路径成立，否则不成立，取消该字符在record中的标记</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exist</span><span class="params">(board [][]<span class="keyword">byte</span>, word <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(board) == <span class="number">0</span> || <span class="built_in">len</span>(board[<span class="number">0</span>]) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> word == <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> word == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    m := <span class="built_in">len</span>(board)</span><br><span class="line">    n := <span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line">    record := <span class="built_in">make</span>([][]<span class="keyword">bool</span>, m)</span><br><span class="line">    <span class="comment">// record中默认false，表示该字符都没有路过</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i ++ &#123;</span><br><span class="line">        record[i] = <span class="built_in">make</span>([]<span class="keyword">bool</span>, n)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i ++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j ++ &#123;</span><br><span class="line">            <span class="keyword">if</span> helper(board, record, word, i, j, m, n) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(board [][]<span class="keyword">byte</span>, record [][]<span class="keyword">bool</span>, word <span class="keyword">string</span>, x, y <span class="keyword">int</span>, m, n <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="comment">//  如果word为&quot;&quot;，则说明前面的字符已经匹配完了</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(word) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  检查越界</span></span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt;= m || y &gt;= n &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  如果该路径走过了，就返回不可达</span></span><br><span class="line">    <span class="keyword">if</span> record[x][y] &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> board[x][y] == word[<span class="number">0</span>] &#123;</span><br><span class="line">        fmt.Println(word)</span><br><span class="line">        fmt.Println(board[x][y])</span><br><span class="line">        record[x][y] = <span class="literal">true</span></span><br><span class="line">        flag := <span class="literal">false</span></span><br><span class="line">        <span class="comment">// 检查上下左右的字符是否匹配剩余的路径</span></span><br><span class="line">        flag = flag || helper(board, record, word[<span class="number">1</span>:], x+<span class="number">1</span>, y, m, n)</span><br><span class="line">        flag = flag || helper(board, record, word[<span class="number">1</span>:], x, y+<span class="number">1</span>, m, n)</span><br><span class="line">        flag = flag || helper(board, record, word[<span class="number">1</span>:], x<span class="number">-1</span>, y, m, n)</span><br><span class="line">        flag = flag || helper(board, record, word[<span class="number">1</span>:], x, y<span class="number">-1</span>, m, n)</span><br><span class="line">        <span class="keyword">if</span> flag &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            record[x][y] = <span class="literal">false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题13：机器人的运动范围"><a href="#面试题13：机器人的运动范围" class="headerlink" title="面试题13：机器人的运动范围"></a>面试题13：机器人的运动范围</h2><p>描述：地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
<p>思路：使用record记录走过的地点，依次向下遍历</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">movingCount</span><span class="params">(m <span class="keyword">int</span>, n <span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    record := <span class="built_in">make</span>([]<span class="keyword">bool</span>, m*n)</span><br><span class="line">    <span class="keyword">return</span> helper(<span class="number">0</span>, <span class="number">0</span>, m, n, k, record)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(x, y, m, n, k <span class="keyword">int</span>, record []<span class="keyword">bool</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> calculate(x, y) &gt; k &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> record[x*n+y] &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    res := <span class="number">1</span></span><br><span class="line">    record[x*n+y] = <span class="literal">true</span></span><br><span class="line">    res += helper(x, y+<span class="number">1</span>, m, n, k, record)</span><br><span class="line">    res += helper(x, y<span class="number">-1</span>, m, n, k, record)</span><br><span class="line">    res += helper(x<span class="number">-1</span>, y, m, n, k, record)</span><br><span class="line">    res += helper(x+<span class="number">1</span>, y, m, n, k, record)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculate</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> a != <span class="number">0</span> || b != <span class="number">0</span>&#123;</span><br><span class="line">        res += a%<span class="number">10</span></span><br><span class="line">        a /= <span class="number">10</span></span><br><span class="line">        res += b%<span class="number">10</span></span><br><span class="line">        b /= <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题14：剪绳子"><a href="#面试题14：剪绳子" class="headerlink" title="面试题14：剪绳子"></a>面试题14：剪绳子</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/">leetcode</a></p>
<p>描述：给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m] 。请问 k[0]<em>k[1]</em>…*k[m] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>思路一：动态规划，当前的最大积是之前的积的最大值。</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cuttingRope</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    arr := <span class="built_in">make</span>([]<span class="keyword">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    arr[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">    arr[<span class="number">3</span>] = <span class="number">3</span></span><br><span class="line">    arr[<span class="number">4</span>] = <span class="number">4</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">5</span>; i &lt;= n; i ++ &#123;</span><br><span class="line">        max := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j := i<span class="number">-1</span>; j &gt;= i/<span class="number">2</span>; j -- &#123;</span><br><span class="line">            tmp := arr[j]*arr[i-j]</span><br><span class="line">            <span class="keyword">if</span> max &lt; tmp &#123;</span><br><span class="line">                max = tmp</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = max</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路二：贪心算法：当n&gt;=5时，尽可能多剪长度为3的绳子，如果长度为4，则剪成两根长度为2的绳子。</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cuttingRope</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    timeOf3 := n/<span class="number">3</span></span><br><span class="line">    <span class="keyword">if</span> n%<span class="number">3</span> == <span class="number">1</span> &#123;</span><br><span class="line">        timeOf3 --</span><br><span class="line">    &#125;</span><br><span class="line">    timeOf2 := (n-timeOf3*<span class="number">3</span>)/<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">int</span>(math.Pow(<span class="number">3</span>, <span class="keyword">float64</span>(timeOf3)))*<span class="keyword">int</span>(math.Pow(<span class="number">2</span>, <span class="keyword">float64</span>(timeOf2)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题15：二进制中1的个数"><a href="#面试题15：二进制中1的个数" class="headerlink" title="面试题15：二进制中1的个数"></a>面试题15：二进制中1的个数</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">leetcode</a></p>
<p>描述：请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p>
<p>思路：使用1进行与操作，一次向左移</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hammingWeight</span><span class="params">(num <span class="keyword">uint32</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">uint32</span> = <span class="number">1</span></span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">32</span>; i ++ &#123;</span><br><span class="line">        <span class="keyword">if</span> num &amp; a != <span class="number">0</span> &#123;</span><br><span class="line">            count ++</span><br><span class="line">        &#125;</span><br><span class="line">        a &lt;&lt;= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路：使用n和n-1进行与操作，例如一开始n=5，二进制是0101,那么和4与之后为4，二进制位0100，之后4和3再与就是0了，相当于做了两次与操作，然后就得到1的个数</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hammingWeight</span><span class="params">(n <span class="keyword">uint32</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> n != <span class="number">0</span> &#123;</span><br><span class="line">        count ++</span><br><span class="line">        n = n &amp;(n<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题16：数值的整数次方"><a href="#面试题16：数值的整数次方" class="headerlink" title="面试题16：数值的整数次方"></a>面试题16：数值的整数次方</h1><p>描述：实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p>
<p>思路：使用二分法，考虑次方为负数的情况</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myPow</span><span class="params">(x <span class="keyword">float64</span>, n <span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span>/pow(x, -n)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pow(x, n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(x <span class="keyword">float64</span>, n <span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    tmp := pow(x, n/<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> n%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x*tmp*tmp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp*tmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题17：打印从1到最大的n位数"><a href="#面试题17：打印从1到最大的n位数" class="headerlink" title="面试题17：打印从1到最大的n位数"></a>面试题17：打印从1到最大的n位数</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof">leetcode</a></p>
<p>描述：输入数字 <code>n</code>，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printNumbers</span><span class="params">(n <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    num := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="keyword">int</span>(math.Pow(<span class="number">10</span>,<span class="keyword">float64</span>(n))<span class="number">-1</span>))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(num); i ++ &#123;</span><br><span class="line">        num[i] = i+<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题19：正则表达式匹配"><a href="#面试题19：正则表达式匹配" class="headerlink" title="面试题19：正则表达式匹配"></a>面试题19：正则表达式匹配</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/submissions/">leetcode</a></p>
<p>描述：请实现一个函数用来匹配包含’. ‘和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但与”aa.a”和”ab*a”均不匹配。</p>
<p>思路：</p>
<p><img src="https://i.loli.net/2020/03/29/41bfzeCwuySrJnZ.png" alt="image-20200329161913939"></p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isMatch</span><span class="params">(s <span class="keyword">string</span>, p <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> helper(s, p, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(s, p <span class="keyword">string</span>, x, y <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x == <span class="built_in">len</span>(s) &amp;&amp; y == <span class="built_in">len</span>(p) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="built_in">len</span>(s) &amp;&amp; y == <span class="built_in">len</span>(p) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> y &lt; <span class="built_in">len</span>(p)<span class="number">-1</span> &amp;&amp; p[y+<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="built_in">len</span>(s) &amp;&amp; s[x] == p[y] || (p[y] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; x &lt; <span class="built_in">len</span>(s)) &#123;</span><br><span class="line">            <span class="keyword">return</span> helper(s, p, x+<span class="number">1</span>, y+<span class="number">2</span>) || helper(s, p, x, y+<span class="number">2</span>) || helper(s, p, x+<span class="number">1</span>, y)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> helper(s, p, x, y+<span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="built_in">len</span>(s) &amp;&amp; s[x] == p[y] || (p[y] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; x &lt; <span class="built_in">len</span>(s)) &#123;</span><br><span class="line">        <span class="keyword">return</span> helper(s, p, x+<span class="number">1</span>, y+<span class="number">1</span>)</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="面试题20：表示数值的字符串"><a href="#面试题20：表示数值的字符串" class="headerlink" title="面试题20：表示数值的字符串"></a>面试题20：表示数值的字符串</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/">leetcode</a></p>
<p>描述：请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”、”5e2”、”-123”、”3.1416”、”0123”及”-1E-16”都表示数值，但”12e”、”1a3.14”、”1.2.3”、”+-5”及”12e+5.4”都不是。</p>
<h1 id="面试题21：调整数组顺序使奇数位于偶数前面"><a href="#面试题21：调整数组顺序使奇数位于偶数前面" class="headerlink" title="面试题21：调整数组顺序使奇数位于偶数前面"></a>面试题21：调整数组顺序使奇数位于偶数前面</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">leetcode</a></p>
<p>描述：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p>
<p>思路：使用双指针，奇数指针从0开始，偶数指针从数组末尾开始，当奇数指针指向的数为偶数时，同偶数指针指向的数交换，偶数指针减一，进入下一个循环。如果奇数指针指向的数为奇数时，奇数指针加一。</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exchange</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> || <span class="built_in">len</span>(nums) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    &#125;</span><br><span class="line">    left := <span class="number">0</span></span><br><span class="line">    right := <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left + <span class="number">1</span>&lt; right &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[left] % <span class="number">2</span> != <span class="number">0</span> &#123;</span><br><span class="line">            left ++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums[left], nums[right] = nums[right], nums[left]</span><br><span class="line">            right --</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> nums[left] % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        nums[left], nums[right] = nums[right], nums[left]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题22：链表中倒数第k个节点"><a href="#面试题22：链表中倒数第k个节点" class="headerlink" title="面试题22：链表中倒数第k个节点"></a>面试题22：链表中倒数第k个节点</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">leetcode</a></p>
<p>描述：输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p>
<p>思路：两个指针，快指针先走k-1步，这样当快指针走到尾，慢指针就走到第k个了，在一开始要注意链表长度小于k的情况。</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getKthFromEnd</span><span class="params">(head *ListNode, k <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> f, s = head, head</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i ++ &#123;</span><br><span class="line">        <span class="keyword">if</span> f == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        &#125;</span><br><span class="line">        f = f.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> f != <span class="literal">nil</span> &#123;</span><br><span class="line">        s = s.Next</span><br><span class="line">        f = f.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题23：链表中环的入口节点"><a href="#面试题23：链表中环的入口节点" class="headerlink" title="面试题23：链表中环的入口节点"></a>面试题23：链表中环的入口节点</h1><p>描述：给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<p>说明：不允许修改给定的链表。</p>
<p>思路：首先快慢指针走，一个走两步一个走一步，当出现相遇时表明有环，记录该节点。然后使用两个指针，一个指向头结点，一个指向相遇结点，同时向后走，如果相遇，则为环的入口点。</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">detectCycle</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    intersect := getInter(head)</span><br><span class="line">    <span class="keyword">if</span> intersect == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    l1 := head</span><br><span class="line">    l2 := intersect</span><br><span class="line">    <span class="keyword">for</span> l1 != l2 &#123;</span><br><span class="line">        l1 = l1.Next</span><br><span class="line">        l2 = l2.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l1</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getInter</span><span class="params">(root *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> || root.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    slow := root</span><br><span class="line">    fase := root</span><br><span class="line">    <span class="keyword">for</span> fase != <span class="literal">nil</span> &amp;&amp; fase.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        fase = fase.Next.Next</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        <span class="keyword">if</span> slow == fase &#123;</span><br><span class="line">            <span class="keyword">return</span> slow</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题24：反转链表"><a href="#面试题24：反转链表" class="headerlink" title="面试题24：反转链表"></a>面试题24：反转链表</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">leetcode</a></p>
<p>描述：定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
<p>思路：循环或者递归</p>
<p>循环代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> pre, next *ListNode</span><br><span class="line">    <span class="keyword">for</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line">        next = head.Next</span><br><span class="line">        head.Next = pre</span><br><span class="line">        pre = head</span><br><span class="line">        head = next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反转之后，n变为尾结点</span></span><br><span class="line">    n := head.Next</span><br><span class="line">    t := reverseList(n)</span><br><span class="line">    n.Next = head</span><br><span class="line">    head.Next = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题25：合并两个排序的链表"><a href="#面试题25：合并两个排序的链表" class="headerlink" title="面试题25：合并两个排序的链表"></a>面试题25：合并两个排序的链表</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">leetcode</a></p>
<p>描述：输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
<p>思路：使用递归实现，首先判断是否为nil，如果有一个为nil的话就返回另一个；如果两个指针都不为nil的话就进行比较，找出较小者作为头结点，其next结点为递归该函数使用前者的next结点和较大节点产生的新节点。</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTwoLists</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> l2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> l2 == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> l1</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> l1.Val &lt; l2.Val &#123;</span><br><span class="line">        l1.Next = mergeTwoLists(l1.Next, l2)</span><br><span class="line">        <span class="keyword">return</span> l1 </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l2.Next = mergeTwoLists(l2.Next, l1)</span><br><span class="line">        <span class="keyword">return</span> l2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题26：树的子结构"><a href="#面试题26：树的子结构" class="headerlink" title="面试题26：树的子结构"></a>面试题26：树的子结构</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">leetcode</a></p>
<p>描述：输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p>
<p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p>
<p>思路：首先对A树的每一个节点进行遍历，如果该结点和B相等时，调用helper函数，否则的话，递归调用A的子节点和B的函数。</p>
<p>在helper函数中，如果B为nil则返回true，如果A为nil而B不为nil时，说明不存在字数，返回false；如果A和B不相同的话，返回false，相同的话，使用helper递归调用判断A、B的左右子树是否相同。</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSubStructure</span><span class="params">(A *TreeNode, B *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (A != <span class="literal">nil</span> &amp;&amp; B != <span class="literal">nil</span>) &amp;&amp; (isBofA(A, B) || isSubStructure(A.Left, B) || isSubStructure(A.Right, B))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isBofA</span><span class="params">(A *TreeNode, B *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> B == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> A == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> A.Val != B.Val &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isBofA(A.Left, B.Left) &amp;&amp; isBofA(A.Right, B.Right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="面试题27：二叉树的镜像"><a href="#面试题27：二叉树的镜像" class="headerlink" title="面试题27：二叉树的镜像"></a>面试题27：二叉树的镜像</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">leetcode</a></p>
<p>描述：请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
<p>思路：首先镜像子树，然后交换子树。使用递归完成</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mirrorTree</span><span class="params">(root *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    root.Left, root.Right = mirrorTree(root.Right), mirrorTree(root.Left)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题28：对称的二叉树"><a href="#面试题28：对称的二叉树" class="headerlink" title="面试题28：对称的二叉树"></a>面试题28：对称的二叉树</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/">leetcode</a></p>
<p>描述：请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<p>思路：使用helper函数，输入两个子树，递归调用，如果节点相同的话，递归判断树1的左子树和树2的右子树，以及树1的右子树和树2的左子树。</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSymmetric</span><span class="params">(root *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> helper(root, root)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(t1, t2 *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> t1 == <span class="literal">nil</span> &amp;&amp; t2 == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> t1 != <span class="literal">nil</span> &amp;&amp; t2 == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> t1 == <span class="literal">nil</span> &amp;&amp; t2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> t1.Val == t2.Val &#123;</span><br><span class="line">        <span class="keyword">return</span> helper(t1.Left, t2.Right) &amp;&amp; helper(t1.Right, t2.Left)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题29：顺时针打印矩阵"><a href="#面试题29：顺时针打印矩阵" class="headerlink" title="面试题29：顺时针打印矩阵"></a>面试题29：顺时针打印矩阵</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">leetcode</a></p>
<p>描述：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<p>思路：一层一层的打印。</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spiralOrder</span><span class="params">(matrix [][]<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span> || <span class="built_in">len</span>(matrix[<span class="number">0</span>]) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    m := <span class="built_in">len</span>(matrix)</span><br><span class="line">    n := <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    layers := m </span><br><span class="line">    <span class="keyword">if</span> layers &lt; n &#123;</span><br><span class="line">        layers = n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> layers % <span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">        layers = layers/<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        layers = layers/<span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="keyword">int</span>, m*n)</span><br><span class="line">    idx := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; layers; i ++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := i; j &lt; n-i; j ++ &#123;</span><br><span class="line">            <span class="keyword">if</span> idx == m*n &#123;</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            &#125;</span><br><span class="line">            res[idx] = matrix[i][j]</span><br><span class="line">            idx ++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> j := i+<span class="number">1</span>; j &lt; m-i; j ++ &#123;</span><br><span class="line">            <span class="keyword">if</span> idx == m*n &#123;</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            &#125;</span><br><span class="line">            res[idx] = matrix[j][n-i<span class="number">-1</span>]</span><br><span class="line">            idx ++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> j := n-i<span class="number">-2</span>; j &gt;= i; j -- &#123;</span><br><span class="line">            <span class="keyword">if</span> idx == m*n &#123;</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            &#125;</span><br><span class="line">            res[idx] = matrix[m-i<span class="number">-1</span>][j]</span><br><span class="line">            idx ++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> j := m-i<span class="number">-2</span>; j &gt;= i +<span class="number">1</span>; j -- &#123;</span><br><span class="line">            <span class="keyword">if</span> idx == m*n &#123;</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            &#125;</span><br><span class="line">            res[idx] = matrix[j][i]</span><br><span class="line">            idx ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题30：包含min函数的栈"><a href="#面试题30：包含min函数的栈" class="headerlink" title="面试题30：包含min函数的栈"></a>面试题30：包含min函数的栈</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/">leetcode</a></p>
<p>描述：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>
<p>思路：维持一个最小值min字段，每次压栈时如果x比min小，就把min和x都压入栈，然后更新min。出栈时，如果Pop的值和min相等的话，就把下一个pop的值附给min。</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MinStack <span class="keyword">struct</span> &#123;</span><br><span class="line">    s *stack</span><br><span class="line">    min <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** initialize your data structure here. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">MinStack</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> MinStack&#123;NewStack(), math.MaxInt32&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt;= this.min &#123;</span><br><span class="line">        this.s.Push(this.min)</span><br><span class="line">        this.min = x</span><br><span class="line">    &#125;</span><br><span class="line">    this.s.Push(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span> <span class="title">Pop</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    <span class="keyword">if</span> this.s.Pop().(<span class="keyword">int</span>) == this.min &#123;</span><br><span class="line">        this.min = this.s.Pop().(<span class="keyword">int</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span> <span class="title">Top</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.s.Top().(<span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span> <span class="title">Min</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.min</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> stack <span class="keyword">struct</span> &#123;</span><br><span class="line">	root *node</span><br><span class="line">	size <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">	val  <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	next *node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStack</span><span class="params">()</span> *<span class="title">stack</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;stack&#123;</span><br><span class="line">		root: <span class="built_in">new</span>(node),</span><br><span class="line">		size: <span class="number">0</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">Push</span><span class="params">(value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	tmp := <span class="built_in">new</span>(node)</span><br><span class="line">	tmp.val = value</span><br><span class="line">	tmp.next = s.root</span><br><span class="line">	s.root = tmp</span><br><span class="line">	s.size++</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">if</span> s.root != <span class="literal">nil</span> &#123;</span><br><span class="line">		v := s.root.val</span><br><span class="line">		s.root = s.root.next</span><br><span class="line">		s.size--</span><br><span class="line">		<span class="keyword">return</span> v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">Top</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">if</span> s.root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s.root.val</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">Size</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s.size</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">Empty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s.size == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * obj.Push(x);</span></span><br><span class="line"><span class="comment"> * obj.Pop();</span></span><br><span class="line"><span class="comment"> * param_3 := obj.Top();</span></span><br><span class="line"><span class="comment"> * param_4 := obj.Min();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h1 id="面试题31：栈的压入、弹出序列"><a href="#面试题31：栈的压入、弹出序列" class="headerlink" title="面试题31：栈的压入、弹出序列"></a>面试题31：栈的压入、弹出序列</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/">leetcode</a></p>
<p>描述：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p>
<p>思路：如果下一个弹出的数字是栈顶数字，那么直接弹出，否则的话就一次压入数字直到出现该弹出数字，如果压完了都没有相同的，则说明该序列不是弹出序列</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validateStackSequences</span><span class="params">(pushed []<span class="keyword">int</span>, popped []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(pushed) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(popped) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    s := NewStack()</span><br><span class="line">    idx := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, n := <span class="keyword">range</span> popped &#123;</span><br><span class="line">        <span class="keyword">for</span> idx &lt; <span class="built_in">len</span>(pushed) &amp;&amp; (s.Empty() || s.Top().(<span class="keyword">int</span>) != n) &#123;</span><br><span class="line">            s.Push(pushed[idx])</span><br><span class="line">            idx ++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> s.Top().(<span class="keyword">int</span>) == n &#123;</span><br><span class="line">            s.Pop()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> stack <span class="keyword">struct</span> &#123;</span><br><span class="line">	root *node</span><br><span class="line">	size <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">	val  <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	next *node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStack</span><span class="params">()</span> *<span class="title">stack</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;stack&#123;</span><br><span class="line">		root: <span class="built_in">new</span>(node),</span><br><span class="line">		size: <span class="number">0</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">Push</span><span class="params">(value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	tmp := <span class="built_in">new</span>(node)</span><br><span class="line">	tmp.val = value</span><br><span class="line">	tmp.next = s.root</span><br><span class="line">	s.root = tmp</span><br><span class="line">	s.size++</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">if</span> s.root != <span class="literal">nil</span> &#123;</span><br><span class="line">		v := s.root.val</span><br><span class="line">		s.root = s.root.next</span><br><span class="line">		s.size--</span><br><span class="line">		<span class="keyword">return</span> v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">Top</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">if</span> s.root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s.root.val</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">Size</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s.size</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">Empty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s.size == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题32：从上到下打印二叉树"><a href="#面试题32：从上到下打印二叉树" class="headerlink" title="面试题32：从上到下打印二叉树"></a>面试题32：从上到下打印二叉树</h1><h2 id="题目一：不分行从上到下打印二叉树"><a href="#题目一：不分行从上到下打印二叉树" class="headerlink" title="题目一：不分行从上到下打印二叉树"></a>题目一：不分行从上到下打印二叉树</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">leetcode</a></p>
<p>描述：从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>
<p>思路：使用队列，每一层遍历时首先取出队列中的元素，加入结果数组中，然后把该结点的右子树和左子树分别压进去，进行下一个循环。</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    queue := []*TreeNode&#123;root&#125;</span><br><span class="line">    res := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) != <span class="number">0</span> &#123;</span><br><span class="line">        t := queue[<span class="number">0</span>]</span><br><span class="line">        res = <span class="built_in">append</span>(res, t.Val)</span><br><span class="line">        queue = queue[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">if</span> t.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">            queue = <span class="built_in">append</span>(queue, t.Left)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> t.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">            queue = <span class="built_in">append</span>(queue, t.Right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目二：分行从上到下打印二叉树"><a href="#题目二：分行从上到下打印二叉树" class="headerlink" title="题目二：分行从上到下打印二叉树"></a>题目二：分行从上到下打印二叉树</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">leetcode</a></p>
<p>描述：从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>
<p>思路：使用两个队列，公有队列和临时队列，每一次循环中从公有队列取结点，添加到结果集后，把左右子节点添加到临时队列中，一个循环结束，让公有队列指向临时队列。</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    res := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    queue := []*TreeNode&#123;root&#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) != <span class="number">0</span> &#123;</span><br><span class="line">        t := []*TreeNode&#123;&#125;</span><br><span class="line">        nums := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> _, n := <span class="keyword">range</span> queue &#123;</span><br><span class="line">            nums = <span class="built_in">append</span>(nums, n.Val)</span><br><span class="line">            <span class="keyword">if</span> n.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                t = <span class="built_in">append</span>(t, n.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> n.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                t = <span class="built_in">append</span>(t, n.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">append</span>(res, nums)</span><br><span class="line">        queue = t</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目三：从上到下打印二叉树"><a href="#题目三：从上到下打印二叉树" class="headerlink" title="题目三：从上到下打印二叉树"></a>题目三：从上到下打印二叉树</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">leetcode</a></p>
<p>描述：请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p>
<p>思路：和分层打印类似，只不过使用一个flag判断是否该层的结果需要reverse以下</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    res := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    queue := []*TreeNode&#123;root&#125;</span><br><span class="line">    flag := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) != <span class="number">0</span> &#123;</span><br><span class="line">        t := []*TreeNode&#123;&#125;</span><br><span class="line">        nums := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> _, n := <span class="keyword">range</span> queue &#123;</span><br><span class="line">            nums = <span class="built_in">append</span>(nums, n.Val)</span><br><span class="line">            <span class="keyword">if</span> n.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                t = <span class="built_in">append</span>(t, n.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> n.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                t = <span class="built_in">append</span>(t, n.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> flag &#123;</span><br><span class="line">            i, j := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">            <span class="keyword">for</span> i &lt; j &#123;</span><br><span class="line">                nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">                i ++</span><br><span class="line">                j --</span><br><span class="line">            &#125;</span><br><span class="line">            flag = <span class="literal">false</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            flag = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">append</span>(res, nums)</span><br><span class="line">        queue = t</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题33：二叉树的后序遍历序列"><a href="#面试题33：二叉树的后序遍历序列" class="headerlink" title="面试题33：二叉树的后序遍历序列"></a>面试题33：二叉树的后序遍历序列</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">leetcode</a></p>
<p>描述：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。</p>
<p>思路：使用递归实现，后序遍历的最后一个数肯定是根节点，那么就在前面找到左子树和右子树，然后递归判断，如果前面的右子树种存在小于根节点的数，则该二叉树不存在，返回false</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">verifyPostorder</span><span class="params">(postorder []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> helper(postorder, <span class="number">0</span>, <span class="built_in">len</span>(postorder)<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(nums []<span class="keyword">int</span>, start, end <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> end &lt; start &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> end == start &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    rN := nums[end]</span><br><span class="line">    i := start</span><br><span class="line">    <span class="keyword">for</span> i &lt; end &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; rN &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        i ++</span><br><span class="line">    &#125;</span><br><span class="line">    j := i</span><br><span class="line">    <span class="keyword">for</span> j &lt; end &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[j] &lt; rN &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        j ++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> helper(nums, start, i<span class="number">-1</span>) &amp;&amp; helper(nums, i, end<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题34：二叉树中和为某一值的路径"><a href="#面试题34：二叉树中和为某一值的路径" class="headerlink" title="面试题34：二叉树中和为某一值的路径"></a>面试题34：二叉树中和为某一值的路径</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">leetcode</a></p>
<p>描述：输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p>
<p>思路：使用递归前序遍历，遍历子节点的时候把sum减去当前节点的值；如果某个节点是叶结点而且和sum相等，则返回，负责返回空集。</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pathSum</span><span class="params">(root *TreeNode, sum <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Val == sum &amp;&amp; root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [][]<span class="keyword">int</span>&#123;&#123;root.Val&#125;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Val != sum &amp;&amp; root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if root.Val &gt; sum &#123;</span></span><br><span class="line">    <span class="comment">//     return [][]int&#123;&#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    l := pathSum(root.Left, sum-root.Val)</span><br><span class="line">    r := pathSum(root.Right, sum-root.Val)</span><br><span class="line">    res := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, nums := <span class="keyword">range</span> l &#123;</span><br><span class="line">        res = <span class="built_in">append</span>(res, <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;root.Val&#125;, nums...))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, nums := <span class="keyword">range</span> r &#123;</span><br><span class="line">        res = <span class="built_in">append</span>(res, <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;root.Val&#125;, nums...))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题35：复杂链表的复制"><a href="#面试题35：复杂链表的复制" class="headerlink" title="面试题35：复杂链表的复制"></a>面试题35：复杂链表的复制</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">leetcode</a></p>
<p>描述：请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p>
<p>思路：根据链表的每个结点N复制一个节点N’，然后把N’挂在N后面，之后复制其任意指针的指向关系。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node next;</span></span><br><span class="line"><span class="comment">    Node random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">        this.next = null;</span></span><br><span class="line"><span class="comment">        this.random = null;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        dumplateList(head);</span><br><span class="line">        setRandom(head);</span><br><span class="line">        <span class="keyword">return</span> getNewList(head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dumplateList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        Node tmp = head;</span><br><span class="line">        <span class="keyword">while</span> (tmp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node n = <span class="keyword">new</span> Node(tmp.val);</span><br><span class="line">            n.next = tmp.next;</span><br><span class="line">            tmp.next = n;</span><br><span class="line">            tmp = n.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRandom</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        Node tmp = head;</span><br><span class="line">        <span class="keyword">while</span> (tmp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node n = tmp.next;</span><br><span class="line">            <span class="keyword">if</span> (tmp.random == <span class="keyword">null</span>) &#123;</span><br><span class="line">                n.random = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                n.random = tmp.random.next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            tmp = n.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getNewList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        Node tmp = head;</span><br><span class="line">        Node res = <span class="keyword">new</span> Node(-<span class="number">1</span>);</span><br><span class="line">        Node preserve = res;</span><br><span class="line">        <span class="keyword">while</span> (tmp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node n = tmp.next;</span><br><span class="line">            tmp.next = n.next;</span><br><span class="line">            res.next = n;</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">            res = res.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preserve.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题36：二叉搜索树与双向链表"><a href="#面试题36：二叉搜索树与双向链表" class="headerlink" title="面试题36：二叉搜索树与双向链表"></a>面试题36：二叉搜索树与双向链表</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">leetcode</a></p>
<p>描述：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p>
<p>思路：使用中序遍历，一个pre结点，一个cur结点，pre的right指向cur，cur的left指向pre。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node left;</span></span><br><span class="line"><span class="comment">    public Node right;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val,Node _left,Node _right) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// stack.Push(root);</span></span><br><span class="line">        Node cur, pre, tail, head;</span><br><span class="line">        pre = <span class="keyword">null</span>;</span><br><span class="line">        tail = <span class="keyword">null</span>;</span><br><span class="line">        head = <span class="keyword">null</span>;</span><br><span class="line">        cur = root;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() || cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = stack.pop();</span><br><span class="line">            cur = tail;</span><br><span class="line">            <span class="keyword">if</span> (pre == <span class="keyword">null</span>) &#123;</span><br><span class="line">                head = cur;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre.right = cur;</span><br><span class="line">                cur.left = pre;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        tail.right = head;</span><br><span class="line">        head.left = tail;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题37：序列化二叉树"><a href="#面试题37：序列化二叉树" class="headerlink" title="面试题37：序列化二叉树"></a>面试题37：序列化二叉树</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/">leetcode</a></p>
<p>描述：请实现两个函数，分别用来序列化和反序列化二叉树。</p>
<p>思路：使用堆在数组中储存的概念进行序列化和反序列话，假设一个结点的位置为i，那么左子树和右子树结点的位置分别为2i+1和2i+2.依次类推，如果某一个子树不存在的话，使用null代替。</p>
<p>代码：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/solution/java-kong-jian-100-xu-lie-hua-er-cha-shu-by-lemon-/">lemon-132的解答</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String results; <span class="comment">// 定义一个成员变量存储序列化结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;[]&quot;</span>;</span><br><span class="line">        &#125; <span class="comment">// root为null直接返回空字符串即可</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个队列存储每一个非null节点</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root); <span class="comment">// 将root先放进去</span></span><br><span class="line">        results = <span class="string">&quot;[&quot;</span> + root.val;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 每次从队列中取出一个节点，根据其左右子节点是否为null进行字符串拼接</span></span><br><span class="line">            TreeNode tmp = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (tmp.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(tmp.left);</span><br><span class="line">                results += <span class="string">&quot;,&quot;</span> + tmp.left.val;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                results += <span class="string">&quot;,null&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 上面处理left，下面处理right</span></span><br><span class="line">            <span class="keyword">if</span> (tmp.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(tmp.right);</span><br><span class="line">                results += <span class="string">&quot;,&quot;</span> + tmp.right.val;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                results += <span class="string">&quot;,null&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理完成之后添加上结束符</span></span><br><span class="line">        results += <span class="string">&quot;]&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data.length() == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去除收尾的中括号字符</span></span><br><span class="line">        data = data.substring(<span class="number">1</span>, data.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 利用逗号分隔符获取每一个节点的值</span></span><br><span class="line">        String[] vals = data.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="comment">// 定义队列存储每一个有效节点，为了构建其左右子节点</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.valueOf(vals[<span class="number">0</span>]));</span><br><span class="line">        queue.offer(root); <span class="comment">// 第一个元素为root节点</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>; <span class="comment">// 标记后续处理的节点值（包含null）</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode tmp = queue.poll();</span><br><span class="line">            <span class="comment">// 从队列中取出节点，然后根据是否为null，依次设置left和right</span></span><br><span class="line">            <span class="comment">// 如果不是null，则需要加入队列，后续需要处理此有效节点的左右节点</span></span><br><span class="line">            <span class="keyword">if</span> (vals[i].equals(<span class="string">&quot;null&quot;</span>)) &#123;</span><br><span class="line">                tmp.left = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp.left = <span class="keyword">new</span> TreeNode(Integer.valueOf(vals[i]));</span><br><span class="line">                queue.offer(tmp.left);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span> (vals[i].equals(<span class="string">&quot;null&quot;</span>)) &#123;</span><br><span class="line">                tmp.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp.right = <span class="keyword">new</span> TreeNode(Integer.valueOf(vals[i]));</span><br><span class="line">                queue.offer(tmp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题38：字符串的排列"><a href="#面试题38：字符串的排列" class="headerlink" title="面试题38：字符串的排列"></a>面试题38：字符串的排列</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">leetcode</a></p>
<p>描述：输入一个字符串，打印出该字符串中字符的所有排列</p>
<p>思路：深度优先，递归</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">permutation</span><span class="params">(s <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> helper([]<span class="keyword">byte</span>(s))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(bs []<span class="keyword">byte</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(bs) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(bs) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">string</span>&#123;<span class="keyword">string</span>(bs)&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> i, b := <span class="keyword">range</span> bs &#123;</span><br><span class="line">        tmp := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(bs)<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">copy</span>(tmp[:i], bs[:i])</span><br><span class="line">        <span class="built_in">copy</span>(tmp[i:], bs[i+<span class="number">1</span>:])</span><br><span class="line">        t := helper(tmp)</span><br><span class="line">        <span class="keyword">for</span> _, ts := <span class="keyword">range</span> t &#123;</span><br><span class="line">            <span class="keyword">if</span> m[ts] &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            m[ts] = <span class="literal">true</span></span><br><span class="line">            res = <span class="built_in">append</span>(res, <span class="keyword">string</span>(b)+ts)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题39：数组中出现次数超过一半的数字"><a href="#面试题39：数组中出现次数超过一半的数字" class="headerlink" title="面试题39：数组中出现次数超过一半的数字"></a>面试题39：数组中出现次数超过一半的数字</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">leetcode</a></p>
<p>描述：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>
<p>思路：排序之后取中间位置值</p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">majorityElement</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="built_in">len</span>(nums)/<span class="number">2</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://crazystrome.github.io/2020/10/14/%E9%AB%98%E6%80%A7%E8%83%BDMYSQL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="crazyStrome">
      <meta itemprop="description" content="啥都写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="crazyStrome的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/14/%E9%AB%98%E6%80%A7%E8%83%BDMYSQL/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-14 18:23:20" itemprop="dateCreated datePublished" datetime="2020-10-14T18:23:20+08:00">2020-10-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-23 09:24:33" itemprop="dateModified" datetime="2020-04-23T09:24:33+08:00">2020-04-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://crazystrome.github.io/2020/10/14/TCPIP%E5%8D%8F%E8%AE%AE%E5%8D%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="crazyStrome">
      <meta itemprop="description" content="啥都写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="crazyStrome的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/14/TCPIP%E5%8D%8F%E8%AE%AE%E5%8D%B7/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-14 18:23:20" itemprop="dateCreated datePublished" datetime="2020-10-14T18:23:20+08:00">2020-10-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-22 09:02:21" itemprop="dateModified" datetime="2020-08-22T09:02:21+08:00">2020-08-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.  概述"></a>1.  概述</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://crazystrome.github.io/2020/10/14/sync/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="crazyStrome">
      <meta itemprop="description" content="啥都写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="crazyStrome的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/14/sync/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-14 18:23:20" itemprop="dateCreated datePublished" datetime="2020-10-14T18:23:20+08:00">2020-10-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-04 09:10:21" itemprop="dateModified" datetime="2020-04-04T09:10:21+08:00">2020-04-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- TOC -->

<ul>
<li><a href="#sync%E5%8C%85%E8%A7%A3%E6%9E%90">sync包解析</a><ul>
<li><a href="#mutex">Mutex</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

<h1 id="sync包解析"><a href="#sync包解析" class="headerlink" title="sync包解析"></a>sync包解析</h1><h2 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h2><p>Mutex是一个互斥锁，当Mutex是零值的时候，它是没有上锁的。</p>
<p>Mutex不可复制。</p>
<p>以下是Mutex的定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	state <span class="keyword">int32</span></span><br><span class="line">	sema  <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件下还定义了一个Locker接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Locker represents an object that can be locked and unlocked.</span></span><br><span class="line"><span class="keyword">type</span> Locker <span class="keyword">interface</span> &#123;</span><br><span class="line">	Lock()</span><br><span class="line">	Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以及一组描述Mutex状态的变量：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	mutexLocked = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// mutex is locked</span></span><br><span class="line">	mutexWoken</span><br><span class="line">	mutexStarving</span><br><span class="line">	mutexWaiterShift = <span class="literal">iota</span></span><br><span class="line"></span><br><span class="line">	starvationThresholdNs = <span class="number">1e6</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://crazystrome.github.io/2020/10/14/spring%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="crazyStrome">
      <meta itemprop="description" content="啥都写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="crazyStrome的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/14/spring%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-14 18:23:20" itemprop="dateCreated datePublished" datetime="2020-10-14T18:23:20+08:00">2020-10-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-26 20:07:55" itemprop="dateModified" datetime="2020-05-26T20:07:55+08:00">2020-05-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>使用AOP需要在pom中导入spring支持aop的相关包。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjrt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1_3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://crazystrome.github.io/2020/10/14/spring%E6%BA%90%E7%A0%81%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="crazyStrome">
      <meta itemprop="description" content="啥都写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="crazyStrome的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/14/spring%E6%BA%90%E7%A0%81%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-14 18:23:20" itemprop="dateCreated datePublished" datetime="2020-10-14T18:23:20+08:00">2020-10-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-09 16:24:53" itemprop="dateModified" datetime="2020-08-09T16:24:53+08:00">2020-08-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://crazystrome.github.io/2020/10/14/SpringMVC%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="crazyStrome">
      <meta itemprop="description" content="啥都写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="crazyStrome的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/14/SpringMVC%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-14 18:23:20" itemprop="dateCreated datePublished" datetime="2020-10-14T18:23:20+08:00">2020-10-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-11 16:18:03" itemprop="dateModified" datetime="2020-06-11T16:18:03+08:00">2020-06-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h1 id="JDBC连接"><a href="#JDBC连接" class="headerlink" title="JDBC连接"></a>JDBC连接</h1><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>在pom中添加相关依赖。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/javax.servlet/jstl --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>添加jsp中jstl依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>添加返回json转换器依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>新建Person类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>新建PersonDAO接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonDAO</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This is the method to be used to initialize</span></span><br><span class="line"><span class="comment">     * database resources ie. connection.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDataSource</span><span class="params">(DataSource ds)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This is the method to be used to create</span></span><br><span class="line"><span class="comment">     * a record in the Student table.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(String name, String address)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This is the method to be used to list down</span></span><br><span class="line"><span class="comment">     * a record from the Student table corresponding</span></span><br><span class="line"><span class="comment">     * to a passed student id.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">getPerson</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This is the method to be used to list down</span></span><br><span class="line"><span class="comment">     * all the records from the Student table.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">listPersons</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This is the method to be used to delete</span></span><br><span class="line"><span class="comment">     * a record from the Student table corresponding</span></span><br><span class="line"><span class="comment">     * to a passed student id.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This is the method to be used to update</span></span><br><span class="line"><span class="comment">     * a record into the Student table.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Integer id, String address)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonJDBCTemplate</span> <span class="keyword">implements</span> <span class="title">PersonDAO</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDataSource</span><span class="params">(DataSource ds)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dataSource = ds;</span><br><span class="line">        <span class="keyword">this</span>.jdbcTemplate = <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(String name, String address)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;insert into person (name, address) values (?, ?)&quot;</span>;</span><br><span class="line">        jdbcTemplate.update(sql, name, address);</span><br><span class="line">        System.out.println(<span class="string">&quot;Create record name=&quot;</span> + name);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">getPerson</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;select * from person where id = ?&quot;</span>;</span><br><span class="line">        Person person = jdbcTemplate.queryForObject(sql,</span><br><span class="line">                <span class="keyword">new</span> Object[]&#123;id&#125;, <span class="keyword">new</span> PersonMapper());</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">listPersons</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;select * from person&quot;</span>;</span><br><span class="line">        List&lt;Person&gt; personList = jdbcTemplate.query(sql,</span><br><span class="line">                <span class="keyword">new</span> PersonMapper());</span><br><span class="line">        <span class="keyword">return</span> personList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;delete from person where id = ?&quot;</span>;</span><br><span class="line">        jdbcTemplate.update(sql, id);</span><br><span class="line">        System.out.println(<span class="string">&quot;Delete record with id: &quot;</span> + id);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Integer id, String address)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;update person set address = ? where id = ?&quot;</span>;</span><br><span class="line">        jdbcTemplate.update(sql, address, id);</span><br><span class="line">        System.out.println(<span class="string">&quot;Update record with id: &quot;</span> + id);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实现一个将mysql数据处理的mapper</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonMapper</span> <span class="keyword">implements</span> <span class="title">RowMapper</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">mapRow</span><span class="params">(ResultSet resultSet, <span class="keyword">int</span> i)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        p.setId(resultSet.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        p.setName(resultSet.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        p.setAddress(resultSet.getString(<span class="string">&quot;address&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置如下bean</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;000000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hsp.dao.PersonJDBCTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>实现controller</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HiController</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ApplicationContext context;</span><br><span class="line">    <span class="keyword">private</span> PersonJDBCTemplate template;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        context = applicationContext;</span><br><span class="line">        System.out.println(context.getApplicationName());</span><br><span class="line">        template = context.getBean(<span class="string">&quot;jdbcTemplate&quot;</span>, PersonJDBCTemplate.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/all&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHi</span><span class="params">(ModelMap modelMap)</span> </span>&#123;</span><br><span class="line">        List&lt;Person&gt; persons = template.listPersons();</span><br><span class="line">        modelMap.put(<span class="string">&quot;persons&quot;</span>, persons);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;show&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/add/&#123;name&#125;/&#123;address&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title">add</span><span class="params">(<span class="meta">@PathVariable</span> String name, <span class="meta">@PathVariable</span> String address)</span> </span>&#123;</span><br><span class="line">        template.create(name, address);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok()</span><br><span class="line">                .body(<span class="string">&quot;name: &quot;</span> + name + <span class="string">&quot;, address: &quot;</span> + address);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/del/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="meta">@PathVariable</span> <span class="keyword">int</span> id, Writer writer)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        template.delete(id);</span><br><span class="line">        writer.write(<span class="string">&quot;id: &quot;</span> + id + <span class="string">&quot; has been deleted.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h1><h2 id="Spring事务优点"><a href="#Spring事务优点" class="headerlink" title="Spring事务优点"></a>Spring事务优点</h2><p>支持全局事务和本地事务。</p>
<h3 id="全局事务"><a href="#全局事务" class="headerlink" title="全局事务"></a>全局事务</h3><p>全局事务可以使用多个事务资源，通常是关系数据库和消息队列。</p>
<h3 id="本地事务"><a href="#本地事务" class="headerlink" title="本地事务"></a>本地事务</h3><p>本地事务与资源挂钩，例如与 JDBC 关联的事务。本地事务可能更容易使用但有一个显著的缺点：不能跨多个事务资源。例如使用 JDBC 连接管理事务的代码不能在 JTA 事务中运行。另一个缺点是本地 transactions 对编程 model 是侵入性的。</p>
<h3 id="Spring的一致编程模型"><a href="#Spring的一致编程模型" class="headerlink" title="Spring的一致编程模型"></a>Spring的一致编程模型</h3><p>Spring 解决了全局和本地事务的缺点。应用开发者能在任何环境中使用一致的编程模型。只需要编写一次代码，就能适用于不同环境中的各种事务管理策略。Spring Framework 同时提供了声明式和编程式的事务管理。</p>
<p>通过程序化的 transaction management，开发人员可以使用 Spring Framework transaction 抽象，它可以运行任何底层的 transaction 基础架构。使用首选的声明性 model，开发人员通常只编写与 transaction management 相关的很少或没有 code，因此，不依赖于 Spring Framework transaction API 或任何其他 transaction API。</p>
<h2 id="Spring事务抽象"><a href="#Spring事务抽象" class="headerlink" title="Spring事务抽象"></a>Spring事务抽象</h2><p><code>org.springframework.transaction.PlatformTransactionManager</code>定义了事务策略，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，为了与 Spring 的哲学保持一致，<code>PlatformTransactionManager</code>接口的所有方法都能抛出的<code>TransactionException</code>是非受检异常（也就是说它继承<code>java.lang.RuntimeException</code>）。事务基础设施故障几乎总是很严重的，只有极少数情况应用代码可以真正从事务失败中恢复，但应用开发者也可选择捕获并处理异常</p>
<p><code>getTransaction(..)</code>方法根据<code>TransactionDefinition</code>参数返回<code>TransactionStatus</code>对象。如果当前调用栈中有匹配的事务，则返回的<code>TransactionStatus</code>代表已存在的事务，否则代表新的事务。后一种情况的含义是，与 Java EE transaction 上下文一样，<code>TransactionStatus</code>与执行线程相关联。</p>
<p>TransactionDefinition 是在 Spring 中事务支持的核心接口，它的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">getPropagationBehavior</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">getIsolationLevel</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">getTimeout</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>序号</th>
<th>方法 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>**int getPropagationBehavior()**该方法返回传播行为。Spring 提供了与 EJB CMT 类似的所有的事务传播选项。</td>
</tr>
<tr>
<td>2</td>
<td>**int getIsolationLevel()**该方法返回该事务独立于其他事务的工作的程度。</td>
</tr>
<tr>
<td>3</td>
<td>**String getName()**该方法返回该事务的名称。</td>
</tr>
<tr>
<td>4</td>
<td>**int getTimeout()**该方法返回以秒为单位的时间间隔，事务必须在该时间间隔内完成。</td>
</tr>
<tr>
<td>5</td>
<td>**boolean isReadOnly()**该方法返回该事务是否是只读的。</td>
</tr>
</tbody></table>
<p><code>TransactionStatus</code>接口为编写事务代码以控制事务执行和查询事务状态提供了一种更简单的方式。这些概念应该不陌生，因为它们对于所有的事务 API 来说都是常见的。以下清单显示了<code>TransactionStatus</code>接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionStatus</span> <span class="keyword">extends</span> <span class="title">SavepointManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isNewTransaction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasSavepoint</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRollbackOnly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRollbackOnly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCompleted</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下示例显示如何定义本地<code>PlatformTransactionManager</code> implementation(在本例中，使用 plain JDBC.</p>
<p>定义一个JDBC datasource。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;000000&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;manager&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;dataSource&quot;</span> ref=<span class="string">&quot;dataSource&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h2 id="声明式事务管理"><a href="#声明式事务管理" class="headerlink" title="声明式事务管理"></a>声明式事务管理</h2><p>使用AOP实现声明式事务管理。</p>
<p>回滚规则的概念很重要。它们允许您指定哪些 exceptions(和 throwables)应该导致自动回滚。您可以在 configuration 中以声明方式指定，而不是在 Java code 中。因此，虽然您仍然可以在<code>TransactionStatus</code> object 上调用<code>setRollbackOnly()</code>来回滚当前的 transaction，但大多数情况下您可以指定<code>MyApplicationException</code>必须始终导致回滚的规则。此选项的显着优势是业务 objects 不依赖于 transaction 基础结构。例如，它们通常不需要 import Spring transaction API 或其他 Spring API。</p>
<h3 id="理解Spring的声明事务实现"><a href="#理解Spring的声明事务实现" class="headerlink" title="理解Spring的声明事务实现"></a>理解Spring的声明事务实现</h3><p>关于 Spring Framework 的声明性 transaction 支持，要掌握的最重要的概念是，这种支持是<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-understanding-aop-proxies">通过 AOP 代理</a>启用的，而 transactional 建议是由元数据驱动的(目前是 XML-或 annotation-based)。 AOP 与 transactional 元数据的组合产生一个 AOP 代理，它使用<code>TransactionInterceptor</code>和适当的<code>PlatformTransactionManager</code> implementation 来驱动方法调用的 transactions。</p>
<p><img src="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/tx.jpg"></p>
<h3 id="声明事务实现的例子"><a href="#声明事务实现的例子" class="headerlink" title="声明事务实现的例子"></a>声明事务实现的例子</h3><p>pom中需要引入aspectJ依赖。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjrt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjtools --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>实现一个数据库实现类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonJDBCTemplate</span> <span class="keyword">implements</span> <span class="title">PersonDAO</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDataSource</span><span class="params">(DataSource ds)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dataSource = ds;</span><br><span class="line">        <span class="keyword">this</span>.jdbcTemplate = <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(String name, String address)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;insert into person (name, address) values (?, ?)&quot;</span>;</span><br><span class="line">        jdbcTemplate.update(sql, name, address);</span><br><span class="line">        System.out.println(<span class="string">&quot;Create record name=&quot;</span> + name);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;00000&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">getPerson</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;select * from person where id = ?&quot;</span>;</span><br><span class="line">        Person person = jdbcTemplate.queryForObject(sql,</span><br><span class="line">                <span class="keyword">new</span> Object[]&#123;id&#125;, <span class="keyword">new</span> PersonMapper());</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">listPersons</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;select * from person&quot;</span>;</span><br><span class="line">        List&lt;Person&gt; personList = jdbcTemplate.query(sql,</span><br><span class="line">                <span class="keyword">new</span> PersonMapper());</span><br><span class="line">        <span class="keyword">return</span> personList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;delete from person where id = ?&quot;</span>;</span><br><span class="line">        jdbcTemplate.update(sql, id);</span><br><span class="line">        System.out.println(<span class="string">&quot;Delete record with id: &quot;</span> + id);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Integer id, String address)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;update person set address = ? where id = ?&quot;</span>;</span><br><span class="line">        jdbcTemplate.update(sql, address, id);</span><br><span class="line">        System.out.println(<span class="string">&quot;Update record with id: &quot;</span> + id);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在create中抛出一个异常来检验添加给他的事务是否能正常回退。</p>
<p>配置xml中。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/tx/spring-tx-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/aop/spring-aop-3.0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;000000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hsp.dao.PersonJDBCTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    配置一个事务，对应的是实现的数据库bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;manager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    实现一个通知--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;personAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;manager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;create&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    声明一个advisor--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;personServiceOperation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.hsp.dao.PersonJDBCTemplate.create(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;personAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;personServiceOperation&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果设置read-only为true，那么该方法下不能对数据库执行插入修改删除操作，只能读取数据库。</p>
<h3 id="回滚声明式事务"><a href="#回滚声明式事务" class="headerlink" title="回滚声明式事务"></a>回滚声明式事务</h3><p>您可以准确配置哪些<code>Exception</code>类型标记 transaction 以进行回滚，包括已检查的 exceptions。以下 XML 代码段演示了如何为已检查的 application-specific <code>Exception</code>类型配置回滚：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;txManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;get*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span> <span class="attr">rollback-for</span>=<span class="string">&quot;NoProductInStockException&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果您不希望在抛出 exception 时回滚 transaction，您还可以指定“no rollback rules”。以下 example 告诉 Spring Framework 的 transaction 基础设施提交服务员 transaction，即使面对未处理的<code>InstrumentNotFoundException</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;updateStock&quot;</span> <span class="attr">no-rollback-for</span>=<span class="string">&quot;InstrumentNotFoundException&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>您还可以以编程方式指示所需的回滚。虽然很简单，但这个 process 非常具有侵入性，并且会将 code 紧密地耦合到 Spring Framework 的 transaction 基础架构。以下 example 显示了如何以编程方式指示所需的回滚：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resolvePosition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// some business logic...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoProductInStockException ex) &#123;</span><br><span class="line">        <span class="comment">// trigger rollback programmatically</span></span><br><span class="line">        TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tx-advice-设置"><a href="#tx-advice-设置" class="headerlink" title="tx:advice/设置"></a><a href="tx:advice/">tx:advice/</a>设置</h3><p>本节总结了您可以使用<code>&lt;tx:advice/&gt;</code>标记指定的各种 transactional 设置。默认的<code>&lt;tx:advice/&gt;</code>设置为：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#tx-propagation">传播设置</a>是<code>REQUIRED.</code></li>
<li>隔离 level 是<code>DEFAULT.</code></li>
<li>transaction 是 read-write。</li>
<li>transaction 超时默认为基础 transaction 系统的默认超时，如果不支持超时，则默认为 none。</li>
<li>任何<code>RuntimeException</code>触发回滚，任何已检查的<code>Exception</code>都没有。</li>
</ul>
<p>您可以更改这些默认设置。以下 table 总结了嵌套在<code>&lt;tx:advice/&gt;</code>和<code>&lt;tx:attributes/&gt;</code>标记内的<code>&lt;tx:method/&gt;</code>标记的各种属性：</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">需要？</th>
<th align="left">默认</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>name</code></td>
<td align="left">是</td>
<td align="left">与 transaction 属性关联的方法名称。通配符(*)字符可用于将相同的 transaction 属性设置与多个方法相关联(对于 example，<code>get*</code>，<code>handle*</code>，<code>on*Event</code>等)。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>propagation</code></td>
<td align="left">没有</td>
<td align="left"><code>REQUIRED</code></td>
<td align="left">Transaction 传播行为。</td>
</tr>
<tr>
<td align="left"><code>isolation</code></td>
<td align="left">没有</td>
<td align="left"><code>DEFAULT</code></td>
<td align="left">Transaction isolation level。仅适用于<code>REQUIRED</code>或<code>REQUIRES_NEW</code>的传播设置。</td>
</tr>
<tr>
<td align="left"><code>timeout</code></td>
<td align="left">没有</td>
<td align="left">-1</td>
<td align="left">Transaction timeout(秒)。仅适用于传播<code>REQUIRED</code>或<code>REQUIRES_NEW</code>。</td>
</tr>
<tr>
<td align="left"><code>read-only</code></td>
<td align="left">没有</td>
<td align="left">假</td>
<td align="left">Read-write 与 read-only transaction。仅适用于<code>REQUIRED</code>或<code>REQUIRES_NEW</code>。</td>
</tr>
<tr>
<td align="left"><code>rollback-for</code></td>
<td align="left">没有</td>
<td align="left">Comma-delimited 触发回滚的<code>Exception</code>实例列表。对于 example，<code>com.foo.MyBusinessException,ServletException.</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>no-rollback-for</code></td>
<td align="left">没有</td>
<td align="left">Comma-delimited 不触发回滚的<code>Exception</code>实例列表。对于 example，<code>com.foo.MyBusinessException,ServletException.</code></td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="使用-Transactional"><a href="#使用-Transactional" class="headerlink" title="使用@Transactional"></a>使用@Transactional</h3><p>使用<code>@Transactional</code> annotation 提供的 ease-of-use 最好用 example 说明，后面的文字对此进行了解释。考虑以下 class 定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the service class that we want to make transactional</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultFooService</span> <span class="keyword">implements</span> <span class="title">FooService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Foo <span class="title">getFoo</span><span class="params">(String fooName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Foo <span class="title">getFoo</span><span class="params">(String fooName, String barName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertFoo</span><span class="params">(Foo foo)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateFoo</span><span class="params">(Foo foo)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所述在 class level 中使用，annotation 指示声明 class(及其子类)的所有方法的默认值。或者，每个方法都可以单独注释。请注意，class-level annotation 不适用于 class 层次结构的祖先 classes;在这种情况下，需要在 order 中本地重新声明方法以参与 subclass-level annotation。</p>
<p>当如上所述的 POJO class 在 Spring context 中定义为 bean 时，可以通过<code>@Configuration</code> class 中的<code>@EnableTransactionManagement</code> annotation 创建 bean 实例 transactional。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/transaction/annotation/EnableTransactionManagement.html">javadoc</a>。</p>
<p>在 XML configuration 中，<code>&lt;tx:annotation-driven/&gt;</code>标签提供了类似的便利：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- from the file &#x27;context.xml&#x27; --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- this is the service object that we want to make transactional --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;fooService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.service.DefaultFooService&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- enable the configuration of transactional behavior based on annotations --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;txManager&quot;</span>/&gt;</span><span class="comment">&lt;!-- a PlatformTransactionManager is still required --&gt;</span> (1)</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;txManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- (this dependency is defined somewhere else) --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- other &lt;bean/&gt; definitions here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用代理时，应仅将<code>@Transactional</code> annotation 应用于具有公共可见性的方法。如果使用<code>@Transactional</code> annotation 注释 protected，private 或 package-visible 方法，则不会引发错误，但带注释的方法不会显示已配置的 transactional 设置。如果需要注释 non-public 方法，请考虑使用 AspectJ(稍后介绍)。</p>
<p>您可以将<code>@Transactional</code> annotation 应用于接口定义，接口上的方法，class 定义或 class 上的公共方法。但是，仅仅存在<code>@Transactional</code> annotation 不足以激活 transactional 行为。 <code>@Transactional</code> annotation 只是元数据，可以被<code>@Transactional</code> -aware 的某些运行时基础结构使用，并且可以使用元数据来配置具有 transactional 行为的相应 beans。在前面的 example 中，<code>&lt;tx:annotation-driven/&gt;</code>元素会切换 transactional 行为。</p>
<h5 id="Transactional-设置"><a href="#Transactional-设置" class="headerlink" title="@Transactional 设置"></a>@Transactional 设置</h5><p><code>@Transactional</code> annotation 是元数据，指定接口，class 或方法必须具有 transactional 语义(对于 example，“在调用此方法时启动全新的 read-only transaction，暂停任何现有的 transaction”)。默认的<code>@Transactional</code>设置如下：</p>
<ul>
<li>传播设置为<code>PROPAGATION_REQUIRED.</code></li>
<li>隔离 level 是<code>ISOLATION_DEFAULT.</code></li>
<li>transaction 是 read-write。</li>
<li>transaction 超时默认为基础 transaction 系统的默认超时，如果不支持超时，则为 none。</li>
<li>任何<code>RuntimeException</code>触发回滚，任何已检查的<code>Exception</code>都没有。</li>
</ul>
<p>您可以更改这些默认设置。以下 table 总结了<code>@Transactional</code> annotation 的各种 properties：</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#tx-multiple-tx-mgrs-with-attransactional">值</a></td>
<td align="left"><code>String</code></td>
<td align="left">可选限定符，指定要使用的 transaction manager。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#tx-propagation">传播</a></td>
<td align="left"><code>enum</code> : <code>Propagation</code></td>
<td align="left">可选的传播设置。</td>
</tr>
<tr>
<td align="left"><code>isolation</code></td>
<td align="left"><code>enum</code> : <code>Isolation</code></td>
<td align="left">可选隔离 level。仅适用于<code>REQUIRED</code>或<code>REQUIRES_NEW</code>的传播值。</td>
</tr>
<tr>
<td align="left"><code>timeout</code></td>
<td align="left"><code>int</code>(以粒度为单位)</td>
<td align="left">可选的 transaction 超时。仅适用于<code>REQUIRED</code>或<code>REQUIRES_NEW</code>的传播值。</td>
</tr>
<tr>
<td align="left"><code>readOnly</code></td>
<td align="left"><code>boolean</code></td>
<td align="left">Read-write 与 read-only transaction。仅适用于<code>REQUIRED</code>或<code>REQUIRES_NEW</code>的值。</td>
</tr>
<tr>
<td align="left"><code>rollbackFor</code></td>
<td align="left">_A_ray <code>Class</code> objects，必须从<code>Throwable.</code>派生</td>
<td align="left">可选的 exception exception classes 必须导致回滚。</td>
</tr>
<tr>
<td align="left"><code>rollbackForClassName</code></td>
<td align="left">_Alass 类的 class 名称。 classes 必须从<code>Throwable.</code>派生</td>
<td align="left">exception classes 名称的可选 array 必须导致回滚。</td>
</tr>
<tr>
<td align="left"><code>noRollbackFor</code></td>
<td align="left">_A_ray <code>Class</code> objects，必须从<code>Throwable.</code>派生</td>
<td align="left">可选 array 的 exception classes，不得导致回滚。</td>
</tr>
<tr>
<td align="left"><code>noRollbackForClassName</code></td>
<td align="left">Array 的<code>String</code> class 名称，必须从<code>Throwable.</code>派生</td>
<td align="left">可选 array 的 exception classes 名称，不得导致回滚。</td>
</tr>
</tbody></table>
<h5 id="多个-Transaction-Managers-with-Transactional"><a href="#多个-Transaction-Managers-with-Transactional" class="headerlink" title="多个 Transaction Managers with @Transactional"></a>多个 Transaction Managers with @Transactional</h5><p>大多数 Spring applications 只需要一个 transaction manager，但是在某些 application 中你可能需要多个独立的 transaction managers。您可以使用<code>@Transactional</code> annotation 的<code>value</code>属性来选择性地指定要使用的<code>PlatformTransactionManager</code>的标识。这可以是 bean name 或 transaction manager bean 的限定符 value。对于 example，使用限定符表示法，可以将以下 Java code 与 application context 中的以下 transaction manager bean 声明组合使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionalService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(&quot;order&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSomething</span><span class="params">(String name)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(&quot;account&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下清单显示了 bean 声明：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">value</span>=<span class="string">&quot;order&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">value</span>=<span class="string">&quot;account&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这种情况下，<code>TransactionalService</code> run 上的两个方法在单独的 transaction managers 下，由<code>order</code>和<code>account</code>限定符区分。如果未找到特定限定的<code>PlatformTransactionManager</code> bean，则仍使用默认的<code>&lt;tx:annotation-driven&gt;</code>目标 bean name，<code>transactionManager</code>。</p>
<h3 id="事务传播"><a href="#事务传播" class="headerlink" title="事务传播"></a>事务传播</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39625809/article/details/80707695">https://blog.csdn.net/weixin_39625809/article/details/80707695</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/71517302">https://zhuanlan.zhihu.com/p/71517302</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">crazyStrome</p>
  <div class="site-description" itemprop="description">啥都写</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">null </a>
  </div>

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">crazyStrome</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  

  

    </div>
</body>
</html>
