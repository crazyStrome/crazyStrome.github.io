<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"crazystrome.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="啥都写">
<meta property="og:type" content="website">
<meta property="og:title" content="crazyStrome的博客">
<meta property="og:url" content="http://crazystrome.github.io/page/4/index.html">
<meta property="og:site_name" content="crazyStrome的博客">
<meta property="og:description" content="啥都写">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="crazyStrome">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://crazystrome.github.io/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>crazyStrome的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">crazyStrome的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/crazyStrome" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://crazystrome.github.io/2020/10/14/spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="crazyStrome">
      <meta itemprop="description" content="啥都写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="crazyStrome的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/14/spring/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-14 18:23:20" itemprop="dateCreated datePublished" datetime="2020-10-14T18:23:20+08:00">2020-10-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-28 10:46:42" itemprop="dateModified" datetime="2020-05-28T10:46:42+08:00">2020-05-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h1 id="1-IoC容器"><a href="#1-IoC容器" class="headerlink" title="1.  IoC容器"></a>1.  IoC容器</h1><h2 id="1-1-Spring-IoC容器和Beans简介"><a href="#1-1-Spring-IoC容器和Beans简介" class="headerlink" title="1.1.  Spring IoC容器和Beans简介"></a>1.1.  Spring IoC容器和Beans简介</h2><p>控制反转也称为依赖注入。它是一个process，其中object仅通过构造函数arguments，工厂方法的arguments或者属性的properties来定义它们的依赖项。</p>
<p><code>org.springframework.beans</code>和<code>org.springframework.context</code>包是 Spring Framework 的 IoC 容器的基础。</p>
<p>在 Spring 中，构成 application 主干并由 Spring IoC 容器管理的 objects 称为 beans。</p>
<h2 id="1-2-容器概述"><a href="#1-2-容器概述" class="headerlink" title="1.2.  容器概述"></a>1.2.  容器概述</h2><p><code>org.springframework.context.ApplicationContext</code>接口表示 Spring IoC 容器，负责实例化，配置和组装 beans。容器通过读取 configuration 元数据获取有关 objects 实例化，配置和汇编的指令。 configuration 元数据以 XML，Java annotations 或 Java code 表示。</p>
<h3 id="1-2-1-Configuration元数据"><a href="#1-2-1-Configuration元数据" class="headerlink" title="1.2.1.  Configuration元数据"></a>1.2.1.  Configuration元数据</h3><p>Spring IoC 容器使用一种 configuration 元数据。此 configuration 元数据表示作为 application 开发人员如何告诉 Spring 容器在 application 中实例化，配置和组装 objects。</p>
<ul>
<li><p>Configuration 元数据传统上以简单直观的 XML 格式提供。</p>
</li>
<li><p>Spring 2.5 引入了对 annotation-based configuration 元数据的支持。</p>
</li>
<li><p>从 Spring 3.0 开始，Spring JavaConfig 项目提供的许多 features 成为 Spring Framework 核心的一部分</p>
</li>
</ul>
<p>Spring 配置方式至少包含一种并且通常容器必须管理多个 bean 定义。 基于 XML 配置的元数据将 beans 配置为 top-level <beans/>元素内的<bean/>元素。 Java 配置通常在<code>@Configuration</code> 标记的类中使用<code>@Bean</code> 注释的方法。</p>
<p>这些 bean 定义对应于构成应用的实际对象.</p>
<p>以下示例展示了基于 XML 配置的元数据的基本结构：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span>  (1) (2)</span><br><span class="line">        <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- more bean definitions go here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>id属性用于标识单个bean定义。</p>
<p>class属性定义bean的类型并需要使用完全限定的类名，就是完全路径。</p>
<h3 id="1-2-2-实例化容器"><a href="#1-2-2-实例化容器" class="headerlink" title="1.2.2.  实例化容器"></a>1.2.2.  实例化容器</h3><p>提供给<code>ApplicationContext</code>构造函数的一个或多个字符串类型的位置路径，它允许容器从各种外部资源(例如本地文件系统，Java <code>CLASSPATH</code>等)加载 configuration 元数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;services.xml&quot;</span>, <span class="string">&quot;daos.xml&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>property name</code>元素引用 JavaBean property 的 name，<code>ref</code>元素引用另一个 bean 定义的 name。</p>
<p>使用一个或多个<import/>元素来从一个文件或多个文件加载 bean 定义。以下示例显示了如何执行此操作：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;services.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;resources/messageSource.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;/resources/themeSource.xml&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-3-使用容器"><a href="#1-2-3-使用容器" class="headerlink" title="1.2.3.  使用容器"></a>1.2.3.  使用容器</h3><p><code>ApplicationContext</code>是高级工厂的接口，能够维护不同 beans 及其依赖项的注册表。通过使用方法<code>T getBean(String name, Class requiredType)</code>，可以检索 beans 的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create and configure beans</span></span><br><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;services.xml&quot;</span>, <span class="string">&quot;daos.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// retrieve configured instance</span></span><br><span class="line">PetStoreService service = context.getBean(<span class="string">&quot;petStore&quot;</span>, PetStoreService.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// use configured instance</span></span><br><span class="line">List&lt;String&gt; userList = service.getUsernameList();</span><br></pre></td></tr></table></figure>

<h2 id="1-3-Bean概述"><a href="#1-3-Bean概述" class="headerlink" title="1.3.  Bean概述"></a>1.3.  Bean概述</h2><p>Spring IoC 容器管理一个或多个 beans。</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">解释在……</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Class</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-class">实例化 Beans</a></td>
</tr>
<tr>
<td align="left">Name</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-beanname">命名 Beans</a></td>
</tr>
<tr>
<td align="left">Scope</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes">Bean的作用域</a></td>
</tr>
<tr>
<td align="left">Constructor arguments</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-collaborators=">依赖注入</a></td>
</tr>
<tr>
<td align="left">Properties</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-collaborators">依赖注入</a></td>
</tr>
<tr>
<td align="left">Autowiring mode</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-autowire">自动化协作者</a></td>
</tr>
<tr>
<td align="left">Lazy initialization mode</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lazy-init">Lazy-initialized Beans</a></td>
</tr>
<tr>
<td align="left">Initialization method</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle-initializingbean">初始化回调</a></td>
</tr>
<tr>
<td align="left">Destruction method</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle-disposablebean">毁灭回调</a></td>
</tr>
</tbody></table>
<p>除了包含有关如何创建特定 bean 的信息的 bean 定义之外，<code>ApplicationContext</code> implementations 还允许注册在容器外部(由用户)创建的现有 objects。这是通过<code>getBeanFactory()</code>方法访问 ApplicationContext 的 BeanFactory 来完成的，该方法返回 BeanFactory <code>DefaultListableBeanFactory</code> implementation。 <code>DefaultListableBeanFactory</code>通过<code>registerSingleton(..)</code>和<code>registerBeanDefinition(..)</code>方法支持此注册。但是，典型的 applications 只能使用通过常规 bean 定义元数据定义的 beans。</p>
<h3 id="1-3-1-命名Beans"><a href="#1-3-1-命名Beans" class="headerlink" title="1.3.1.  命名Beans"></a>1.3.1.  命名Beans</h3><p>bean 通常只有一个标识符。但是，如果它需要多个，则额外的可以被视为别名。</p>
<p>在 XML-based configuration 元数据中，使用<code>id</code>属性，<code>name</code>属性或两者来指定 bean 标识符。id属性允许指定一个id。如果要引入其他别名，可以在name属性中指定。</p>
<p>在 XML-based configuration 元数据中，您可以使用<alias/>元素来完成此操作。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;fromName&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;toName&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-3-2-实例化Beans"><a href="#1-3-2-实例化Beans" class="headerlink" title="1.3.2.  实例化Beans"></a>1.3.2.  实例化Beans</h3><p>bean 定义本质上是 creating 一个或多个 objects 的配方。容器在询问时查看命名 bean 的配方，并使用由 bean 定义封装的 configuration 元数据来创建(或获取)实际的 object。</p>
<p>以下 bean 定义指定通过调用工厂方法来创建 bean。该定义未指定返回的 object 的类型(class)，仅指定包含工厂方法的 class。在此 example 中，<code>createInstance()</code>方法必须是静态方法。以下 example 显示了如何指定工厂方法：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;clientService&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;examples.ClientService&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-method</span>=<span class="string">&quot;createInstance&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ClientService clientService = <span class="keyword">new</span> ClientService();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ClientService</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClientService <span class="title">createInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> clientService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用实例工厂方法进行实例化会从容器中调用现有 bean 的 non-static 方法来创建新的 bean。要使用此机制，请将<code>class</code>属性保留为空，并在<code>factory-bean</code>属性中，在当前(或 parent 或 ancestor)容器中指定 bean 的 name，该容器包含要调用以创建 object 的实例方法。使用<code>factory-method</code>属性设置工厂方法本身的 name。以下 example 显示了如何配置这样的 bean：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- the factory bean, which contains a method called createInstance() --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;serviceLocator&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.DefaultServiceLocator&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- inject any dependencies required by this locator bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- the bean to be created via the factory bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;clientService&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-bean</span>=<span class="string">&quot;serviceLocator&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-method</span>=<span class="string">&quot;createClientServiceInstance&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultServiceLocator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ClientService clientService = <span class="keyword">new</span> ClientServiceImpl();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientService <span class="title">createClientServiceInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> clientService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个工厂 class 也可以包含多个工厂方法</p>
<h2 id="1-4-依赖"><a href="#1-4-依赖" class="headerlink" title="1.4.  依赖"></a>1.4.  依赖</h2><h3 id="1-4-1-依赖注入"><a href="#1-4-1-依赖注入" class="headerlink" title="1.4.1.  依赖注入"></a>1.4.1.  依赖注入</h3><p>依赖注入（DI）是一个过程，是指一个Bean在初始化时，通过构造函数的参数、工厂方法的参数、或者properties中定义的依赖项或者从工厂方法返回的依赖项，来构成一个完整的bean。</p>
<p>DI 存在两种主要变体：<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-constructor-injection">Constructor-based 依赖注入</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-setter-injection">Setter-based 依赖注入</a>。</p>
<p>构造方法注入。</p>
<p>由容器调用具有多个参数的构造方法完成，每个参数代表一个依赖项。调用具有特定参数的静态工厂方法来构造bean是等效的。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;thingOne&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.ThingOne&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;thingTwo&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;thingThree&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;thingTwo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.ThingTwo&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;thingThree&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.ThingThree&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当构造方法中的参数类型是已知的，比如int或string，需要添加类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> examples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Number of years to calculate the Ultimate Answer</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> years;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The Answer to Life, the Universe, and Everything</span></span><br><span class="line">    <span class="keyword">private</span> String ultimateAnswer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExampleBean</span><span class="params">(<span class="keyword">int</span> years, String ultimateAnswer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.years = years;</span><br><span class="line">        <span class="keyword">this</span>.ultimateAnswer = ultimateAnswer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7500000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;42&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以使用<code>index</code>属性显式指定构造函数 arguments 的索引，如下面的 example 所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7500000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;42&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以使用构造函数参数 name 进行 value 消歧，如下面的 example 所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;years&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7500000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;ultimateAnswer&quot;</span> <span class="attr">value</span>=<span class="string">&quot;42&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>请记住，要使这项工作开箱即用，必须在启用 debug flag 的情况下编译 code，以便 Spring 可以从构造函数中查找参数 name。如果您不能或不想使用 debug flag 编译 code，则可以使用<a target="_blank" rel="noopener" href="https://download.oracle.com/javase/6/docs/api/java/beans/ConstructorProperties.html">@ConstructorProperties</a> 显式 name 构造函数 arguments。然后 sample class 必须如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> examples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fields omitted</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ConstructorProperties(&#123;&quot;years&quot;, &quot;ultimateAnswer&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExampleBean</span><span class="params">(<span class="keyword">int</span> years, String ultimateAnswer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.years = years;</span><br><span class="line">        <span class="keyword">this</span>.ultimateAnswer = ultimateAnswer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>setter依赖注入</p>
<p>Setter依赖注入是调用无参构造器或者无参工厂方法来实例化Bean后，在beans上调用setter方法的容器来完成。</p>
<p>可以混合使用构造器依赖注入和setter方法注入，构造器注入强制依赖项，settter方法注入可选依赖项。</p>
<p>容器解决依赖项分析：</p>
<ul>
<li>使用描述所有 beans 的 configuration 元数据创建和初始化<code>ApplicationContext</code>。 Configuration 元数据可以由 XML，Java code 或 annotations 指定。</li>
<li>对于每个 bean，其依赖关系以 properties，constructor arguments 或_ar_ments 的形式表示(如果使用它而不是普通的构造函数)。当实际创建 bean 时，这些依赖项将提供给 bean。</li>
<li>每个 property 或构造函数参数都是要设置的 value 的实际定义，或者是容器中另一个 bean 的 reference。</li>
<li>作为 value 的每个 property 或构造函数参数都从其指定的格式转换为该 property 或 constructor 参数的实际类型。默认情况下，Spring 可以将 string 格式提供的 value 转换为所有 built-in 类型，例如<code>int</code>，<code>long</code>，<code>String</code>，<code>boolean</code>等。</li>
</ul>
<p>Spring 容器在创建容器时验证每个 bean 的 configuration。但是，在实际创建 bean 之前，不会设置 bean properties 本身。</p>
<p>循环依赖：</p>
<p>对于 example：Class A 需要通过构造函数注入实现 class B，而 class B 需要通过构造函数注入实现 class A.如果为 classes A 和 B 配置 beans 以相互注入，则 Spring IoC 容器会在运行时检测到此循环 reference，并抛出<code>BeanCurrentlyInCreationException</code>。</p>
<p>可以使用setter注入配置循环依赖项。</p>
<p>spring在容器 load-time 处检测 configuration 问题，例如 reference to non-existent beans 和循环依赖项。</p>
<p>如果不存在循环依赖关系，则当一个或多个协作 beans 被注入依赖 bean 时，每个协作 bean 在被注入依赖 bean 之前完全配置。这意味着，如果 bean A 依赖于 bean B，Spring IoC 容器在 bean A 上调用 setter 方法之前完全配置 bean B.换句话说，bean 被实例化(如果它不是 pre-instantiated singleton)，设置其依赖项，并调用相关的生命周期方法(例如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle-initializingbean">配置的 init 方法</a>或<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle-initializingbean">InitializingBean 回调方法</a>)。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;parent&quot;</span> <span class="attr">abstract</span>=<span class="string">&quot;true&quot;</span> <span class="attr">class</span>=<span class="string">&quot;example.ComplexObject&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;adminEmails&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;administrator&quot;</span>&gt;</span>[emailprotected]<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;support&quot;</span>&gt;</span>[emailprotected]<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;child&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;adminEmails&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- the merge is specified on the child collection definition --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span> <span class="attr">merge</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;sales&quot;</span>&gt;</span>[emailprotected]<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;support&quot;</span>&gt;</span>[emailprotected]<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意在<code>child</code> bean 定义的<code>adminEmails</code> property 的<code>&lt;props/&gt;</code>元素上使用<code>merge=true</code>属性。当<code>child</code> bean 由容器解析并实例化时，生成的实例有一个<code>adminEmails</code> <code>Properties</code>集合，其中包含将 child 的<code>adminEmails</code>集合与 parent 的<code>adminEmails</code>集合合并的结果。</p>
<p>Spring 将 properties 等的空 arguments 视为空<code>Strings</code>。</p>
<p>需要null的时候使用<null/>。</p>
<h3 id="1-4-3-使用depends-on"><a href="#1-4-3-使用depends-on" class="headerlink" title="1.4.3.  使用depends-on"></a>1.4.3.  使用depends-on</h3><p>在使用此元素的 bean 初始化之前，<code>depends-on</code>属性可以显式强制初始化一个或多个 beans。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beanOne&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ExampleBean&quot;</span> <span class="attr">depends-on</span>=<span class="string">&quot;manager,accountDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;manager&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;manager&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;manager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ManagerBean&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.jdbc.JdbcAccountDao&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-4-4-Lazy-initialized-Beans"><a href="#1-4-4-Lazy-initialized-Beans" class="headerlink" title="1.4.4.  Lazy-initialized Beans"></a>1.4.4.  Lazy-initialized Beans</h3><p>默认情况下，<code>ApplicationContext</code> implementations 急切地创建和配置所有<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-singleton">singleton</a> beans 作为初始化 process 的一部分。通常，这个 pre-instantiation 是可取的，因为 configuration 或周围环境中的错误会立即被发现，而不是几小时甚至几天。如果不希望出现这种情况，可以通过将 bean 定义标记为 lazy-initialized 来阻止 singleton bean 的 pre-instantiation。 lazy-initialized bean 告诉 IoC 容器在第一次请求时创建 bean 实例，而不是在启动时创建 bean 实例。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;lazy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.something.ExpensiveToCreateBean&quot;</span> <span class="attr">lazy-init</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;not.lazy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.something.AnotherBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是，当 lazy-initialized bean 是 singleton bean 的依赖关系而 singleton bean 不是 lazy-initialized 时，<code>ApplicationContext</code>会在启动时创建 lazy-initialized bean，因为它必须满足 singleton 的依赖关系。 lazy-initialized bean 被注入 singleton bean，而不是 lazy-initialized。</p>
<p>可以使用<code>&lt;beans/&gt;</code>元素上的<code>default-lazy-init</code>属性控制容器 level 上的 lazy-initialization，以下 example 显示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">default-lazy-init</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- no beans will be pre-instantiated... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-4-5-自动装配"><a href="#1-4-5-自动装配" class="headerlink" title="1.4.5.  自动装配"></a>1.4.5.  自动装配</h3><p>自动装配具有以下优点：</p>
<ul>
<li>自动装配可以显着减少指定 properties 或构造函数 arguments 的需要。 (其他机制，如 bean 模板<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-singleton">在本章的其他地方讨论过</a>在此 regard.)也很有价值</li>
<li>随着 objects 的发展，自动装配可以更新 configuration。例如，如果需要向 class 添加依赖项，则可以自动满足该依赖项，而无需修改 configuration。因此，自动装配在开发期间尤其有用，而不会在 code base 变得更稳定时否定切换到显式布线的选项。</li>
</ul>
<p>使用 XML-based configuration 元数据(请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-child-bean-definitions">依赖注入</a>)时，可以使用``元素的<code>autowire</code>属性为 bean 定义指定 autowire 模式。自动装配功能有四种模式。您为每个 bean 指定自动装配，因此可以选择要自动装配的那些。以下 table 描述了四种自动装配模式：</p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>no</code></td>
<td align="left">(默认)无自动装配。 Bean references 必须由<code>ref</code>元素定义。不建议对较大的部署更改默认设置，因为明确指定协作者可以提供更好的控制和清晰度。在某种程度上，它记录了系统的结构。</td>
</tr>
<tr>
<td align="left"><code>byName</code></td>
<td align="left">property name 自动装配。 Spring 查找 bean，其 name 与需要自动装配的 property 相同。例如，如果 bean 定义由 name 设置为 autowire 并且它包含<code>master</code> property(即，它具有<code>setMaster(..)</code>方法)，则 Spring 将查找名为<code>master</code>的 bean 定义并使用它来设置 property。</td>
</tr>
<tr>
<td align="left"><code>byType</code></td>
<td align="left">如果容器中只存在 property 类型的一个 bean，则允许 property 自动装配。如果存在多个，则抛出致命的 exception，这表示您不能对该 bean 使用<code>byType</code>自动装配。如果没有匹配的 beans，则不会发生任何事情(property 未设置)。</td>
</tr>
<tr>
<td align="left"><code>constructor</code></td>
<td align="left">类似于<code>byType</code>但适用于构造函数 arguments。如果容器中没有构造函数参数类型的一个 bean，则会引发致命错误。</td>
</tr>
</tbody></table>
<p>当 Spring遇到一个在 setter 方法中使用的 @Autowired 注释，它会在方法中视图执行 <strong>byType</strong> 自动连接。</p>
<h3 id="1-4-6-方法注入"><a href="#1-4-6-方法注入" class="headerlink" title="1.4.6.  方法注入"></a>1.4.6.  方法注入</h3><p>容器中大多数bean都是单例。当 singleton bean 需要与另一个 singleton bean 协作或 non-singleton bean 需要与另一个 non-singleton bean 协作时，通常通过将一个 bean 定义为另一个的 property 来处理依赖关系。</p>
<p> 有时我们需要在一个bean A中调用另一个bean B的方法，通常我们会添加一个字段，然后使用依赖注入把bean B的实例注入到这个字段上。这种情况下在bean A 和 bean B都是singleton时没问题，但是在 bean A是singleton和bean B是非singleton时就可能出现问题。因为bean B为非singleton , 那么bean B是希望他的使用者在一些情况下创建一个新实例，而bean A使用字段把bean B的一个实例缓存了下来，每次都使用的是同一个实例。</p>
<p> 我们假设bean B是一个prototype</p>
<p> 一种解决办法是不使用字段依赖注入，每次使用bean B的时候都去bean容器中重新获取</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是一个命令执行类，提供一个process方法，执行用户的命令</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandManager</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用依赖注入，把applicationContext注入进来</span></span><br><span class="line">    <span class="meta">@Autowire</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户指定的参数，每次使用一个新的Command实例去执行命令</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> commandState 执行的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 执行后的返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">process</span><span class="params">(Map commandState)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 每次使用都调用createCommand去获取一个新实例</span></span><br><span class="line">        Command command = createCommand();</span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="keyword">return</span> command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从applicationContext获取一个新的Command实例</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Command <span class="title">createCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.applicationContext.getBean(<span class="string">&quot;command&quot;</span>, Command.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 上面的代码是每次都从applicationContext重新获取一个新实例来实现的。Spring提供了一个Lookup method inject机制，它可以改变方法的返回值，来达到方法注入的效果。对应的有annotation和xml两种使用方式。</p>
<h4 id="查找方法注入"><a href="#查找方法注入" class="headerlink" title="查找方法注入"></a>查找方法注入</h4><p>annotation的使用方式@Lookup，把@Lookup加到你要改变方法返回值的方法上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandManager</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">process</span><span class="params">(Map commandState)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 每次使用都调用createCommand去获取一个新实例</span></span><br><span class="line">        Command command = createCommand();</span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="keyword">return</span> command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Loopup的注释中的写明了需要返回的bean名字，如果没有写bean name，那么会根据createCommand的函数返回值类型去查找对应的bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Lookup(&quot;command&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Command <span class="title">createCommand</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> Spring的Lookup method inject实现原理的是使用CGLIB动态生成一个类去继承<code>CommandManager</code>，重写<code>createCommand</code>方法。然后根据@Lookup中指定的bean Name或者<code>createCommand</code>方法的返回类型判断需要返回的bean。<code>createCommand</code>可以是abstract和可以不是。因为使用的是继承，所以<code>CommandManager</code>类和<code>createCommand</code>方法都不能是final的。</p>
<p><code>createCommand</code>方法的签名需要满足如下要求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;public|protected&gt; [abstract] &lt;return-type&gt; theMethodName(no-arguments);</span><br></pre></td></tr></table></figure>

<p>如果方法是<code>abstract</code>，则 dynamically-generated 子类实现该方法。否则，dynamically-generated 子类将覆盖原始 class 中定义的具体方法。对应实现的XML配置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;command&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;AsyncCommand&quot;</span> scope=<span class="string">&quot;prototype&quot;</span>&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">&quot;commandManager&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;CommandManager&quot;</span>&gt;</span><br><span class="line">    &lt;lookup-method name=<span class="string">&quot;createCommand&quot;</span> bean=<span class="string">&quot;command&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h4 id="任意方法替换"><a href="#任意方法替换" class="headerlink" title="任意方法替换"></a>任意方法替换</h4><h2 id="1-5-Bean范围"><a href="#1-5-Bean范围" class="headerlink" title="1.5.  Bean范围"></a>1.5.  Bean范围</h2><p> Beans 可以定义为部署在多个范围之一中。 Spring Framework 支持六个范围，其中四个范围仅在您使用 web-aware <code>ApplicationContext</code>时可用。你也可以创建<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-other-injection">自定义范围。</a></p>
<p>以下 table 描述了支持的范围：</p>
<table>
<thead>
<tr>
<th align="left">范围</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-custom">singleton</a></td>
<td align="left">（默认）整个容器周期中只维护一个实例。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-singleton">原型</a></td>
<td align="left">每次请求时容器都会创建新的实例</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-prototype">请求</a></td>
<td align="left">将单个 bean 定义范围限定为单个 HTTP 请求的生命周期。也就是说，每个 HTTP 请求都有自己的 bean 实例，该实例是在单个 bean 定义的后面创建的。仅在 web-aware Spring <code>ApplicationContext</code>的 context 中有效。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-request">session</a></td>
<td align="left">将单个 bean 定义范围限定为 HTTP <code>Session</code>的生命周期。仅在 web-aware Spring <code>ApplicationContext</code>的 context 中有效。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-session">应用</a></td>
<td align="left">将单个 bean 定义范围限定为<code>ServletContext</code>的生命周期。仅在 web-aware Spring <code>ApplicationContext</code>的 context 中有效。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#beans-factory-scopes-application">WebSocket</a></td>
<td align="left">将单个 bean 定义范围限定为<code>WebSocket</code>的生命周期。仅在 web-aware Spring <code>ApplicationContext</code>的 context 中有效。</td>
</tr>
</tbody></table>
<h3 id="1-5-1-Singleton范围"><a href="#1-5-1-Singleton范围" class="headerlink" title="1.5.1.  Singleton范围"></a>1.5.1.  Singleton范围</h3><p>当把Bean的范围限定为Singleton时，Spring IoC容器只创建该bean的一个实例。该实例储存在此类singleton beans的缓存中，并且后续请求和引用都指向这同一个实例。</p>
<p><img src="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/singleton.jpg"></p>
<p> Spring singleton 的范围最好描述为 per-container 和 per-bean。这意味着，如果在单个 Spring 容器中为特定 class 定义一个 bean，则 Spring 容器将创建该bean 定义所定义的 class 的一个且仅一个实例。</p>
<h3 id="1-5-2-prototype范围"><a href="#1-5-2-prototype范围" class="headerlink" title="1.5.2.  prototype范围"></a>1.5.2.  prototype范围</h3><p>每次向spring IoC容器请求bean时都会新创建一个bean实例。</p>
<p><img src="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/prototype.jpg"></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.something.DefaultAccountService&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>应该为所有状态随时变化的 beans 使用原型范围，为 stateless beans 使用 singleton 范围。</p>
<p>当我们将一个bean的Scope定义为prototype时，有一点需要注意的是Spring将只会回调对应bean定义的初始化方法，而对于销毁方法，Spring是不会进行回调的。根据之前对我们对生命周期回调方法的介绍，我们知道初始化方法的回调是在Spring将对应的bean实例化之后进行回调的，不管我们将bean的Scope设置为何种类型，对应bean的实例化都是由Spring完成的，所以对于bean定义的初始化方法是可以被Spring回调的，这点没有问题。相对应的是bean的销毁方法是在Spring决定销毁bean容器之前进行回调的，这个时候Spring需要拿到对应的bean实例才能进行对应销毁方法的回调，但是对于prototype类型的bean定义而言，Spring是不会保留对应的bean实例的，所以它拿不到，也就不会进行回调了。而对于之前我们介绍的singleton类型的bean定义，由于其实例都由Spring缓存起来了，以确保每次请求的都是同一个实例，所以在bean容器销毁前，Spring还是可以拿到原来实例化的bean实例，所以就可以进行对应销毁方法的回调。</p>
<h3 id="1-5-3-带有prototype-bean依赖的单例bean"><a href="#1-5-3-带有prototype-bean依赖的单例bean" class="headerlink" title="1.5.3.  带有prototype-bean依赖的单例bean"></a>1.5.3.  带有prototype-bean依赖的单例bean</h3><p>需要使用方法注入</p>
<h3 id="1-5-4-Request，Session，Application-和-WebSocket-Scopes"><a href="#1-5-4-Request，Session，Application-和-WebSocket-Scopes" class="headerlink" title="1.5.4.  Request，Session，Application 和 WebSocket Scopes"></a>1.5.4.  Request，Session，Application 和 WebSocket Scopes</h3><p>仅当您使用 web-aware Spring <code>ApplicationContext</code> implementation(例如<code>XmlWebApplicationContext</code>)时，<code>request</code>，<code>session</code>，<code>application</code>和<code>websocket</code>范围才可用。如果将这些范围与常规 Spring IoC 容器(例如<code>ClassPathXmlApplicationContext</code>)一起使用，则会抛出抱怨未知 bean 范围的<code>IllegalStateException</code>。</p>
<h4 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h4><p>当我们将一个bean的Scope定义为request时，表示在每一个HttpRequest生命周期内从bean容器获取到的对应bean定义的实例都是同一个实例，而不同的HttpRequest所获取到的实例是不一样的。该类型的Scope只允许在Web环境下使用，包括后续介绍的session和application。</p>
<p>对于此种类型的bean有一个问题需要注意，那就是如果我们拥有一个singleton类型的 beanA，然后其需要被注入一个request类型的beanB时，如果我们在对beanA进行定义时就定义好了其对beanB的依赖。则由于Spring默认会在初始化bean容器后立即对单例类型的bean进行实例化，进而导致会实例化其所依赖的其它bean，也就是说在实例化beanA的时候，会进而实例化beanB。但此时是没有HttpRequest请求的，也就是说没有Web环境的，那么Spring将无法实例化beanB，其会抛出异常。<br>针对上述情形，可以有两种处理方法，一是指定beanA为懒初始化，这样Spring在bean容器初始化完成后默认不会对其进行实例化，只有在其第一次需要被使用的情况下才会被初始化，所以此时beanA不能作为其它会被Spring在bean容器初始化后进行实例化的bean的依赖关系链上的一员存在。<br>使用注解进行制定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanA</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种处理方式是可以在beanB的bean定义下定义<a href="aop:scoped-proxy/">aop:scoped-proxy/</a>以告诉Spring需要为对应的bean生成一个代理。这样在将beanB注入给beanA时实际上注入的只是一个代理，然后在我们真正使用beanB的时候，Spring会拿一个真正的beanB实例来进行对应的操作。</p>
<h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>当将一个bean的Scope定义为session时即表示该bean的实例将与session保持一致，即每一个不同的session保持一个不同的实例，同一个session则拥有相同的实例。或者换句话来说就是在同一session环境下，不管你从bean容器中获取对应bean定义的实例多少次，你取到的总是一个相同的实例。</p>
<h4 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h4><p>指定Scope为application也只能在Web环境下使用。当定义一个bean的scope为application时表示对应的bean实例是跟ServletContext绑定在一起的，即在整个ServletContext环境下都只会拥有一个对应的实例。</p>
<h3 id="1-5-5-自定义范围"><a href="#1-5-5-自定义范围" class="headerlink" title="1.5.5.  自定义范围"></a>1.5.5.  自定义范围</h3><p>自己实现scope接口，并注册到IoC容器中。</p>
<h2 id="1-6-自定义Bean的性质"><a href="#1-6-自定义Bean的性质" class="headerlink" title="1.6.  自定义Bean的性质"></a>1.6.  自定义Bean的性质</h2><p>Spring Framework 提供了许多可用于自定义 bean 特性的接口。本节将它们分组如下：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#registerDestructionCallback">生命周期回调</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle">ApplicationContextAware 和 BeanNameAware</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-aware">其他感知接口</a></li>
</ul>
<h3 id="1-6-1-生命周期回调"><a href="#1-6-1-生命周期回调" class="headerlink" title="1.6.1.  生命周期回调"></a>1.6.1.  生命周期回调</h3><p>实现 Spring <code>InitializingBean</code>和<code>DisposableBean</code>接口，容器就可以通过afterPropertiesSet()和destory()方法进行Bean的初始化和销毁操作。</p>
<p>使用<code>init-method</code>和<code>destroy-method</code>也可以定义初始化方法和销毁方法。</p>
<p>初始化方法是在初始化之后执行的，销毁方法是在销毁Bean之前执行的。</p>
<p>还可以实现Lifecyscle接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lifecycle</span> </span>&#123;  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;  </span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h4 id="初始化回调"><a href="#初始化回调" class="headerlink" title="初始化回调"></a>初始化回调</h4><p>接口允许 bean 在容器在 bean 上设置所有必需的 properties 后执行初始化工作。 <code>InitializingBean</code>接口指定单个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure>

<p>我们建议您不要使用<code>InitializingBean</code>接口，因为它会不必要地将 code 耦合到 Spring。或者，我们建议使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-extension">@PostConstruct</a> annotation 或指定 POJO 初始化方法。对于 XML-based configuration 元数据，可以使用<code>init-method</code>属性指定具有 void no-argument 签名的方法的 name。使用 Java configuration，您可以使用<code>@Bean</code>的<code>initMethod</code>属性。</p>
<h4 id="销毁回调"><a href="#销毁回调" class="headerlink" title="销毁回调"></a>销毁回调</h4><p>实现<code>org.springframework.beans.factory.DisposableBean</code>接口允许 bean 在包含它的容器被销毁时获得回调。 <code>DisposableBean</code>接口指定单个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure>

<p>我们建议您不要使用<code>DisposableBean</code>回调接口，因为它会不必要地将 code 耦合到 Spring。或者，我们建议使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-java-lifecycle-callbacks">@PreDestroy</a> annotation 或指定 bean 定义支持的泛型方法。使用 XML-based configuration 元数据，您可以使用``上的<code>destroy-method</code>属性。使用 Java configuration，您可以使用<code>@Bean</code>的<code>destroyMethod</code>属性。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleInitBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;cleanup&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以在<beans/>中添加默认的初始化方法或销毁方法：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">default-init-method</span>=<span class="string">&quot;init&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;blogService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.something.DefaultBlogService&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;blogDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;blogDao&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>从 Spring 2.5 开始，您有三个控制 bean 生命周期行为的选项：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle">InitializingBean</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle-initializingbean">DisposableBean</a>回调接口</li>
<li>自定义<code>init()</code>和<code>destroy()</code>方法</li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle-disposablebean">@PostConstruct 和 @PreDestroy 注释</a>。您可以组合这些机制来控制给定的 bean。</li>
</ul>
<h4 id="启动和关闭回调方法"><a href="#启动和关闭回调方法" class="headerlink" title="启动和关闭回调方法"></a>启动和关闭回调方法</h4><p><code>Lifecycle</code>接口为具有自己的生命周期要求的任何 object 定义了基本方法(例如启动和停止一些后台 process)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Phased</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPhase</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmartLifecycle</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span>, <span class="title">Phased</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAutoStartup</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">(Runnable callback)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动时，具有最低相位的 objects 首先启动。停止时，遵循反向顺序。因此，实现<code>SmartLifecycle</code>且其<code>getPhase()</code>方法返回<code>Integer.MIN_VALUE</code>的 object 将是第一个开始，最后一个停止。在频谱的另一端，<code>Integer.MAX_VALUE</code>的阶段值将指示 object 应该最后启动并首先停止(可能因为它依赖于其他进程 running)。在考虑阶段 value 时，同样重要的是要知道没有实现<code>SmartLifecycle</code>的任何“正常”<code>Lifecycle</code> object 的默认阶段是<code>0</code>。因此，任何负相位 value 都表示 object 应该在这些标准组件之前启动(并在它们之后停止)。对于任何正相值，反向都是 true。</p>
<p><code>SmartLifecycle</code>定义的 stop 方法接受回调。在 implementation 的 shutdown process 完成之后，任何 implementation 都必须调用该回调的<code>run()</code>方法。这样可以在必要时启用异步关闭</p>
<h3 id="1-6-2-ApplicationContextAware和BeanNameAware"><a href="#1-6-2-ApplicationContextAware和BeanNameAware" class="headerlink" title="1.6.2.  ApplicationContextAware和BeanNameAware"></a>1.6.2.  ApplicationContextAware和BeanNameAware</h3><p>当<code>ApplicationContext</code>创建实现<code>org.springframework.context.ApplicationContextAware</code>接口的 object 实例时，该实例将提供的 reference。</p>
<h2 id="1-7-Bean定义继承"><a href="#1-7-Bean定义继承" class="headerlink" title="1.7.  Bean定义继承"></a>1.7.  Bean定义继承</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;inheritedTestBean&quot;</span> <span class="attr">abstract</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.TestBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;parent&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;inheritsWithDifferentClass&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.DerivedTestBean&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">parent</span>=<span class="string">&quot;inheritedTestBean&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;initialize&quot;</span>&gt;</span>  (1)</span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;override&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- the age property value of 1 will be inherited from parent --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>child bean 定义从 parent 继承范围，构造函数参数值，属性值和方法覆盖，并带有添加新值的选项。您指定的任何范围，初始化方法，销毁方法或<code>static</code>工厂方法设置都会覆盖相应的 parent 设置。</p>
<p>前面的 example 使用<code>abstract</code>属性显式地将 parent bean 定义标记为 abstract。如果 parent 定义未指定 class，则需要将 parent bean 定义显式标记为<code>abstract</code>，如下面的 example 所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;inheritedTestBeanWithoutClass&quot;</span> <span class="attr">abstract</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;parent&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;inheritsWithClass&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.DerivedTestBean&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">parent</span>=<span class="string">&quot;inheritedTestBeanWithoutClass&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;initialize&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;override&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- age will inherit the value of 1 from the parent bean definition--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>parent bean 无法单独实例化，因为它不完整，并且也明确标记为<code>abstract</code>。当定义为<code>abstract</code>时，它仅可用作纯模板 bean 定义，用作 child 定义的 parent 定义。尝试使用这样的<code>abstract</code> parent bean，通过将其称为另一个 bean 的 ref property 或使用 parent bean ID 进行显式<code>getBean()</code>调用返回错误。类似地，容器的内部<code>preInstantiateSingletons()</code>方法忽略定义为 abstract 的 bean 定义。</p>
<h2 id="1-8-集装箱扩建点"><a href="#1-8-集装箱扩建点" class="headerlink" title="1.8.  集装箱扩建点"></a>1.8.  集装箱扩建点</h2><p>通常，application 开发人员不需要子类<code>ApplicationContext</code> implementation classes。相反，可以通过插入特殊 integration 接口的 implementations 来扩展 Spring IoC 容器。</p>
<h3 id="1-8-1-使用-BeanPostProcessor-自定义-Beans"><a href="#1-8-1-使用-BeanPostProcessor-自定义-Beans" class="headerlink" title="1.8.1.  使用 BeanPostProcessor 自定义 Beans"></a>1.8.1.  使用 BeanPostProcessor 自定义 Beans</h3><h2 id="1-9-Annotation-based-Container-Configuration"><a href="#1-9-Annotation-based-Container-Configuration" class="headerlink" title="1.9.  Annotation-based Container Configuration"></a>1.9.  Annotation-based Container Configuration</h2><p>在xml配置中添加<a href="context:annotation-config">context:annotation-config</a>来开启注解模式。</p>
<p><code>&lt;context:annotation-config/&gt;</code>仅在定义它的同一 application context 中查找 beans 上的 annotations。</p>
<h3 id="1-9-1-Required"><a href="#1-9-1-Required" class="headerlink" title="1.9.1.  @Required"></a>1.9.1.  @Required</h3><p><code>@Required</code> annotation 适用于 bean property setter 方法，如下例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Required</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的property必须被装配，否则会抛出异常。</p>
<h3 id="1-9-2-使用-Autowired"><a href="#1-9-2-使用-Autowired" class="headerlink" title="1.9.2.  使用@Autowired"></a>1.9.2.  使用@Autowired</h3><p>可以将<code>@Autowired</code> annotation 应用于构造函数，如以下 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MovieRecommender</span><span class="params">(CustomerPreferenceDao customerPreferenceDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 Spring Framework 4.3 开始，如果目标 bean 仅定义一个开头的构造函数，则不再需要在这样的构造函数上使用<code>@Autowired</code> annotation。但是，如果有几个构造器可用，则必须注释至少一个构造器以教导容器使用哪一个。</p>
<p>还可以将<code>@Autowired</code> annotation 应用于“传统”setter 方法，如以下 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-9-5-使用泛型作为自动装配限定符"><a href="#1-9-5-使用泛型作为自动装配限定符" class="headerlink" title="1.9.5.  使用泛型作为自动装配限定符"></a>1.9.5.  使用泛型作为自动装配限定符</h3><p>除了<code>@Qualifier</code> annotation 之外，您还可以使用 Java 泛型类型作为隐式的限定形式。例如，假设您有以下 configuration：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringStore <span class="title">stringStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringStore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IntegerStore <span class="title">integerStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IntegerStore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设前面的 beans 实现了一个通用接口(即<code>Store</code>和<code>Store</code>)，你可以<code>@Autowire</code> <code>Store</code>接口，泛型用作限定符，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Store&lt;String&gt; s1; <span class="comment">// &lt;String&gt; qualifier, injects the stringStore bean</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Store&lt;Integer&gt; s2; </span><br></pre></td></tr></table></figure>

<p>通用限定符也适用于自动装配 lists，<code>Map</code>实例和数组。</p>
<h3 id="1-9-6-使用-CustomAutowireConfigurer"><a href="#1-9-6-使用-CustomAutowireConfigurer" class="headerlink" title="1.9.6. 使用 CustomAutowireConfigurer"></a>1.9.6. 使用 CustomAutowireConfigurer</h3><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/CustomAutowireConfigurer.html">CustomAutowireConfigurer 上</a>是一个<code>BeanFactoryPostProcessor</code>，它允许您注册自己的自定义限定符注释类型，即使它们没有使用 Spring 的<code>@Qualifier</code> annotation 注释。以下 example 显示了如何使用<code>CustomAutowireConfigurer</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;customAutowireConfigurer&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.annotation.CustomAutowireConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;customQualifierTypes&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>example.CustomQualifier<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>AutowireCandidateResolver</code>通过以下方式确定 autowire 候选人：</p>
<ul>
<li>每个 bean 定义的<code>autowire-candidate</code> value</li>
<li><code>&lt;beans/&gt;</code>元素上可用的任何<code>default-autowire-candidates</code>模式</li>
<li><code>@Qualifier</code> 注释的存在以及使用<code>CustomAutowireConfigurer</code>注册的任何自定义注释</li>
</ul>
<p>当多个 beans 有资格作为 autowire 候选者时，“primary”的确定如下：如果候选者中只有一个 bean 定义将<code>primary</code>属性设置为<code>true</code>，则选择它。</p>
<h3 id="1-9-7-注射-Resource"><a href="#1-9-7-注射-Resource" class="headerlink" title="1.9.7.  注射@Resource"></a>1.9.7.  注射@Resource</h3><p>Spring 还支持使用字段上的 JSR-250 <code>@Resource</code> annotation 或 bean property setter 方法进行注入。</p>
<p><code>@Resource</code>采用 name 属性。默认情况下，Spring 将 value 解释为要注入的 bean name。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource(name=&quot;myMovieFinder&quot;)</span> (<span class="number">1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果未显式指定 name，则默认 name 派生自字段 name 或 setter 方法。如果是字段，则需要字段 name。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-9-8-使用-PostConstruct和-PreDestory"><a href="#1-9-8-使用-PostConstruct和-PreDestory" class="headerlink" title="1.9.8.  使用@PostConstruct和@PreDestory"></a>1.9.8.  使用@PostConstruct和@PreDestory</h3><p><code>CommonAnnotationBeanPostProcessor</code>不仅识别<code>@Resource</code> annotation，还识别 JSR-250 生命周期注释。在 Spring 2.5 中引入，对这些注释的支持提供了<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-scanning-qualifiers">初始化回调</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle-initializingbean">销毁回调</a>中描述的另一种替代方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachingMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">populateMovieCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// populates the movie cache upon initialization...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearMovieCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// clears the movie cache upon destruction...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-10-Classpath扫描和托管组件"><a href="#1-10-Classpath扫描和托管组件" class="headerlink" title="1.10.  Classpath扫描和托管组件"></a>1.10.  Classpath扫描和托管组件</h2><p>本章中的大多数示例都使用 XML 来指定配置Bean的数据，该元数据在 Spring 容器中生成每个<code>BeanDefinition</code>。上一节(<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle-combined-effects">Annotation-based Container Configuration</a>)演示了如何通过源代码级别的注解提供大量配置元数据。但是，即使在这些示例中，基础bean 定义也在 XML 文件中明确定义，而 annotations 仅驱动依赖项注入。本节介绍通过扫描 classpath 隐式检测候选组件的选项。候选组件是 classes，它们与过滤条件匹配，并且在容器中注册了相应的 bean 定义。这消除了使用 XML 执行 bean 注册的需要。相反，您可以使用 annotations(用于 example，<code>@Component</code>)，AspectJ 类型表达式或您自己的自定义过滤条件来选择哪些 classes 具有向容器注册的 bean 定义。</p>
<h3 id="1-10-1-Component和进一步的刻板印象注释"><a href="#1-10-1-Component和进一步的刻板印象注释" class="headerlink" title="1.10.1.  @Component和进一步的刻板印象注释"></a>1.10.1.  @Component和进一步的刻板印象注释</h3><p><code>@Repository</code> annotation 是任何 class 的标记，它满足 repository(也称为 Data Access Object 或 DAO)的角色或构造型。该标记的用途之一是 exceptions 的自动转换，如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#beans-annotation-config">Exception 翻译</a>中所述。</p>
<p>Spring 提供了进一步的构造型注释：<code>@Component</code>，<code>@Service</code>和<code>@Controller</code>。 <code>@Component</code>是任何 Spring-managed component 的通用构造型。 <code>@Repository</code>，<code>@Service</code>和<code>@Controller</code>是<code>@Component</code>的特化，用于更具体的用例(分别在持久性，服务和表示层中)。因此，您可以使用<code>@Component</code>注释 component classes，但是，通过使用<code>@Repository</code>，<code>@Service</code>或<code>@Controller</code>注释它们，您的 classes 更适合通过工具处理或与方面相关联。例如，这些构造型注释成为切入点的理想目标。 <code>@Repository</code>，<code>@Service</code>和<code>@Controller</code>还可以在 Spring Framework 的未来版本中携带其他语义。因此，如果您在服务层使用<code>@Component</code>或<code>@Service</code>之间进行选择，<code>@Service</code>显然是更好的选择。同样，如前所述，已经支持<code>@Repository</code>作为持久层中自动 exception 转换的标记。</p>
<h3 id="1-10-2-使用-Meta-annotations-和-Composed-Annotations"><a href="#1-10-2-使用-Meta-annotations-和-Composed-Annotations" class="headerlink" title="1.10.2.  使用 Meta-annotations 和 Composed Annotations"></a>1.10.2.  使用 Meta-annotations 和 Composed Annotations</h3><p>元注解的作用就是负责注解其他注解。Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。Java5.0定义的元注解：<br>　　　　1.@Target,<br>　　　　2.@Retention,<br>　　　　3.@Documented,<br>　　　　4.@Inherited</p>
<h3 id="1-10-3-自动检测-Classes-并注册-Bean-定义"><a href="#1-10-3-自动检测-Classes-并注册-Bean-定义" class="headerlink" title="1.10.3.  自动检测 Classes 并注册 Bean 定义"></a>1.10.3.  自动检测 Classes 并注册 Bean 定义</h3><p>Spring 可以自动检测原型 classes 并使用<code>ApplicationContext</code>注册相应的<code>BeanDefinition</code>实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleMovieLister</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JpaMovieFinder</span> <span class="keyword">implements</span> <span class="title">MovieFinder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// implementation elided for clarity</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要自动检测这些 classes 并注册相应的 beans，您需要将<code>@ComponentScan</code>添加到<code>@Configuration</code> class，其中<code>basePackages</code>属性是两个 classes 的 common parent 包。 </p>
<h3 id="1-10-4-使用过滤器自定义扫描"><a href="#1-10-4-使用过滤器自定义扫描" class="headerlink" title="1.10.4.  使用过滤器自定义扫描"></a>1.10.4.  使用过滤器自定义扫描</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;org.example&quot;,</span></span><br><span class="line"><span class="meta">        includeFilters = @Filter(type = FilterType.REGEX, pattern = &quot;.*Stub.*Repository&quot;),</span></span><br><span class="line"><span class="meta">        excludeFilters = @Filter(Repository.class))</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;org.example&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;regex&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">expression</span>=<span class="string">&quot;.*Stub.*Repository&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Repository&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-10-5-在组件中定义-Bean-元数据"><a href="#1-10-5-在组件中定义-Bean-元数据" class="headerlink" title="1.10.5.  在组件中定义 Bean 元数据"></a>1.10.5.  在组件中定义 Bean 元数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryMethodComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;public&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestBean <span class="title">publicInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TestBean(<span class="string">&quot;publicInstance&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Component method implementation omitted</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是在Bean的定义类中产生其他Bean，工厂类的概念。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryMethodComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;public&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestBean <span class="title">publicInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TestBean(<span class="string">&quot;publicInstance&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use of a custom qualifier and autowiring of method parameters</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> TestBean <span class="title">protectedInstance</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="meta">@Qualifier(&quot;public&quot;)</span> TestBean spouse,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="meta">@Value(&quot;#&#123;privateInstance.age&#125;&quot;)</span> String country)</span> </span>&#123;</span><br><span class="line">        TestBean tb = <span class="keyword">new</span> TestBean(<span class="string">&quot;protectedInstance&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        tb.setSpouse(spouse);</span><br><span class="line">        tb.setCountry(country);</span><br><span class="line">        <span class="keyword">return</span> tb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TestBean <span class="title">privateInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TestBean(<span class="string">&quot;privateInstance&quot;</span>, i++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@RequestScope</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestBean <span class="title">requestScopedInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TestBean(<span class="string">&quot;requestScopedInstance&quot;</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-10-6-自动检测命名的组件"><a href="#1-10-6-自动检测命名的组件" class="headerlink" title="1.10.6.  自动检测命名的组件"></a>1.10.6.  自动检测命名的组件</h3><p>当 component 作为 scan process 的一部分自动检测时，其 bean name 由该扫描程序已知的<code>BeanNameGenerator</code>策略生成。默认情况下，任何包含 name <code>value</code>的 Spring 构造型 annotation(<code>@Component</code>，<code>@Repository</code>，<code>@Service</code>和<code>@Controller</code>)都会将 name 提供给相应的 bean 定义。</p>
<p>如果这样的 annotation 不包含 name <code>value</code>或任何其他检测到的 component(例如自定义过滤器发现的那些)，则默认的 bean name generator 将返回未大写的 non-qualified class name。如果检测到以下 component classes，则名称将为<code>myMovieLister</code>和<code>movieFinderImpl</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;myMovieLister&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieFinderImpl</span> <span class="keyword">implements</span> <span class="title">MovieFinder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果您不想依赖默认的 bean-naming 策略，则可以提供自定义 bean-naming 策略。首先，实现<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/factory/support/BeanNameGenerator.html">BeanNameGenerator</a>接口，并确保包含默认的 no-arg 构造函数。然后，在配置扫描程序时提供完全限定的 class name，如下面的 example annotation 和 bean 定义所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;org.example&quot;, nameGenerator = MyNameGenerator.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;org.example&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">name-generator</span>=<span class="string">&quot;org.example.MyNameGenerator&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-10-7-为自动检测组件提供scope"><a href="#1-10-7-为自动检测组件提供scope" class="headerlink" title="1.10.7.  为自动检测组件提供scope"></a>1.10.7.  为自动检测组件提供scope</h3><p>与 Spring-managed 组件一样，自动检测组件的默认范围和最常见范围是<code>singleton</code>。但是，有时您需要一个可由<code>@Scope</code> annotation 指定的不同范围。您可以在 annotation 中提供范围的 name，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieFinderImpl</span> <span class="keyword">implements</span> <span class="title">MovieFinder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-10-8-使用-Annotations-提供限定符元数据"><a href="#1-10-8-使用-Annotations-提供限定符元数据" class="headerlink" title="1.10.8.  使用 Annotations 提供限定符元数据"></a>1.10.8.  使用 Annotations 提供限定符元数据</h3><h3 id="1-10-9-生成候选组件索引"><a href="#1-10-9-生成候选组件索引" class="headerlink" title="1.10.9.  生成候选组件索引"></a>1.10.9.  生成候选组件索引</h3><p>虽然 classpath 扫描非常快，但是可以通过在编译时创建候选的静态列表来改进大应用程序的启动性能。</p>
<p>要生成索引，请为包含作为 component scan 指令目标的组件的每个模块添加其他依赖项。以下 example 显示了如何使用 Maven 执行此操作：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-indexer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="1-12-使用java的容器配置"><a href="#1-12-使用java的容器配置" class="headerlink" title="1.12.  使用java的容器配置"></a>1.12.  使用java的容器配置</h2><p>本节介绍如何在 Java code 中使用 annotations 来配置 Spring 容器。它包括以下主题：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-java-basic-concepts">基本概念： @Bean 和 @Configuration</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-java-instantiating-container">使用 AnnotationConfigApplicationContext 实例化 Spring 容器</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-java-bean-annotation">使用 @Bean Annotation</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-java-configuration-annotation">使用 @Configuration annotation</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-java-composing-configuration-classes">编写 Java-based 配置</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-definition-profiles">Bean 定义 Profiles</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-property-source-abstraction">PropertySource 抽象</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-using-propertysource">使用 @PropertySource</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-placeholder-resolution-in-statements">Statements 中的占位符解析</a></li>
</ul>
<h3 id="1-12-1-Bean和-Configuration"><a href="#1-12-1-Bean和-Configuration" class="headerlink" title="1.12.1.  @Bean和@Configuration"></a>1.12.1.  @Bean和@Configuration</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyService <span class="title">myService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面的<code>AppConfig</code> class 等效于以下 Spring `` XML：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.acme.services.MyServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-12-2-使用-AnnotationConfigApplicationContext-实例化-Spring-容器"><a href="#1-12-2-使用-AnnotationConfigApplicationContext-实例化-Spring-容器" class="headerlink" title="1.12.2.  使用 AnnotationConfigApplicationContext 实例化 Spring 容器"></a>1.12.2.  使用 AnnotationConfigApplicationContext 实例化 Spring 容器</h3><h4 id="简单构造"><a href="#简单构造" class="headerlink" title="简单构造"></a>简单构造</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">    MyService myService = ctx.getBean(MyService.class);</span><br><span class="line">    myService.doStuff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用register构造"><a href="#使用register构造" class="headerlink" title="使用register构造"></a>使用register构造</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">    ctx.register(AppConfig.class, OtherConfig.class);</span><br><span class="line">    ctx.register(AdditionalConfig.class);</span><br><span class="line">    ctx.refresh();</span><br><span class="line">    MyService myService = ctx.getBean(MyService.class);</span><br><span class="line">    myService.doStuff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 no-arg 构造函数实例化<code>AnnotationConfigApplicationContext</code>，然后使用<code>register()</code>方法对其进行配置。</p>
<h4 id="使用scan：启用Component扫描"><a href="#使用scan：启用Component扫描" class="headerlink" title="使用scan：启用Component扫描"></a>使用scan：启用Component扫描</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.acme&quot;)</span> (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span>  </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">    ctx.scan(<span class="string">&quot;com.acme&quot;</span>);</span><br><span class="line">    ctx.refresh();</span><br><span class="line">    MyService myService = ctx.getBean(MyService.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-12-3-使用-Bean注解"><a href="#1-12-3-使用-Bean注解" class="headerlink" title="1.12.3.  使用@Bean注解"></a>1.12.3.  使用@Bean注解</h3><p>可以在@Component或者@Configuration注解的类下面使用@Bean注解。</p>
<h4 id="声明Bean"><a href="#声明Bean" class="headerlink" title="声明Bean"></a>声明Bean</h4><p>要声明 bean，可以使用<code>@Bean</code> annotation 注释方法。您可以使用此方法在指定为方法的 return value 的类型的<code>ApplicationContext</code>中注册 bean 定义。默认情况下， bean name 与方法 name 相同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransferServiceImpl <span class="title">transferService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Bean依赖项"><a href="#Bean依赖项" class="headerlink" title="Bean依赖项"></a>Bean依赖项</h4><p>如果我们的<code>TransferService</code>需要<code>AccountRepository</code>，我们可以使用方法参数来实现该依赖关系，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransferService <span class="title">transferService</span><span class="params">(AccountRepository accountRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl(accountRepository);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接收生命周期回调"><a href="#接收生命周期回调" class="headerlink" title="接收生命周期回调"></a>接收生命周期回调</h4><p>使用<code>@Bean</code> annotation 定义的任何 classes 都支持常规生命周期回调，并且可以使用 JSR-250 中的<code>@PostConstruct</code>和<code>@PreDestroy</code> 注释。</p>
<p><code>@Bean</code> annotation 支持指定任意初始化和销毁回调方法，就像<code>bean</code>元素上 Spring XML 的<code>init-method</code>和<code>destroy-method</code>属性一样，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanOne</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// initialization logic</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanTwo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// destruction logic</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(initMethod = &quot;init&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanOne <span class="title">beanOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BeanOne();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(destroyMethod = &quot;cleanup&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanTwo <span class="title">beanTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BeanTwo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，使用具有公共<code>close</code>或<code>shutdown</code>方法的 Java configuration 定义的 beans 将自动使用销毁回调登记。如果您有一个公共的<code>close</code>或<code>shutdown</code>方法，并且您不希望在容器关闭时调用它，则可以将<code>@Bean(destroyMethod=&quot;&quot;)</code>添加到 bean 定义以禁用默认的<code>(inferred)</code>模式。</p>
<h4 id="指定Bean范围"><a href="#指定Bean范围" class="headerlink" title="指定Bean范围"></a>指定Bean范围</h4><p>Spring 包含<code>@Scope</code> annotation，以便您可以指定 bean 的范围。</p>
<p>默认范围是<code>singleton</code>，但您可以使用<code>@Scope</code> annotation 覆盖它，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Encryptor <span class="title">encryptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring 提供了一种通过<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-other-injection">范围代理</a>处理作用域依赖项的便捷方式。使用 XML configuration 时创建此类代理的最简单方法是``元素。使用<code>@Scope</code> annotation 在 Java 中配置 beans 可提供与<code>proxyMode</code>属性的等效支持。默认值为无代理(<code>ScopedProxyMode.NO</code>)，但您可以指定<code>ScopedProxyMode.TARGET_CLASS</code>或<code>ScopedProxyMode.INTERFACES</code>。</p>
<p>如果使用 Java 将 XML 范围内的 scoped proxy example port(请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-other-injection">范围代理</a>)传递到我们的<code>@Bean</code>，它类似于以下内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// an HTTP Session-scoped bean exposed as a proxy</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@SessionScope</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserPreferences <span class="title">userPreferences</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UserPreferences();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Service <span class="title">userService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UserService service = <span class="keyword">new</span> SimpleUserService();</span><br><span class="line">    <span class="comment">// a reference to the proxied userPreferences bean</span></span><br><span class="line">    service.setUserPreferences(userPreferences());</span><br><span class="line">    <span class="keyword">return</span> service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="lt-aop-scoped-proxy-gt"><a href="#lt-aop-scoped-proxy-gt" class="headerlink" title="&lt;aop:scoped-proxy/&gt;"></a>&lt;aop:scoped-proxy/&gt;</h4><p>Spring的Bean是有scope属性的，表示bean的生存周期。scope的值有prototype、singleton、session、request。那么就有个问题了，如果一个singleton的bean中引用了一个prototype的bean，结果会怎样呢？在默认情况下，单例会永远持有一开始构造所赋给它的值。</p>
<p>所以，为了让我们在每次调用这个Bean的时候都能够得到具体scope中的值，比如prototype，那么我们希望每次在单例中调用这个Bean的时候，得到的都是一个新的prototype，Spring中AOP名字空间中引入了这个标签<strong>&lt;aop:scoped-proxy/&gt;</strong> <strong>。</strong></p>
<h4 id="自定义Bean命名"><a href="#自定义Bean命名" class="headerlink" title="自定义Bean命名"></a>自定义Bean命名</h4><p>默认情况下，configuration classes 使用<code>@Bean</code>方法的 name 作为生成的 bean 的 name。但是，使用<code>name</code>属性可以覆盖此功能，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;myThing&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thing <span class="title">thing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Bean别名"><a href="#Bean别名" class="headerlink" title="Bean别名"></a>Bean别名</h4><p><code>@Bean</code> annotation 的<code>name</code>属性接受 String array。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&#123;&quot;dataSource&quot;, &quot;subsystemA-dataSource&quot;, &quot;subsystemB-dataSource&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// instantiate, configure and return DataSource bean...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Bean描述"><a href="#Bean描述" class="headerlink" title="Bean描述"></a>Bean描述</h4><p>有时，提供 bean 的更详细的文本描述是有帮助的。当 beans 暴露(可能通过 JMX)用于监视目的时，这可能特别有用。</p>
<p>要向<code>@Bean</code>添加描述，可以使用<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/context/annotation/Description.html">@Description</a> annotation，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Description(&quot;Provides a basic example of a bean&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thing <span class="title">thing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-12-4-使用-Configuration注解"><a href="#1-12-4-使用-Configuration注解" class="headerlink" title="1.12.4.  使用@Configuration注解"></a>1.12.4.  使用@Configuration注解</h3><p><code>@Configuration</code>是 class-level annotation，表示 object 是 bean 定义的来源。</p>
<h4 id="注入Inter-bean依赖项"><a href="#注入Inter-bean依赖项" class="headerlink" title="注入Inter-bean依赖项"></a>注入Inter-bean依赖项</h4><p>当 beans 彼此依赖时，表达该依赖关系就像让一个 bean 方法调用另一个一样简单，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanOne <span class="title">beanOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BeanOne(beanTwo());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanTwo <span class="title">beanTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BeanTwo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="look-up方法注入"><a href="#look-up方法注入" class="headerlink" title="look-up方法注入"></a>look-up方法注入</h4><p>如前所述，<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-method-injection">查找方法注入</a>是一种您应该很少使用的高级 feature。在 singleton-scoped bean 依赖于 prototype-scoped bean 的情况下，它很有用。使用 Java 进行此类型的 configuration 提供了实现此 pattern 的自然方法。以下 example 显示了如何使用查找方法注入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandManager</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">process</span><span class="params">(Object commandState)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// grab a new instance of the appropriate Command interface</span></span><br><span class="line">        Command command = createCommand();</span><br><span class="line">        <span class="comment">// set the state on the (hopefully brand new) Command instance</span></span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="keyword">return</span> command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// okay... but where is the implementation of this method?</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Command <span class="title">createCommand</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过使用 Java configuration，您可以创建<code>CommandManager</code>的子类，其中抽象<code>createCommand()</code>方法被覆盖，以便查找新的(原型)命令 object。以下 example 显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AsyncCommand <span class="title">asyncCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AsyncCommand command = <span class="keyword">new</span> AsyncCommand();</span><br><span class="line">    <span class="comment">// inject dependencies here as required</span></span><br><span class="line">    <span class="keyword">return</span> command;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommandManager <span class="title">commandManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// return new anonymous implementation of CommandManager with command() overridden</span></span><br><span class="line">    <span class="comment">// to return a new prototype Command object</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CommandManager() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Command <span class="title">createCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> asyncCommand();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-12-5-撰写Java-based配置"><a href="#1-12-5-撰写Java-based配置" class="headerlink" title="1.12.5.  撰写Java-based配置"></a>1.12.5.  撰写Java-based配置</h3><h4 id="import"><a href="#import" class="headerlink" title="@import"></a>@import</h4><p>@import可以从另一个Configuration类中加载@Bean定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> A <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(ConfigA.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> B <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，在实例化 context 时，不需要同时指定<code>ConfigA.class</code>和<code>ConfigB.class</code>，只需要显式提供<code>ConfigB</code></p>
<p>这种方法简化了容器实例化，因为只需要处理一个 class，而不是要求你在构造期间记住可能大量的<code>@Configuration</code> classes。</p>
<h4 id="在导入的-Bean-定义上注入依赖项"><a href="#在导入的-Bean-定义上注入依赖项" class="headerlink" title="在导入的 @Bean 定义上注入依赖项"></a>在导入的 @Bean 定义上注入依赖项</h4><p>在大多数实际场景中，beans 在 configuration classes 之间依赖于彼此。使用 XML 时，这不是问题，因为不涉及编译器，并且您可以在容器初始化期间声明<code>ref=&quot;someBean&quot;</code>并信任 Spring 来解决它。使用<code>@Configuration</code> classes 时，Java 编译器会在 configuration model 上设置约束，因为对其他 beans 的引用必须是有效的 Java 语法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransferService <span class="title">transferService</span><span class="params">(AccountRepository accountRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl(accountRepository);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RepositoryConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AccountRepository <span class="title">accountRepository</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcAccountRepository(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(&#123;ServiceConfig.class, RepositoryConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemTestConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// return new DataSource</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(SystemTestConfig.class);</span><br><span class="line">    <span class="comment">// everything wires up across configuration classes...</span></span><br><span class="line">    TransferService transferService = ctx.getBean(TransferService.class);</span><br><span class="line">    transferService.transfer(<span class="number">100.00</span>, <span class="string">&quot;A123&quot;</span>, <span class="string">&quot;C456&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="结合-Java-和-XML-Configuration"><a href="#结合-Java-和-XML-Configuration" class="headerlink" title="结合 Java 和 XML Configuration"></a>结合 Java 和 XML Configuration</h4><p>请记住，<code>@Configuration</code> classes 最终是容器中的 bean 定义。在本系列示例中，我们创建一个名为<code>AppConfig</code>的<code>@Configuration</code> class，并将其作为``定义包含在<code>system-test-config.xml</code>中。因为<code>context:annotation-config</code>已打开，容器会识别<code>@Configuration</code> annotation 并正确处理<code>AppConfig</code>中声明的<code>@Bean</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AccountRepository <span class="title">accountRepository</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcAccountRepository(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransferService <span class="title">transferService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransferService(accountRepository());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- enable processing of annotations such as @Autowired and @Configuration --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:/com/acme/jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.acme.AppConfig&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>因为<code>@Configuration</code>是带有<code>@Component</code>的 meta-annotated，<code>@Configuration</code> -annotated classes 自动成为 component 扫描的候选者。使用与上一个 example 中描述的相同的场景，我们可以重新定义<code>system-test-config.xml</code>以利用 component-scanning。请注意，在这种情况下，我们不需要显式声明<code>context:annotation-config</code>，因为<code>context:component-scan</code>启用相同的功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportResource(&quot;classpath:/com/acme/properties-config.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DriverManagerDataSource(url, username, password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-13-环境抽象"><a href="#1-13-环境抽象" class="headerlink" title="1.13.  环境抽象"></a>1.13.  环境抽象</h2><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/core/env/Environment.html">环境</a>接口是集成在容器中的抽象，它为 application 环境的两个 key 方面建模：<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-definition-profiles">profiles</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-property-source-abstraction">properties</a>。</p>
<p>profile 是 bean 定义的命名逻辑 group，仅当给定的 profile 为 active 时才向容器注册。 Beans 可以分配给 profile，无论是用 XML 定义还是用 annotations 定义。与 profiles 相关的<code>Environment</code> object 的作用是确定哪些 profiles(如果有)当前是 active，以及哪些 profiles(如果有)默认情况下应该 active。</p>
<p>Properties 在几乎所有 applications 中都发挥着重要作用，可能来自各种来源：properties files，JVM 系统 properties，系统环境变量，JNDI，servlet context 参数，ad-hoc <code>Properties</code> objects，<code>Map</code>objects 等等。与 properties 相关的<code>Environment</code> object 的作用是为用户提供方便的服务接口，用于配置 property 源和从中解析 properties。</p>
<h3 id="1-13-1-Bean定义Profile"><a href="#1-13-1-Bean定义Profile" class="headerlink" title="1.13.1.  Bean定义Profile"></a>1.13.1.  Bean定义Profile</h3><p>Bean 定义 profiles 在核心容器中提供了一种机制，允许在不同的环境中注册不同的 beans。</p>
<p>Spring中的Profile功能其实早在Spring 3.1的版本就已经出来，它可以理解为我们在Spring容器中所定义的Bean的<strong>逻辑组名称</strong>，只有当这些Profile被激活的时候，才会将Profile中所对应的Bean注册到Spring容器中。</p>
<h4 id="使用-Profile"><a href="#使用-Profile" class="headerlink" title="使用@Profile"></a>使用@Profile</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Profile(&quot;dev&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DevConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanOne <span class="title">getBeanOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BeanOne one = <span class="keyword">new</span> BeanOne();</span><br><span class="line">        one.setName(<span class="string">&quot;devBeanOne&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> one;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@Profile(&quot;test&quot;)</span><br><span class="line">public class TestConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public BeanOne getBeanOne() &#123;</span><br><span class="line">        BeanOne one &#x3D; new BeanOne();</span><br><span class="line">        one.setName(&quot;testBeanOne&quot;);</span><br><span class="line">        return one;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>profile string 可能包含一个简单的 profile name(用于 example，<code>production</code>)或一个 profile 表达式。 profile 表达式允许表达更复杂的 profile 逻辑(对于 example，<code>production &amp; us-east</code>)。 profile 表达式支持以下 operators：</p>
<ul>
<li><code>!</code>：profile 的逻辑“not”</li>
<li><code>&amp;</code>：profiles 的逻辑“和”</li>
<li><code>|</code>：profiles 的逻辑“或”</li>
</ul>
<p>如果不使用括号，则无法混合<code>&amp;</code>和<code>|</code> 运算符。对于 example，<code>production &amp; us-east | eu-central</code>不是有效的表达式。它必须表示为<code>production &amp; (us-east | eu-central)</code>。</p>
<p>可以使用<code>@Profile</code>作为<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-meta-annotations">meta-annotation</a>来创建自定义组合注释。以下 example 定义了一个自定义<code>@Production</code> 注释，您可以将其用作<code>@Profile(&quot;production&quot;)</code>的 drop-in 替换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Profile(&quot;production&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Production &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Profile</code>也可以在 level 方法中声明，只包含 configuration class 的一个特定 bean(对于 example，对于特定 bean 的替代变体)，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;dataSource&quot;)</span></span><br><span class="line">    <span class="meta">@Profile(&quot;development&quot;)</span> (<span class="number">1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">standaloneDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder()</span><br><span class="line">            .setType(EmbeddedDatabaseType.HSQL)</span><br><span class="line">            .addScript(<span class="string">&quot;classpath:com/bank/config/sql/schema.sql&quot;</span>)</span><br><span class="line">            .addScript(<span class="string">&quot;classpath:com/bank/config/sql/test-data.sql&quot;</span>)</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;dataSource&quot;)</span></span><br><span class="line">    <span class="meta">@Profile(&quot;production&quot;)</span> (<span class="number">2</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">jndiDataSource</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Context ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">        <span class="keyword">return</span> (DataSource) ctx.lookup(<span class="string">&quot;java:comp/env/jdbc/datasource&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用@import把两个配置文件导入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(&#123;DevConfig.class, TestConfig.class&#125;)</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;hsp&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClass</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(classes &#x3D; &#123;ConfigClass.class&#125;)</span><br><span class="line">@ActiveProfiles(&quot;dev&quot;)</span><br><span class="line">public class TestAll &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private BeanOne beanOne;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testProfile() &#123;</span><br><span class="line">        System.out.println(beanOne.getName());</span><br><span class="line">        &#x2F;&#x2F;devBeanOne</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="激活Profile"><a href="#激活Profile" class="headerlink" title="激活Profile"></a>激活Profile</h4><p>激活 profile 可以通过多种方式完成，但最直接的方法是以编程方式对<code>Environment</code> API 进行编程，这可以通过<code>ApplicationContext</code>获得。以下 example 显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">ctx.getEnvironment().setActiveProfiles(<span class="string">&quot;development&quot;</span>);</span><br><span class="line">ctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);</span><br><span class="line">ctx.refresh();</span><br></pre></td></tr></table></figure>

<p>此外，您还可以通过<code>spring.profiles.active</code> property 声明性地激活 profile，这可以通过系统环境变量，<code>web.xml</code>中的 JVM 系统 properties，servlet context 参数指定，甚至可以作为 JNDI 中的条目指定(请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-property-source-abstraction">PropertySource 抽象</a>)。</p>
<h4 id="默认Profile"><a href="#默认Profile" class="headerlink" title="默认Profile"></a>默认Profile</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Profile(&quot;default&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultDataConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder()</span><br><span class="line">            .setType(EmbeddedDatabaseType.HSQL)</span><br><span class="line">            .addScript(<span class="string">&quot;classpath:com/bank/config/sql/schema.sql&quot;</span>)</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您可以使用<code>Environment</code>上的<code>setDefaultProfiles()</code>或使用<code>spring.profiles.default</code> property 声明性地更改默认 profile 的 name。</p>
<h3 id="1-13-2-PropertySource抽象"><a href="#1-13-2-PropertySource抽象" class="headerlink" title="1.13.2.  PropertySource抽象"></a>1.13.2.  PropertySource抽象</h3><p>Spring 的<code>Environment</code>抽象提供了 property 源的可配置层次结构上的搜索操作。请考虑以下列表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx = <span class="keyword">new</span> GenericApplicationContext();</span><br><span class="line">Environment env = ctx.getEnvironment();</span><br><span class="line"><span class="keyword">boolean</span> containsMyProperty = env.containsProperty(<span class="string">&quot;my-property&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Does my environment contain the &#x27;my-property&#x27; property? &quot;</span> + containsMyProperty);</span><br></pre></td></tr></table></figure>

<p>在前面的代码片段中，我们看到 high-level 方式询问 Spring 是否为当前环境定义了<code>my-property</code> property。要回答这个问题，<code>Environment</code> object 会对一组<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/core/env/PropertySource.html">PropertySource</a> objects 执行搜索。 <code>PropertySource</code>是对 key-value 对的任何源的简单抽象，Spring 的<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/core/env/StandardEnvironment.html">StandardEnvironment</a>配置有两个 PropertySource objects - 一个表示 JVM 系统 properties(<code>System.getProperties()</code>)的集合，另一个表示系统环境变量集(<code>System.getenv()</code>)。</p>
<h3 id="1-13-3-使用-PropertySource"><a href="#1-13-3-使用-PropertySource" class="headerlink" title="1.13.3.  使用@PropertySource"></a>1.13.3.  使用@PropertySource</h3><p>新建一个app.properties</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testbean.name&#x3D;BeanOne</span><br></pre></td></tr></table></figure>

<p>配置类ConfigClass.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:app.properties&quot;)</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;hsp&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClass</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Environment env;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;one&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanOne <span class="title">getBeanOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BeanOne one = <span class="keyword">new</span> BeanOne();</span><br><span class="line">        one.setName(env.getProperty(<span class="string">&quot;testbean.name&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> one;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = &#123;ConfigClass.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAll</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;one&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> BeanOne beanOne;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testProfile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(beanOne.getName());</span><br><span class="line">        <span class="comment">//BeanOne</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-13-4-Statements-中的占位符解析"><a href="#1-13-4-Statements-中的占位符解析" class="headerlink" title="1.13.4.  Statements 中的占位符解析"></a>1.13.4.  Statements 中的占位符解析</h3><h2 id="1-14-注册-LoadTimeWeaver"><a href="#1-14-注册-LoadTimeWeaver" class="headerlink" title="1.14.  注册 LoadTimeWeaver"></a>1.14.  注册 LoadTimeWeaver</h2><p>用于在 classes 加载到 Java 虚拟机(JVM)时动态转换 class。</p>
<p>要启用 load-time 编织，您可以将<code>@EnableLoadTimeWeaving</code>添加到一个<code>@Configuration</code> classes 中，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableLoadTimeWeaving</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者，对于 XML configuration，您可以使用<code>context:load-time-weaver</code>元素：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:load-time-weaver</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>一旦为<code>ApplicationContext</code>配置，该<code>ApplicationContext</code>中的任何 bean 都可以实现<code>LoadTimeWeaverAware</code>，从而接收 load-time weaver 实例的 reference。这与<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#orm-jpa">Spring 的 JPA 支持</a>结合使用特别有用，其中 load-time 编织可能是 JPA class 转换所必需的。有关更多详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/orm/jpa/LocalContainerEntityManagerFactoryBean.html">LocalContainerEntityManagerFactoryBean</a> javadoc。有关 AspectJ load-time 编织的更多信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-aj-ltw">Load-time 在 Spring Framework 中使用 AspectJ 进行编织</a>。</p>
<h2 id="1-15-ApplicationContext-的附加功能"><a href="#1-15-ApplicationContext-的附加功能" class="headerlink" title="1.15.  ApplicationContext 的附加功能"></a>1.15.  ApplicationContext 的附加功能</h2><h3 id="1-15-1-使用-MessageSource-进行国际化"><a href="#1-15-1-使用-MessageSource-进行国际化" class="headerlink" title="1.15.1.  使用 MessageSource 进行国际化"></a>1.15.1.  使用 MessageSource 进行国际化</h3><p><code>ApplicationContext</code>接口扩展了一个名为<code>MessageSource</code>的接口，因此提供了国际化(“i18n”)功能。 Spring 还提供<code>HierarchicalMessageSource</code>接口，可以分层次地解析消息。这些接口共同提供了 Spring 效果消息解析的基础。这些接口上定义的方法包括：</p>
<ul>
<li><code>String getMessage(String code, Object[] args, String default, Locale loc)</code>：用于从<code>MessageSource</code>检索消息的基本方法。如果未找到指定 locale 的消息，则使用默认消息。传入的任何 arguments 都使用标准 library 提供的<code>MessageFormat</code>功能成为替换值。</li>
<li><code>String getMessage(String code, Object[] args, Locale loc)</code>：与前一个方法基本相同，但有一点不同：无法指定默认消息。如果找不到该消息，则抛出<code>NoSuchMessageException</code>。</li>
<li><code>String getMessage(MessageSourceResolvable resolvable, Locale locale)</code>：前面方法中使用的所有 properties 也包装在一个名为<code>MessageSourceResolvable</code>的 class 中，您可以使用此方法。</li>
</ul>
<h3 id="1-15-2-标准和自定义事件"><a href="#1-15-2-标准和自定义事件" class="headerlink" title="1.15.2.  标准和自定义事件"></a>1.15.2.  标准和自定义事件</h3><p>通过<code>ApplicationEvent</code> class 和<code>ApplicationListener</code>接口提供<code>ApplicationContext</code>中的 Event 处理。如果实现<code>ApplicationListener</code>接口的 bean 被部署到 context 中，那么每次Bean被发布到<code>ApplicationContext</code>都会收到通知。</p>
<p>以下 table 描述了 Spring 提供的标准 events：</p>
<table>
<thead>
<tr>
<th align="left">事件</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>ContextRefreshedEvent</code></td>
<td align="left">初始化或刷新<code>ApplicationContext</code>时发布(例如，通过<code>ConfigurableApplicationContext</code>接口使用<code>refresh()</code>方法)。这里，“初始化”意味着所有 beans 都被加载，post-processor beans 被检测并激活，单例是 pre-instantiated，<code>ApplicationContext</code>object 可以使用了。如果 context 尚未关闭，则可以多次触发刷新，前提是所选的<code>ApplicationContext</code>实际上支持这种“热”刷新。例如，<code>XmlWebApplicationContext</code>支持热刷新，但<code>GenericApplicationContext</code>不支持。</td>
</tr>
<tr>
<td align="left"><code>ContextStartedEvent</code></td>
<td align="left">通过在<code>ConfigurableApplicationContext</code>接口上使用<code>start()</code>方法启动<code>ApplicationContext</code>时发布。这里，“已启动”意味着所有<code>Lifecycle</code> beans 都会收到明确的启动信号。通常，此信号用于在显式停止后重新启动 beans，但它也可用于启动尚未为自动启动配置的组件(对于 example，尚未在初始化时启动的组件)。</td>
</tr>
<tr>
<td align="left"><code>ContextStoppedEvent</code></td>
<td align="left">通过在<code>ConfigurableApplicationContext</code>接口上使用<code>stop()</code>方法停止<code>ApplicationContext</code>时发布。这里，“停止”意味着所有<code>Lifecycle</code> beans 都会收到明确的停止信号。可以通过<code>start()</code>调用重新启动已停止的 context。</td>
</tr>
<tr>
<td align="left"><code>ContextClosedEvent</code></td>
<td align="left">通过在<code>ConfigurableApplicationContext</code>接口上使用<code>close()</code>方法关闭<code>ApplicationContext</code>时发布。在这里，“关闭”意味着所有 singleton beans 都被销毁。封闭的 context 到达其生命的终点。它无法刷新或重新启动。</td>
</tr>
<tr>
<td align="left"><code>RequestHandledEvent</code></td>
<td align="left">web-specific event 告诉所有 beans 已经为 HTTP 请求提供服务。请求完成后发布此 event。此 event 仅适用于使用 Spring 的<code>DispatcherServlet</code>的 web applications。</td>
</tr>
</tbody></table>
<p>自定义一个需要监听的Event</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplicationEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object source;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSource</span><span class="params">(Object source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.source = source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTest</span><span class="params">(String test)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.test = test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> String test;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyApplicationEvent</span><span class="params">(Object source, String address, String test)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">        <span class="keyword">this</span>.test = test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MyApplicationEvent&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;source=&quot;</span> + source +</span><br><span class="line">                <span class="string">&quot;, address=&#x27;&quot;</span> + address + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, test=&#x27;&quot;</span> + test + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想要发布我们的自定义事件,就需要调用ApplicationEventPublisher类中的publishEvent()方法 。官方文档中是叫我们创建一个实现ApplicationEventPublisherAware的类，并且注册为spring中的bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplicationEventService</span> <span class="keyword">implements</span> <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; blackList;</span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher publisher;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher applicationEventPublisher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.publisher = applicationEventPublisher;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">(String address, String text)</span> </span>&#123;</span><br><span class="line">        blackList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        blackList.add(<span class="string">&quot;111111@qq.com&quot;</span>);</span><br><span class="line">        blackList.add(<span class="string">&quot;123@cc.com&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (blackList.contains(address)) &#123;</span><br><span class="line">            publisher.publishEvent(<span class="keyword">new</span> MyApplicationEvent(<span class="keyword">this</span>, address, text));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testListener</span><span class="params">(String address, String text)</span> </span>&#123;</span><br><span class="line">        MyApplicationEvent event = <span class="keyword">new</span> MyApplicationEvent(<span class="keyword">this</span>, address, text);</span><br><span class="line">        publisher.publishEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在配置的时候，Spring容器会检测到这个MyApplicationEventService实现 ApplicationEventPublisherAware并自动调用 setApplicationEventPublisher()。实际上，传入的参数将是Spring容器本身; 您只需通过其ApplicationEventPublisher接口与应用程序上下文进行 交互。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplicationListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">MyApplicationEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(MyApplicationEvent myApplicationEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;my listener start&quot;</span>);</span><br><span class="line">        System.out.println(myApplicationEvent.toString());</span><br><span class="line">        System.out.println(<span class="string">&quot;my listener end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="基于注解的时间监听器"><a href="#基于注解的时间监听器" class="headerlink" title="基于注解的时间监听器"></a>基于注解的时间监听器</h4><p>基于注解的话，Listener不需要实现接口，只需要注解就可以</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplicationListener</span></span>&#123;</span><br><span class="line">    <span class="meta">@EventListener(MyApplicationEvent.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(MyApplicationEvent myApplicationEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;my listener start&quot;</span>);</span><br><span class="line">        System.out.println(myApplicationEvent.toString());</span><br><span class="line">        System.out.println(<span class="string">&quot;my listener end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以加上判断条件，如果条件不成立，不会调用该listener。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplicationListener</span></span>&#123;</span><br><span class="line">    <span class="meta">@EventListener(value = MyApplicationEvent.class, condition = &quot;#event.test==&#x27;hi&#x27;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(MyApplicationEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;my listener start&quot;</span>);</span><br><span class="line">        System.out.println(event.toString());</span><br><span class="line">        System.out.println(<span class="string">&quot;my listener end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="异步Listeners"><a href="#异步Listeners" class="headerlink" title="异步Listeners"></a>异步Listeners</h4><p>如果希望特定的Listener异步处理events，则可以用@Async</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplicationListener</span></span>&#123;</span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(MyApplicationEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;my listener start&quot;</span>);</span><br><span class="line">        System.out.println(event.toString());</span><br><span class="line">        System.out.println(<span class="string">&quot;my listener end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用异步 events 时请注意以下限制：</p>
<ul>
<li>如果 event listener 抛出<code>Exception</code>，则它不会传播给调用者有关详细信息，请参阅<code>AsyncUncaughtExceptionHandler</code>。</li>
<li>这样的 event listener 无法发送回复。如果您需要作为处理结果发送另一个 event，inject <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/aop/interceptor/AsyncUncaughtExceptionHandler.html">ApplicationEventPublisher</a>手动发送 event。</li>
</ul>
<h4 id="给listener定义顺序"><a href="#给listener定义顺序" class="headerlink" title="给listener定义顺序"></a>给listener定义顺序</h4><p>如果需要在另一个 listener 之前调用一个 listener，可以将<code>@Order</code> annotation 添加到方法声明中，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EventListener</span></span><br><span class="line"><span class="meta">@Order(42)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processBlackListEvent</span><span class="params">(BlackListEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// notify appropriate parties via notificationAddress...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="泛型化Events"><a href="#泛型化Events" class="headerlink" title="泛型化Events"></a>泛型化Events</h4><p>您还可以使用泛型来进一步定义 event 的结构。考虑使用<code>EntityCreatedEvent</code>，其中<code>T</code>是创建的实际实体的类型。对于 example，您可以创建以下 listener 定义以仅接收<code>EntityCreatedEvent</code>的<code>EntityCreatedEvent</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EventListener</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPersonCreated</span><span class="params">(EntityCreatedEvent&lt;Person&gt; event)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于类型擦除，仅当被触发的 event 解析 event listener 过滤器的通用参数(即<code>class PersonCreatedEvent extends EntityCreatedEvent &#123; … &#125;</code>之类的东西)时，此方法才有效。</p>
<h3 id="1-15-3-方便的访问Low-level资源"><a href="#1-15-3-方便的访问Low-level资源" class="headerlink" title="1.15.3.  方便的访问Low-level资源"></a>1.15.3.  方便的访问Low-level资源</h3><p>application context 是<code>ResourceLoader</code>，可用于加载<code>Resource</code> objects。</p>
<p>您可以配置部署到 application context 中的 bean 来实现特殊的回调接口<code>ResourceLoaderAware</code>，在初始化时自动回调，application context 本身作为<code>ResourceLoader</code>传入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyResourceLoader</span> <span class="keyword">implements</span> <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ResourceLoader loader;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Set resource Loader&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.loader = resourceLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-16-BeanFactory"><a href="#1-16-BeanFactory" class="headerlink" title="1.16.  BeanFactory"></a>1.16.  BeanFactory</h2><p><code>BeanFactory</code> API 为 Spring 的 IoC 功能提供了基础。它主要用于与 Spring 和相关 third-party 框架的其他部分进行整合，其<code>DefaultListableBeanFactory</code>实现是 higher-level <code>GenericApplicationContext</code>容器中的 key 委托。</p>
<p><code>BeanFactory</code>和相关接口(例如<code>BeanFactoryAware</code>，<code>InitializingBean</code>，<code>DisposableBean</code>)是其他 framework 组件的重要集成点。通过不需要任何注释或甚至反射，它们允许容器与其组件之间的非常有效的交互。 Application-level beans 可以使用相同的回调接口，但通常更推荐声明性依赖注入，通过 annotations 或通过编程 configuration。</p>
<p>请注意，核心<code>BeanFactory</code> API level 及其<code>DefaultListableBeanFactory</code> implementation 不会对 configuration 格式或要使用的任何 component annotations 进行假设。所有这些风格都通过 extensions(例如<code>XmlBeanDefinitionReader</code>和<code>AutowiredAnnotationBeanPostProcessor</code>)进入，并作为核心元数据表示在共享<code>BeanDefinition</code> objects 上运行。这就是 Spring 容器如此灵活和可扩展的本质。</p>
<h3 id="1-16-1-BeanFactory或ApplicationContext"><a href="#1-16-1-BeanFactory或ApplicationContext" class="headerlink" title="1.16.1.  BeanFactory或ApplicationContext"></a>1.16.1.  BeanFactory或ApplicationContext</h3><p>您应该使用<code>ApplicationContext</code>，除非您有充分的理由不这样做，<code>GenericApplicationContext</code>及其子类<code>AnnotationConfigApplicationContext</code>作为自定义引导的 common implementations。这些是 Spring 核心容器的主要入口点，适用于所有 common 目的：加载配置文件，触发 classpath 扫描，以编程方式注册 bean 定义和带注释的 classes，以及(截至 5.0)注册功能 bean 定义。</p>
<h1 id="2-资源"><a href="#2-资源" class="headerlink" title="2.资源"></a>2.资源</h1><p>本章介绍 Spring 如何处理资源以及如何使用 Spring 中的资源。它包括以下主题：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources-introduction">介绍</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources-resource">资源接口</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources-implementations">Built-in 资源 Implementations</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources-resourceloader">ResourceLoader</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources-resourceloaderaware">ResourceLoaderAware 接口</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources-as-dependencies">资源作为依赖关系</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources-app-ctx">Application Contexts 和 Resource Paths</a></li>
</ul>
<h2 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1.  介绍"></a>2.1.  介绍</h2><p>Java 的标准<code>java.net.URL</code> class 和各种 URL 前缀的标准处理程序不足以完全访问 low-level 资源。</p>
<h2 id="2-2-资源接口"><a href="#2-2-资源接口" class="headerlink" title="2.2.  资源接口"></a>2.2.  资源接口</h2><p>Spring 的<code>Resource</code>接口是一个更强大的接口，用于抽象对 low-level 资源的访问。以下清单显示了<code>Resource</code>接口定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Resource</span> <span class="keyword">extends</span> <span class="title">InputStreamSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">exists</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">URL <span class="title">getURL</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">File <span class="title">getFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Resource <span class="title">createRelative</span><span class="params">(String relativePath)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getFilename</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正如<code>Resource</code>接口的定义所示，它扩展了<code>InputStreamSource</code>接口。以下清单显示了<code>InputStreamSource</code>接口的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InputStreamSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-内建Resource的实现类"><a href="#2-3-内建Resource的实现类" class="headerlink" title="2.3.  内建Resource的实现类"></a>2.3.  内建Resource的实现类</h2><p>Spring 包括以下<code>Resource</code> implementations：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources-implementations-urlresource">UrlResource 对象</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources-implementations-classpathresource">使用 ClassPathResource</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources-implementations-filesystemresource">FileSystemResource</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources-implementations-servletcontextresource">ServletContextResource</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources-implementations-inputstreamresource">InputStreamResource</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources-implementations-bytearrayresource">使用 ByteArrayResource</a></li>
</ul>
<h3 id="2-3-1-UrlResource对象"><a href="#2-3-1-UrlResource对象" class="headerlink" title="2.3.1.  UrlResource对象"></a>2.3.1.  UrlResource对象</h3><p><code>UrlResource</code>包装<code>java.net.URL</code>，可用于访问通常可通过 URL 访问的任何 object，例如 files，HTTP 目标，FTP 目标等。所有 URL 都具有标准化的<code>String</code>表示，使得适当的标准化前缀用于指示来自另一个的一种 URL 类型。这包括<code>file:</code>用于访问文件系统path，<code>http:</code>用于通过 HTTP 协议访问资源，<code>ftp:</code>用于通过 FTP 访问资源</p>
<p>如果路径 string 包含已知前缀(例如<code>classpath:</code>)，它会为该前缀创建一个适当的专用<code>Resource</code>。但是，如果它不识别前缀，则假定 string 是标准 URL string 并创建<code>UrlResource</code>。</p>
<h3 id="2-3-2-使用ClassPathResource"><a href="#2-3-2-使用ClassPathResource" class="headerlink" title="2.3.2.  使用ClassPathResource"></a>2.3.2.  使用ClassPathResource</h3><p>JavaBeans <code>PropertyEditor</code>在 string 路径上识别特殊前缀<code>classpath:</code>，并在这种情况下创建<code>ClassPathResource</code>。</p>
<h3 id="2-3-3-FileSystemResource"><a href="#2-3-3-FileSystemResource" class="headerlink" title="2.3.3.  FileSystemResource"></a>2.3.3.  FileSystemResource</h3><p>这是<code>java.io.File</code>和<code>java.nio.file.Path</code>句柄的<code>Resource</code> implementation。它支持分辨率为<code>File</code>和<code>URL</code>。</p>
<h3 id="2-3-4-ServletContext"><a href="#2-3-4-ServletContext" class="headerlink" title="2.3.4.  ServletContext"></a>2.3.4.  ServletContext</h3><p>用于解释相关 web application 根目录中的相对路径。</p>
<p>它始终支持流访问和 URL 访问，但只有在扩展 web application 存档且资源实际位于文件系统上时才允许<code>java.io.File</code>访问。无论它是在文件系统上扩展还是直接从 JAR 或其他地方(如数据库)(可以想象)访问它实际上都依赖于 Servlet 容器。</p>
<h3 id="2-3-5-InputStreamResource"><a href="#2-3-5-InputStreamResource" class="headerlink" title="2.3.5.  InputStreamResource"></a>2.3.5.  InputStreamResource</h3><p><code>InputStreamResource</code>是给定<code>InputStream</code>的<code>Resource</code> implementation。只有在没有特定的<code>Resource</code> implementation 适用时才应该使用它。特别是，在可能的情况下，首选<code>ByteArrayResource</code>或任何 file-based <code>Resource</code> implement。</p>
<h3 id="2-3-6-ByteArrayResource"><a href="#2-3-6-ByteArrayResource" class="headerlink" title="2.3.6.  ByteArrayResource"></a>2.3.6.  ByteArrayResource</h3><p>这是给定字节 array 的<code>Resource</code> implementation。它为给定的字节 array 创建<code>ByteArrayInputStream</code>。</p>
<p>它对于从任何给定的字节 array 中加载内容非常有用，而不必求助于 single-use <code>InputStreamResource</code>。</p>
<h2 id="2-4-ResourceLoader"><a href="#2-4-ResourceLoader" class="headerlink" title="2.4.  ResourceLoader"></a>2.4.  ResourceLoader</h2><p><code>ResourceLoader</code>接口应由 objects 实现，它可以 return(即加载)<code>Resource</code>实例。以下清单显示了<code>ResourceLoader</code>接口定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResourceLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Resource <span class="title">getResource</span><span class="params">(String location)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有 application 上下文都实现了<code>ResourceLoader</code>接口。因此，所有 application 上下文都可用于获取<code>Resource</code>实例。</p>
<p>当您在特定的 application context 上调用<code>getResource()</code>，并且指定的位置路径没有特定的前缀时，您将返回适合该特定 application context 的<code>Resource</code>类型</p>
<p>可以通过指定特殊的<code>classpath:</code>前缀来强制使用<code>ClassPathResource</code>，</p>
<p>可以通过指定任何标准<code>java.net.URL</code>前缀来强制使用<code>UrlResource</code>。</p>
<h2 id="2-5-ResourceLoaderAware接口"><a href="#2-5-ResourceLoaderAware接口" class="headerlink" title="2.5.  ResourceLoaderAware接口"></a>2.5.  ResourceLoaderAware接口</h2><p><code>ResourceLoaderAware</code>接口是一个特殊的标记接口，用于标识期望提供<code>ResourceLoader</code> reference 的 objects。以下清单显示了<code>ResourceLoaderAware</code>接口的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 class 实现<code>ResourceLoaderAware</code>并部署到 application context(作为 Spring-managed bean)时，application context 将其识别为<code>ResourceLoaderAware</code>。然后 application context 调用<code>setResourceLoader(ResourceLoader)</code>，将自身作为参数提供(请记住，Spring 中的所有 application 上下文都实现了<code>ResourceLoader</code>接口)。</p>
<p>也可以使用自动装配把ResourceLoader注入而不用实现ResourceLoaderAware。</p>
<h2 id="2-6-资源作为依赖关系"><a href="#2-6-资源作为依赖关系" class="headerlink" title="2.6.  资源作为依赖关系"></a>2.6.  资源作为依赖关系</h2><p>注入这些 properties 的重要性在于所有 application 上下文都注册并使用特殊的 JavaBeans <code>PropertyEditor</code>，它可以将<code>String</code> _path 转换为<code>Resource</code> objects。因此，如果<code>myBean</code>具有<code>Resource</code>类型的模板 property，则可以为该资源配置一个简单的 string，如下面的 example 所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;template&quot;</span> <span class="attr">value</span>=<span class="string">&quot;some/resource/path/myTemplate.txt&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>请注意，资源路径没有前缀。因此，因为 application context 本身将用作<code>ResourceLoader</code>，所以资源本身通过<code>ClassPathResource</code>，<code>FileSystemResource</code>或<code>ServletContextResource</code>加载，具体取决于 context 的确切类型。</p>
<p>如果需要强制使用特定的<code>Resource</code>类型，则可以使用前缀。</p>
<h2 id="2-7-Application-Contexts和Resource-Paths"><a href="#2-7-Application-Contexts和Resource-Paths" class="headerlink" title="2.7.  Application Contexts和Resource Paths"></a>2.7.  Application Contexts和Resource Paths</h2><h3 id="2-7-1-构建ApplicationContext"><a href="#2-7-1-构建ApplicationContext" class="headerlink" title="2.7.1.  构建ApplicationContext"></a>2.7.1.  构建ApplicationContext</h3><p>applicationContext构造函数的参数主要使用String或者Array。</p>
<h4 id="构造-ClassPathXmlApplicationContext-实例"><a href="#构造-ClassPathXmlApplicationContext-实例" class="headerlink" title="构造 ClassPathXmlApplicationContext 实例"></a>构造 ClassPathXmlApplicationContext 实例</h4><p>请考虑以下目录布局：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">com/</span><br><span class="line">  foo/</span><br><span class="line">    services.xml</span><br><span class="line">    daos.xml</span><br><span class="line">    MessengerService.class</span><br></pre></td></tr></table></figure>

<p>以下 example 显示了如何实例化<code>ClassPathXmlApplicationContext</code>实例，该实例由 files 中定义的名为<code>services.xml</code>和<code>daos.xml</code>(位于 classpath 上)的 beans 组成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(</span><br><span class="line">    <span class="keyword">new</span> String[] &#123;<span class="string">&quot;services.xml&quot;</span>, <span class="string">&quot;daos.xml&quot;</span>&#125;, MessengerService.class);</span><br></pre></td></tr></table></figure>

<h3 id="2-7-2-ApplicationContext构造函数资源Paths中的通配符"><a href="#2-7-2-ApplicationContext构造函数资源Paths中的通配符" class="headerlink" title="2.7.2.  ApplicationContext构造函数资源Paths中的通配符"></a>2.7.2.  ApplicationContext构造函数资源Paths中的通配符</h3><h4 id="Ant-style模式"><a href="#Ant-style模式" class="headerlink" title="Ant-style模式"></a>Ant-style模式</h4><p>路径位置可以包含 Ant-style 模式，如下面的示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/WEB-INF<span class="comment">/*-context.xml</span></span><br><span class="line"><span class="comment">com/mycompany/**/</span>applicationContext.xml</span><br><span class="line">file:C:/some/path<span class="comment">/*-context.xml</span></span><br><span class="line"><span class="comment">classpath:com/mycompany/**/</span>applicationContext.xml</span><br></pre></td></tr></table></figure>

<p>当路径位置包含 Ant-style pattern 时，解析程序遵循更复杂的过程来尝试解析通配符。它为直到最后 non-wildcard 段的路径生成<code>Resource</code>并从中获取 URL。如果此 URL 不是<code>jar:</code> URL 或 container-specific 变体(例如 WebLogic 中的<code>zip:</code>，WebSphere 中的<code>wsjar</code>等)，则从中获取<code>java.io.File</code>并用于通过遍历文件系统来解析通配符。对于 jar:URL，解析器从中获取<code>java.net.JarURLConnection</code>或手动解析 jar:URL，然后遍历 jar 文件的内容以解析通配符。</p>
<h4 id="classpath-前缀"><a href="#classpath-前缀" class="headerlink" title="classpath*:前缀"></a>classpath*:前缀</h4><p>构造 XML-based application context 时，位置 string 可以使用特殊的<code>classpath*:</code>前缀，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx =</span><br><span class="line">    <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;classpath*:conf/appContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>此特殊前缀指定必须获取 match 给定 name 的所有 classpath 资源(内部，这通常通过调用<code>ClassLoader.getResources(…)</code>)然后合并以形成最终的 application context 定义。</p>
<p>您还可以将<code>classpath*:</code>前缀与<code>PathMatcher</code> pattern 组合在位置路径的 rest 中(对于 example，<code>classpath*:META-INF/*-beans.xml</code>)。在这种情况下，解析策略非常简单：在最后一个 non-wildcard 路径段上使用<code>ClassLoader.getResources()</code>调用来获取 class 加载器层次结构中的所有匹配资源，然后，在每个资源之外，使用前面描述的相同的<code>PathMatcher</code>解析策略通配符子路径。</p>
<h3 id="2-7-3-FileSystemResource警告"><a href="#2-7-3-FileSystemResource警告" class="headerlink" title="2.7.3.  FileSystemResource警告"></a>2.7.3.  FileSystemResource警告</h3><p>但是，出于向后兼容性(历史)的原因，当<code>FileSystemApplicationContext</code>是<code>ResourceLoader</code>时，这会发生变化。 <code>FileSystemApplicationContext</code>强制所有附加的<code>FileSystemResource</code>实例将所有位置 paths 视为相对的，无论它们是否以前导斜杠开头。实际上，这意味着以下示例是等效的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx =</span><br><span class="line">    <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">&quot;conf/context.xml&quot;</span>);</span><br><span class="line">ApplicationContext ctx =</span><br><span class="line">    <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">&quot;/conf/context.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>实际上，如果需要 true 绝对文件系统 paths，则应避免对<code>FileSystemResource</code>或<code>FileSystemXmlApplicationContext</code>使用绝对路径，并使用<code>file:</code> URL 前缀强制使用<code>UrlResource</code>。以下示例显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// actual context type doesn&#x27;t matter, the Resource will always be UrlResource</span></span><br><span class="line">ctx.getResource(<span class="string">&quot;file:///some/resource/path/myTemplate.txt&quot;</span>);</span><br><span class="line"><span class="comment">// force this FileSystemXmlApplicationContext to load its definition via a UrlResource</span></span><br><span class="line">ApplicationContext ctx =</span><br><span class="line">    <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">&quot;file:///conf/context.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="3-验证、数据绑定和类型转换"><a href="#3-验证、数据绑定和类型转换" class="headerlink" title="3.  验证、数据绑定和类型转换"></a>3.  验证、数据绑定和类型转换</h1><p>Spring 已经提出了一个<code>Validator</code>接口，它在 application 的每一层都是基本的，非常有用。</p>
<p>数据 binding 对于让用户输入动态绑定到 application 的域 model(或用于 process 用户输入的任何 objects)非常有用。 Spring 提供恰当的名称<code>DataBinder</code>来做到这一点。 <code>Validator</code>和<code>DataBinder</code>组成<code>validation</code>包，主要用于但不限于 MVC framework。</p>
<h2 id="3-1-使用Spring的验证器接口进行验证"><a href="#3-1-使用Spring的验证器接口进行验证" class="headerlink" title="3.1.  使用Spring的验证器接口进行验证"></a>3.1.  使用Spring的验证器接口进行验证</h2><p>Validator接口可以用于验证objects。</p>
<p><code>Validator</code>接口使用<code>Errors</code> object 工作，以便在验证时，验证程序可以向<code>Errors</code> object 报告验证失败。</p>
<h2 id="3-2-将代码解析为错误信息"><a href="#3-2-将代码解析为错误信息" class="headerlink" title="3.2.  将代码解析为错误信息"></a>3.2.  将代码解析为错误信息</h2><h2 id="3-3-Bean-操作和-BeanWrapper"><a href="#3-3-Bean-操作和-BeanWrapper" class="headerlink" title="3.3.  Bean 操作和 BeanWrapper"></a>3.3.  Bean 操作和 BeanWrapper</h2><p><code>org.springframework.beans</code>包遵循 JavaBeans 标准。 JavaBean 是一个具有默认 no-argument 构造函数的 class，它遵循命名约定，其中(对于 example)名为<code>bingoMadness</code>的 property 将具有 setter 方法<code>setBingoMadness(..)</code>和 getter 方法<code>getBingoMadness()</code>。</p>
<p>beans 包中一个非常重要的 class 是<code>BeanWrapper</code>接口及其相应的 implementation(<code>BeanWrapperImpl</code>)。从 javadoc 引用，<code>BeanWrapper</code>提供了设置和获取 property 值(单独或批量)，获取 property 描述符和查询 properties 以确定它们是可读还是可写的功能。此外，<code>BeanWrapper</code>提供对嵌套 properties 的支持，使 sub-properties 上的 properties 设置为无限深度。 <code>BeanWrapper</code>还支持添加标准 JavaBeans <code>PropertyChangeListeners</code>和<code>VetoableChangeListeners</code>的功能，而无需在目标 class 中支持 code。最后但并非最不重要的是，<code>BeanWrapper</code>提供了对设置索引 properties 的支持。 <code>BeanWrapper</code>通常不直接由 application code 使用，但由<code>DataBinder</code>和<code>BeanFactory</code>使用。</p>
<p><code>BeanWrapper</code>的工作方式部分由 name 表示：它包装 bean 以对该 bean 执行操作，例如设置和检索 properties。</p>
<h3 id="3-3-1-设置和获取基本和嵌套的Properties"><a href="#3-3-1-设置和获取基本和嵌套的Properties" class="headerlink" title="3.3.1.  设置和获取基本和嵌套的Properties"></a>3.3.1.  设置和获取基本和嵌套的Properties</h3><p>设置和获取 properties 是通过使用带有几个重载变体的<code>setPropertyValue</code>，<code>setPropertyValues</code>，<code>getPropertyValue</code>和<code>getPropertyValues</code>方法完成的。</p>
<table>
<thead>
<tr>
<th align="left">表达</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>name</code></td>
<td align="left">表示 property <code>name</code>，对应于<code>getName()</code>或<code>isName()</code>和<code>setName(..)</code>方法。</td>
</tr>
<tr>
<td align="left"><code>account.name</code></td>
<td align="left">指示 property <code>account</code>的嵌套 property <code>name</code>，它对应于(对于 example)<code>getAccount().setName()</code>或<code>getAccount().getName()</code>方法。</td>
</tr>
<tr>
<td align="left"><code>account[2]</code></td>
<td align="left">表示索引 property <code>account</code>的第三个元素。索引的 properties 可以是<code>array</code>，<code>list</code>或其他自然排序的集合。</td>
</tr>
<tr>
<td align="left"><code>account[COMPANYNAME]</code></td>
<td align="left">表示由<code>account</code> <code>Map</code> property 的<code>COMPANYNAME</code> key 索引的 map 条目的 value。</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        BeanWrapper wrapper = <span class="keyword">new</span> BeanWrapperImpl(p);</span><br><span class="line">        wrapper.setPropertyValue(<span class="string">&quot;address&quot;</span>, <span class="keyword">new</span> Address());</span><br><span class="line">        wrapper.setPropertyValue(<span class="string">&quot;address.addr&quot;</span>, <span class="string">&quot;treet 1&quot;</span>);</span><br><span class="line">        wrapper.setPropertyValue(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hsp&quot;</span>);</span><br><span class="line">        wrapper.setPropertyValue(<span class="string">&quot;age&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-2-内建的PropertyEditor实现类"><a href="#3-3-2-内建的PropertyEditor实现类" class="headerlink" title="3.3.2.  内建的PropertyEditor实现类"></a>3.3.2.  内建的PropertyEditor实现类</h3><p>Spring 使用<code>PropertyEditor</code>的概念来实现<code>Object</code>和<code>String</code>之间的转换。以与 object 本身不同的方式表示 properties 是很方便的。例如，<code>Date</code>可以用人类可读的方式表示(如<code>String</code>：<code>&#39;2007-14-09&#39;</code>)，而我们仍然可以将人类可读的表单转换回原始 date(或者更好的是，转换以人类可读形式输入的任何 date 回到<code>Date</code> objects)。通过注册<code>java.beans.PropertyEditor</code>类型的自定义编辑器可以实现此行为。在<code>BeanWrapper</code>上注册自定义编辑器，或者在特定的 IoC 容器中注册(如上一章所述)，使其了解如何将 properties 转换为所需的类型。</p>
<p>在 Spring 中使用 property 编辑的几个示例：</p>
<ul>
<li>在 beans 上设置 properties 是通过使用<code>PropertyEditor</code> implementations 完成的。当您使用<code>java.lang.String</code>作为在 XML 文件中声明的某些 bean 的 property 的 value 时，Spring(如果相应 property 的 setter 具有<code>Class</code>参数)使用<code>ClassEditor</code>尝试将参数解析为<code>Class</code> object。</li>
<li>在 Spring 的 MVC framework 中解析 HTTP 请求参数是通过使用所有类型的<code>PropertyEditor</code> implement 来完成的，您可以在<code>CommandController</code>的所有子类中手动绑定。</li>
</ul>
<p>Spring 有许多 built-in <code>PropertyEditor</code> implementations 让生活变得轻松。它们都位于<code>org.springframework.beans.propertyeditors</code>包中。大多数(但不是全部，如下面的 table 所示)默认情况下由<code>BeanWrapperImpl</code>注册。如果 property 编辑器可以某种方式配置，您仍然可以注册自己的变体来覆盖默认变体。以下 table 描述了 Spring 提供的各种<code>PropertyEditor</code> implement：</p>
<table>
<thead>
<tr>
<th align="left">类</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>ByteArrayPropertyEditor</code></td>
<td align="left">字节数组的编辑器。将 strings 转换为其对应的字节表示形式。默认情况下由<code>BeanWrapperImpl</code>注册。</td>
</tr>
<tr>
<td align="left"><code>ClassEditor</code></td>
<td align="left">解析 strings 表示 classes 到实际的 classes 和 vice-versa。如果找不到 class，则抛出<code>IllegalArgumentException</code>。默认情况下，由<code>BeanWrapperImpl</code>注册。</td>
</tr>
<tr>
<td align="left"><code>CustomBooleanEditor</code></td>
<td align="left"><code>Boolean</code> properties 的可自定义 property 编辑器。默认情况下，由<code>BeanWrapperImpl</code>注册，但可以通过将其自定义实例注册为自定义编辑器来覆盖。</td>
</tr>
<tr>
<td align="left"><code>CustomCollectionEditor</code></td>
<td align="left">Property 集合编辑器，将任何源<code>Collection</code>转换为给定目标<code>Collection</code>类型。</td>
</tr>
<tr>
<td align="left"><code>CustomDateEditor</code></td>
<td align="left"><code>java.util.Date</code>的可自定义 property 编辑器，支持自定义<code>DateFormat</code>。没有默认注册。必须是 user-registered，并根据需要使用适当的格式。</td>
</tr>
<tr>
<td align="left"><code>CustomNumberEditor</code></td>
<td align="left">任何<code>Number</code>子类的可自定义 property 编辑器，例如<code>Integer</code>，<code>Long</code>，<code>Float</code>或<code>Double</code>。默认情况下，由<code>BeanWrapperImpl</code>注册，但可以通过将其自定义实例注册为自定义编辑器来覆盖。</td>
</tr>
<tr>
<td align="left"><code>FileEditor</code></td>
<td align="left">将 strings 解析为<code>java.io.File</code> objects。默认情况下，由<code>BeanWrapperImpl</code>注册。</td>
</tr>
<tr>
<td align="left"><code>InputStreamEditor</code></td>
<td align="left">One-way property 编辑器，可以使用 string 并生成(通过中间<code>ResourceEditor</code>和<code>Resource</code>)<code>InputStream</code>，以便<code>InputStream</code> properties 可以直接设置为 strings。请注意，默认用法不会为您关闭<code>InputStream</code>。默认情况下，由<code>BeanWrapperImpl</code>注册。</td>
</tr>
<tr>
<td align="left"><code>LocaleEditor</code></td>
<td align="left">可以将 strings 解析为<code>Locale</code> objects 和 vice-versa(string 格式为<code>[country][variant]</code>，与<code>Locale</code>的<code>toString()</code>方法相同)。默认情况下，由<code>BeanWrapperImpl</code>注册。</td>
</tr>
<tr>
<td align="left"><code>PatternEditor</code></td>
<td align="left">可以将 strings 解析为<code>java.util.regex.Pattern</code> objects 和 vice-versa。</td>
</tr>
<tr>
<td align="left"><code>PropertiesEditor</code></td>
<td align="left">可以将 strings(使用<code>java.util.Properties</code> class 的 javadoc 中定义的格式格式化)转换为<code>Properties</code> objects。默认情况下，由<code>BeanWrapperImpl</code>注册。</td>
</tr>
<tr>
<td align="left"><code>StringTrimmerEditor</code></td>
<td align="left">Property 编辑器修剪 strings。 (可选)允许将空 string 转换为<code>null</code> value。默认情况下未注册 - 必须为 user-registered。</td>
</tr>
<tr>
<td align="left"><code>URLEditor</code></td>
<td align="left">可以将 URL 的 string 表示解析为实际的<code>URL</code> object。默认情况下，由<code>BeanWrapperImpl</code>注册。</td>
</tr>
</tbody></table>
<p>将 bean properties 设置为 string 值时，Spring IoC 容器最终使用标准 JavaBeans <code>PropertyEditor</code> implementations 将这些 strings 转换为 property 的复杂类型。 Spring pre-registers 一些自定义的<code>PropertyEditor</code> implement(用于 example，将表示为 string 的 class name 转换为<code>Class</code> object)。此外，Java 的标准 JavaBeans <code>PropertyEditor</code>查找机制允许适当地命名 class 并放置在与它提供支持的 class 相同的包中，以便可以自动找到它。</p>
<p>如果需要注册其他自定义<code>PropertyEditors</code>，可以使用多种机制。假设您有一个<code>BeanFactory</code> reference，最通常不方便或不推荐的手动方法是使用<code>ConfigurableBeanFactory</code>接口的<code>registerCustomEditor()</code>方法。另一个(稍微方便一点)机制是使用一个名为<code>CustomEditorConfigurer</code>的特殊 bean 工厂 post-processor。虽然你可以使用 bean factory post-processors 和<code>BeanFactory</code> implement，但<code>CustomEditorConfigurer</code>有一个嵌套的 property 设置，所以我们强烈建议你将它与<code>ApplicationContext</code>一起使用，你可以用类似的方式将它部署到任何其他 bean，并且可以自动检测它并应用。</p>
<h2 id="3-4-Spring类转换"><a href="#3-4-Spring类转换" class="headerlink" title="3.4.  Spring类转换"></a>3.4.  Spring类转换</h2><p>Spring 3 引入了一个<code>core.convert</code>包，它提供了一般的类型转换系统。系统定义了一个用于实现类型转换逻辑的 SPI 和一个用于在运行时执行类型转换的 API。在 Spring 容器中，您可以使用此系统替代<code>PropertyEditor</code> implementations 将外部化的 bean property value strings 转换为所需的 property 类型。您还可以在需要进行类型转换的 application 中的任何位置使用公共 API。</p>
<h3 id="3-4-1-转换器SPI"><a href="#3-4-1-转换器SPI" class="headerlink" title="3.4.1.  转换器SPI"></a>3.4.1.  转换器SPI</h3><p>实现类型转换逻辑的 SPI 很简单且类型很强，如下面的接口定义所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.core.convert.converter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">S</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">convert</span><span class="params">(S source)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-2-使用ConverterFactory"><a href="#3-4-2-使用ConverterFactory" class="headerlink" title="3.4.2.  使用ConverterFactory"></a>3.4.2.  使用ConverterFactory</h3><p>当您需要集中整个 class 层次结构的转换逻辑时(对于 example，当从 String 转换为 java.lang.Enum objects 时)，您可以实现<code>ConverterFactory</code>，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.core.convert.converter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConverterFactory</span>&lt;<span class="title">S</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    &lt;T extends R&gt; <span class="function">Converter&lt;S, T&gt; <span class="title">getConverter</span><span class="params">(Class&lt;T&gt; targetType)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-2-使用GenericConverter"><a href="#3-4-2-使用GenericConverter" class="headerlink" title="3.4.2.  使用GenericConverter"></a>3.4.2.  使用GenericConverter</h3><p>当您需要复杂的<code>Converter</code> implementation 时，请考虑使用<code>GenericConverter</code>接口。使用比<code>Converter</code>更灵活但不太强类型的签名，<code>GenericConverter</code>支持在多个源类型和目标类型之间进行转换。此外，<code>GenericConverter</code>使您可以在实现转换逻辑时使用的源和目标字段 context。这样的 context 允许类型转换由字段 annotation 或在字段签名上声明的通用信息驱动。以下清单显示了<code>GenericConverter</code>的接口定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.core.convert.converter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GenericConverter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;ConvertiblePair&gt; <span class="title">getConvertibleTypes</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">convert</span><span class="params">(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-7-Spring验证"><a href="#3-7-Spring验证" class="headerlink" title="3.7.  Spring验证"></a>3.7.  Spring验证</h2><h3 id="3-7-1-JSR-303-Bean-Validation-API-概述"><a href="#3-7-1-JSR-303-Bean-Validation-API-概述" class="headerlink" title="3.7.1.  JSR-303 Bean Validation API 概述"></a>3.7.1.  JSR-303 Bean Validation API 概述</h3><p>考虑以下 example，它显示了一个带有两个 properties 的简单<code>PersonForm</code> model：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonForm</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JSR-303 允许您为这些 properties 定义声明性验证约束，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonForm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Size(max=64)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Min(0)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-Spring表达式语言（）SpEL"><a href="#4-Spring表达式语言（）SpEL" class="headerlink" title="4.Spring表达式语言（）SpEL"></a>4.Spring表达式语言（）SpEL</h1><h2 id="4-1-Evaluation"><a href="#4-1-Evaluation" class="headerlink" title="4.1.  Evaluation"></a>4.1.  Evaluation</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">Expression exp = parser.parseExpression(<span class="string">&quot;&#x27;Hello World&#x27;&quot;</span>); (<span class="number">1</span>)</span><br><span class="line">String message = (String) exp.getValue();</span><br></pre></td></tr></table></figure>

<p><code>ExpressionParser</code>接口负责解析表达式 string。在前面的 example 中，表达式 string 是由周围的单引号表示的 string 文字。 <code>Expression</code>接口负责评估先前定义的表达式 string。分别调用<code>parser.parseExpression</code>和<code>exp.getValue</code>时，可以抛出两个 exceptions，<code>ParseException</code>和<code>EvaluationException</code>。</p>
<p>在下面的方法调用示例中，我们在 string 文字上调用<code>concat</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">Expression exp = parser.parseExpression(<span class="string">&quot;&#x27;Hello World&#x27;.concat(&#x27;!&#x27;)&quot;</span>); (<span class="number">1</span>)</span><br><span class="line">String message = (String) exp.getValue();</span><br></pre></td></tr></table></figure>

<p>泛型方法的使用：<code>public &lt;T&gt; T getValue(Class&lt;T&gt; desiredResultType)</code>。使用此方法无需将表达式的 value 强制转换为所需的结果类型。如果无法将 value 强制转换为<code>T</code>类型或使用已注册的类型转换器进行转换，则抛出<code>EvaluationException</code>。</p>
<p>SpEL 的更常见用法是提供一个表达式 string，该表达式是针对特定的 object 实例(称为 root object)进行评估的。以下 example 显示了如何从<code>Inventor</code> class 的实例检索<code>name</code> property 或创建 boolean 条件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create and set a calendar</span></span><br><span class="line">GregorianCalendar c = <span class="keyword">new</span> GregorianCalendar();</span><br><span class="line">c.set(<span class="number">1856</span>, <span class="number">7</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// The constructor arguments are name, birthday, and nationality.</span></span><br><span class="line">Inventor tesla = <span class="keyword">new</span> Inventor(<span class="string">&quot;Nikola Tesla&quot;</span>, c.getTime(), <span class="string">&quot;Serbian&quot;</span>);</span><br><span class="line"></span><br><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line"></span><br><span class="line">Expression exp = parser.parseExpression(<span class="string">&quot;name&quot;</span>); (<span class="number">1</span>)</span><br><span class="line">String name = (String) exp.getValue(tesla);</span><br><span class="line"><span class="comment">// name == &quot;Nikola Tesla&quot;</span></span><br><span class="line"></span><br><span class="line">exp = parser.parseExpression(<span class="string">&quot;name == &#x27;Nikola Tesla&#x27;&quot;</span>);</span><br><span class="line"><span class="keyword">boolean</span> result = exp.getValue(tesla, Boolean.class);</span><br><span class="line"><span class="comment">// result == true</span></span><br></pre></td></tr></table></figure>

<h3 id="4-1-1-了解EvaluationContext"><a href="#4-1-1-了解EvaluationContext" class="headerlink" title="4.1.1.  了解EvaluationContext"></a>4.1.1.  了解EvaluationContext</h3><h2 id="4-2-Bean中定义的表达式"><a href="#4-2-Bean中定义的表达式" class="headerlink" title="4.2.  Bean中定义的表达式"></a>4.2.  Bean中定义的表达式</h2><p>您可以将带有 XML-based 或 annotation-based configuration 元数据的 SpEL 表达式用于定义<code>BeanDefinition</code>实例。在这两种情况下，定义表达式的语法都是<code>#&#123; &lt;expression string&gt; &#125;</code>形式。</p>
<h3 id="4-2-1-XML-Configuration"><a href="#4-2-1-XML-Configuration" class="headerlink" title="4.2.1.  XML Configuration"></a>4.2.1.  XML Configuration</h3><p>可以使用表达式设置 property 或构造函数参数 value，如下面的 example 所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;numberGuess&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.spring.samples.NumberGuess&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;randomNumber&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123; T(java.lang.Math).random() * 100.0 &#125;&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- other properties --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="5-使用Spring进行面向对象编程"><a href="#5-使用Spring进行面向对象编程" class="headerlink" title="5.  使用Spring进行面向对象编程"></a>5.  使用Spring进行面向对象编程</h1><p>Aspect-oriented 编程(AOP)通过提供另一种思考程序结构的方式来补充 Object-oriented 编程(OOP)。 OOP 中的 key 模块化单元是 class，而在 AOP 中，模块化单元是 aspect。</p>
<p>Spring的核心组件之一就是AOP框架。虽然Spring IoC容器不依赖于AOP，AOP补充了Spring IoC以提供非常强大的中间件解决方案。</p>
<h2 id="5-1-AOP概念"><a href="#5-1-AOP概念" class="headerlink" title="5.1.  AOP概念"></a>5.1.  AOP概念</h2><p>术语：</p>
<ul>
<li>Aspect：纵向关注事务实现的切面。</li>
<li>连接点：程序执行期间的一个点。例如方法的执行或exception的处理，在Spring AOP中，连接点始终表示方法执行。</li>
<li>通知（Advice）：在切面的某个连接点上执行的操作。</li>
<li>切入点：匹配连接点的断言，在AOP中Advice和一个切入点表达式关联。</li>
<li>引入（Introduction）：在不修改代码的前提下，为类添加新的方法和属性。</li>
<li>目标对象：被一个或多个切面所通知的对象。由于Spring AOP是使用运行时代理实现的，因此对象始终是代理对象。</li>
<li>AOP代理：AOP创建的对象，用来实现切面契约。</li>
<li>织入（Weaving）：把切面连接到其他的应用程序类型或者对象上，并创建一个被通知的对象，分为：编译时织入、类加载时织入和执行时织入。</li>
</ul>
<p>通知（Advice）有一下几种类型：</p>
<ul>
<li>前置通知：在连接点之前执行的通知，但不能阻止连接点的执行，除非在通知中抛出异常。</li>
<li>返回后通知：在某个连接点完成后执行的通知。</li>
<li>抛出异常后通知：在方法抛出异常退出时执行的通知。</li>
<li>后通知：当连接点退出时执行的通知，无论是正常返回还是异常退出。</li>
<li>环绕通知：包围一个连接点的通知。</li>
</ul>
<p>环绕通知是最普遍的通知。由于 Spring AOP(如 AspectJ)提供了全方位的通知类型，因此我们建议您使用可以实现所需行为的最不强大的通知类型。例如，如果您只需要使用方法的 return value 更新缓存，那么最好实现返回后通知，而不是环绕通知，尽管环绕通知可以完成同样的事情。</p>
<h2 id="5-2-Spring-AOP能力和目标"><a href="#5-2-Spring-AOP能力和目标" class="headerlink" title="5.2.  Spring AOP能力和目标"></a>5.2.  Spring AOP能力和目标</h2><p>Spring AOP 是用纯 Java 实现的。不需要特殊的编译 process。 Spring AOP 不需要控制 class 加载器层次结构，因此适合在 servlet 容器或 application 服务器中使用。</p>
<p>Spring AOP 目前仅支持方法执行连接点(建议在 Spring beans 上执行方法)。虽然可以在不破坏核心 Spring AOP API 的情况下添加对字段拦截的支持，但未实现字段拦截。如果您需要通知字段访问和更新连接点，请考虑使用 AspectJ 等语言。</p>
<h2 id="5-3-AOP代理"><a href="#5-3-AOP代理" class="headerlink" title="5.3.  AOP代理"></a>5.3.  AOP代理</h2><p>Spring AOP默认使用AOP代理的标准JDK动态代理。这使得任何接口都可以被代理。</p>
<h2 id="5-4-AspectJ支持"><a href="#5-4-AspectJ支持" class="headerlink" title="5.4.  @AspectJ支持"></a>5.4.  @AspectJ支持</h2><p>@AspectJ 指的是将切面声明为使用 annotations 注释的常规 Java classes 的样式。作为 AspectJ 5 版本的一部分，<a target="_blank" rel="noopener" href="https://www.eclipse.org/aspectj">AspectJ 项目</a>引入了 @AspectJ 样式。 Spring 使用 AspectJ 提供的 library 解释与 AspectJ 5 相同的注释，用于切入点解析和匹配。但是，AOP 运行时仍然是纯粹的 Spring AOP，并且不依赖于 AspectJ 编译器或编织器。</p>
<h3 id="5-4-1-启用-AspectJ支持"><a href="#5-4-1-启用-AspectJ支持" class="headerlink" title="5.4.1.  启用@AspectJ支持"></a>5.4.1.  启用@AspectJ支持</h3><p>如果Spring确定bean被一个或多个切面通知，它会自动为该bean生成一个代理来拦截方法调用，并确保根据需要执行通知。</p>
<p>可以使用xml或者Java Config启动@AspectJ支持。还要使用aspectjweaver.jar包。</p>
<p>使用Java Config启动@AspectJ支持，需要添加@EnableAspectJAutoProxy注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要使用 XML-based configuration 启用 @AspectJ 支持，请使用<code>aop:aspectj-autoproxy</code>元素，如下面的 example 所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-4-2-声明Aspect"><a href="#5-4-2-声明Aspect" class="headerlink" title="5.4.2. 声明Aspect"></a>5.4.2. 声明Aspect</h3><p>启用@AspectJ支持后，具有@Aspect注解的Bean将由Spring自动检测并用于配置Spring AOP。</p>
<p>两个 example 中的第一个在 application context 中显示了一个常规的 bean 定义，该定义指向具有<code>@Aspect</code> annotation 的 bean class：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myAspect&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.xyz.NotVeryUsefulAspect&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- configure properties of the aspect here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这两个示例中的第二个显示了<code>NotVeryUsefulAspect</code> class 定义，该定义使用<code>org.aspectj.lang.annotation.Aspect</code> annotation 注释;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.xyz;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotVeryUsefulAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>切面可以有方法和字段（由@Aspect修饰）</p>
<p><code>@Aspect</code> annotation 不足以在 classpath 中自动检测。为此，您需要添加一个单独的<code>@Component</code> annotation(或者，根据 Spring 的 component 扫描器的规则，可以定义符合条件的自定义构造型 annotation)。</p>
<h3 id="5-4-3-声明切入点"><a href="#5-4-3-声明切入点" class="headerlink" title="5.4.3.  声明切入点"></a>5.4.3.  声明切入点</h3><p>切入点确定感兴趣的连接点，从而使我们能够控制通知何时执行。Spring AOP只支持Spring Beans的方法上执行连接点，因此，切入点可以看做匹配Spring Beans上方法的执行。切入点声明有两个部分：一个包含name的签名和一个确定方法执行的切入点表达式。</p>
<p>以下 example 定义名为<code>anyOldTransfer</code>的切入点，该切入点与名为<code>transfer</code>的任何方法的执行相匹配：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(* transfer(..))&quot;)</span><span class="comment">// the pointcut expression</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">anyOldTransfer</span><span class="params">()</span> </span>&#123;&#125;<span class="comment">// the pointcut signature</span></span><br></pre></td></tr></table></figure>

<p>切入点指示符用来指示切入点表达式目的，在Spring AOP中目前只有执行方法这一个连接点，Spring AOP支持的AspectJ切入点指示符如下：</p>
<ul>
<li>execution：用于匹配方法执行的连接点；</li>
<li>within：用于匹配指定的类及其子类中的所有方法。</li>
<li>this：匹配可以向上转型为this指定的类型的代理对象中的所有方法。</li>
<li>target：匹配可以向上转型为target指定的类型的目标对象中的所有方法。</li>
<li>args：用于匹配运行时传入的参数列表的类型为指定的参数列表类型的方法；</li>
<li>@within：用于匹配持有指定注解的类的所有方法；</li>
<li>@target：用于匹配的持有指定注解目标对象的所有方法；</li>
<li>@args：用于匹配运行时 传入的参数列表的类型持有 注解列表对应的注解 的方法；</li>
<li>@annotation：用于匹配持有指定注解的方法；</li>
</ul>
<p>　　AspectJ切入点支持的切入点指示符还有： call、get、set、preinitialization、staticinitialization、initialization、handler、adviceexecution、withincode、cflow、cflowbelow、if、@this、@withincode；但Spring AOP目前不支持这些指示符，使用这些指示符将抛出IllegalArgumentException异常。</p>
<p> Spring AOP 是一个 proxy-based 系统，它区分代理 object 本身(绑定到<code>this</code>)和代理后面的目标 object(绑定到<code>target</code>)。</p>
<p>请注意，切入点定义通常与任何截获的方法匹配。切入点严格意味着 public-only，即使在通过代理进行潜在 non-public 交互的 CGLIB 代理方案中，也需要相应地进行定义。</p>
<p>您可以使用<code>&amp;&amp;,</code> <code>||</code>和<code>!</code>组合切入点表达式。您还可以通过 name 引用切入点表达式。以下 example 显示了三个切入点表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(public * *(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">anyPublicOperation</span><span class="params">()</span> </span>&#123;&#125; (<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Pointcut(&quot;within(com.xyz.someapp.trading..*)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inTrading</span><span class="params">()</span> </span>&#123;&#125; (<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Pointcut(&quot;anyPublicOperation() &amp;&amp; inTrading()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tradingOperation</span><span class="params">()</span> </span>&#123;&#125; (<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>在使用 enterprise applications 时，开发人员通常希望从几个方面引用 application 的模块和特定的操作集。我们建议定义一个“SystemArchitecture”aspect，为此目的捕获 common 切入点表达式。这样的 aspect 通常类似于以下 example：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xyz.someapp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemArchitecture</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A join point is in the web layer if the method is defined</span></span><br><span class="line"><span class="comment">     * in a type in the com.xyz.someapp.web package or any sub-package</span></span><br><span class="line"><span class="comment">     * under that.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;within(com.xyz.someapp.web..*)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inWebLayer</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A join point is in the service layer if the method is defined</span></span><br><span class="line"><span class="comment">     * in a type in the com.xyz.someapp.service package or any sub-package</span></span><br><span class="line"><span class="comment">     * under that.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;within(com.xyz.someapp.service..*)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inServiceLayer</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A join point is in the data access layer if the method is defined</span></span><br><span class="line"><span class="comment">     * in a type in the com.xyz.someapp.dao package or any sub-package</span></span><br><span class="line"><span class="comment">     * under that.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;within(com.xyz.someapp.dao..*)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inDataAccessLayer</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A business service is the execution of any method defined on a service</span></span><br><span class="line"><span class="comment">     * interface. This definition assumes that interfaces are placed in the</span></span><br><span class="line"><span class="comment">     * &quot;service&quot; package, and that implementation types are in sub-packages.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If you group service interfaces by functional area (for example,</span></span><br><span class="line"><span class="comment">     * in packages com.xyz.someapp.abc.service and com.xyz.someapp.def.service) then</span></span><br><span class="line"><span class="comment">     * the pointcut expression &quot;execution(* com.xyz.someapp..service.*.*(..))&quot;</span></span><br><span class="line"><span class="comment">     * could be used instead.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Alternatively, you can write the expression using the &#x27;bean&#x27;</span></span><br><span class="line"><span class="comment">     * PCD, like so &quot;bean(*Service)&quot;. (This assumes that you have</span></span><br><span class="line"><span class="comment">     * named your Spring service beans in a consistent fashion.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.xyz.someapp..service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">businessService</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A data access operation is the execution of any method defined on a</span></span><br><span class="line"><span class="comment">     * dao interface. This definition assumes that interfaces are placed in the</span></span><br><span class="line"><span class="comment">     * &quot;dao&quot; package, and that implementation types are in sub-packages.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.xyz.someapp.dao.*.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dataAccessOperation</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring AOP 用户可能最常使用<code>execution</code>切入点指示符。执行表达式的格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern)</span><br><span class="line">            <span class="keyword">throws</span>-pattern?)</span><br></pre></td></tr></table></figure>

<p>除返回类型 pattern(前面的代码片段中的<code>ret-type-pattern</code>)， name pattern 和参数 pattern 之外的所有部分都是可选的。返回类型 pattern 确定方法的 return 类型必须在 order 中才能匹配连接点。 <code>*</code>最常用作返回类型 pattern。它匹配任何 return 类型。仅当方法返回给定类型时，fully-qualified 类型 name 才匹配。 name pattern 与方法 name 匹配。您可以使用<code>*</code>通配符作为 name pattern 的全部或部分。如果指定声明类型 pattern，请包含尾随<code>.</code>以将其连接到 name pattern component。参数 pattern 稍微复杂一些：<code>()</code>匹配不带参数的方法，而<code>(..)</code>匹配任何数量(零个或多个)参数。 <code>(*)</code> pattern 匹配一个接受任何类型的一个参数的方法。 <code>(*,String)</code>匹配一个带两个参数的方法。第一个可以是任何类型，而第二个必须是<code>String</code>。有关更多信息，请参阅 AspectJ 编程指南的<a target="_blank" rel="noopener" href="https://www.eclipse.org/aspectj/doc/released/progguide/semantics-pointcuts.html">语言语义学</a>部分。</p>
<h3 id="5-4-4-声明通知"><a href="#5-4-4-声明通知" class="headerlink" title="5.4.4.  声明通知"></a>5.4.4.  声明通知</h3><p>通知与切入点表达式相关联，并在切入点匹配的方法执行前，执行后或者环绕运行。切入点表达式可以是对命名切入点的简单引用，也可以是在适当位置声明的切入点表达式。</p>
<h4 id="在连接点之前通知"><a href="#在连接点之前通知" class="headerlink" title="在连接点之前通知"></a>在连接点之前通知</h4><p>可以使用@before注解在aspect中声明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeforeExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAccessCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>环绕通知：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AroundExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;com.xyz.myapp.SystemArchitecture.businessService()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doBasicProfiling</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// start stopwatch</span></span><br><span class="line">        Object retVal = pjp.proceed();</span><br><span class="line">        <span class="comment">// stop stopwatch</span></span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问当前连接点，任何通知方法都可以声明一个类型为JoinPoint的参数作为其第一个参数，需要使用ProceedingJoinPoint作为around声明的第一个参数，它是JoinPoint的子类。JoinPoint接口提供了许多有用的方法：</p>
<ul>
<li>getArgs()：返回方法的参数</li>
<li>getThis()：返回代理的对象</li>
<li>getTarget()：返回目标对象。</li>
<li>getSIgnature()：返回正在通知的方法的描述，就是它的方法签名。</li>
<li>toString()：打印通知方法的有用描述。</li>
</ul>
<h4 id="将参数传递给通知"><a href="#将参数传递给通知" class="headerlink" title="将参数传递给通知"></a>将参数传递给通知</h4><p>要使参数值可以用于通知体，可以使用args的绑定形式。如果在args表达是中使用参数name代替类型name，则在调用通知时，相应参数的value将作为参数值传递。下面的代码：假设通知执行以Account对象作为第一个参数的相关操作，并且需要访问通知体中的账户。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation() &amp;&amp; args(account,..)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validateAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>切入点表达式的<code>args(account,..)</code>部分有两个目的。首先，它将匹配那些至少采用一个参数的方法而且传递给该方法的参数是Account实例。其次，它通过account参数使实际的Account对象可用于通知。</p>
<p>另一种编写方法是声明一个切入点（Point Cut），当它与连接点匹配时提供Account对象，然后从通知中引用指定的切入点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation() &amp;&amp; args(account,..)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">accountDataAccessOperation</span><span class="params">(Account account)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before(&quot;accountDataAccessOperation(account)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validateAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个示例中的第一个显示了<code>@Auditable</code> annotation 的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Auditable &#123;</span><br><span class="line">    <span class="function">AuditCode <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个示例中的第二个显示了与<code>@Auditable</code>方法的执行相匹配的建议：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; @annotation(auditable)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">audit</span><span class="params">(Auditable auditable)</span> </span>&#123;</span><br><span class="line">    AuditCode code = auditable.value();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="建议参数和泛型"><a href="#建议参数和泛型" class="headerlink" title="建议参数和泛型"></a>建议参数和泛型</h4><p>Spring AOP 可以处理 class 声明和方法参数中使用的泛型。假设您有一个如下所示的泛型类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sample</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sampleGenericMethod</span><span class="params">(T param)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sampleGenericCollectionMethod</span><span class="params">(Collection&lt;T&gt; param)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过将 advice 参数 typing 到要拦截方法的参数类型，可以将方法类型的拦截限制为某些参数类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;execution(* ..Sample+.sampleGenericMethod(*)) &amp;&amp; args(param)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeSampleMethod</span><span class="params">(MyType param)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Advice implementation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法不适用于通用集合。因此，您无法按如下方式定义切入点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;execution(* ..Sample+.sampleGenericCollectionMethod(*)) &amp;&amp; args(param)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeSampleMethod</span><span class="params">(Collection&lt;MyType&gt; param)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Advice implementation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了使这项工作，我们必须检查集合的每个元素，这是不合理的，因为我们也无法决定如何处理<code>null</code>值。要实现与此类似的操作，您必须将参数键入<code>Collection&lt;?&gt;</code>并手动检查元素的类型。</p>
<h4 id="确定参数名称"><a href="#确定参数名称" class="headerlink" title="确定参数名称"></a>确定参数名称</h4><p>通知调用中的参数 binding 依赖于切入点表达式中使用的匹配名称与通知和切入点方法签名中声明的参数名称。参数名称不能通过 Java 反射获得，因此 Spring AOP 使用以下策略来确定参数名称：</p>
<ul>
<li>如果用户已明确指定参数名称，则使用指定的参数名称。 advice 和 pointcut annotations 都有一个可选的<code>argNames</code>属性，您可以使用它来指定带注释的方法的参数名称。这些参数名称在运行时可用。以下代码显示了如何使用<code>argNames</code>属性：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(value=&quot;com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)&quot;,</span></span><br><span class="line"><span class="meta">        argNames=&quot;bean,auditable&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">audit</span><span class="params">(Object bean, Auditable auditable)</span> </span>&#123;</span><br><span class="line">    AuditCode code = auditable.value();</span><br><span class="line">    <span class="comment">// ... use code and bean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果第一个参数是<code>JoinPoint</code>，<code>ProceedingJoinPoint</code>或<code>JoinPoint.StaticPart</code>类型，则可以从<code>argNames</code>属性的 value 中省略参数的 name。例如，如果修改前面的接收以接收连接点 object，则<code>argNames</code>属性不需要包含它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(value=&quot;com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)&quot;,</span></span><br><span class="line"><span class="meta">        argNames=&quot;bean,auditable&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">audit</span><span class="params">(JoinPoint jp, Object bean, Auditable auditable)</span> </span>&#123;</span><br><span class="line">    AuditCode code = auditable.value();</span><br><span class="line">    <span class="comment">// ... use code, bean, and jp</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对<code>JoinPoint</code>，<code>ProceedingJoinPoint</code>和<code>JoinPoint.StaticPart</code>类型的第一个参数赋予的特殊处理对于不收集任何其他连接点 context 的通知实例特别方便。在这种情况下，您可以省略<code>argNames</code>属性。例如，以下通知无需声明<code>argNames</code>属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;com.xyz.lib.Pointcuts.anyPublicMethod()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">audit</span><span class="params">(JoinPoint jp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... use jp</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>&#39;argNames&#39;</code>属性有点笨拙，所以如果没有指定<code>&#39;argNames&#39;</code>属性，Spring AOP 会查看 class 的调试信息，并尝试从局部变量 table 中确定参数名称。此信息以 long 形式显示，因为 classes 已使用调试信息(至少<code>&#39;-g:vars&#39;</code>)进行编译。使用此 flag 进行编译的后果是：(1)您的 code 稍微容易理解(逆向工程)，(2)class 文件大小略大(通常无关紧要)，(3)优化删除未使用的本地变量未由编译器应用。换句话说，你应该通过 building 与 flag 一起遇到任何困难。</li>
</ul>
<blockquote>
<p>  如果即使没有调试信息，AspectJ 编译器(ajc)也编译了 @AspectJ aspect，则无需添加<code>argNames</code>属性，因为编译器会保留所需的信息。</p>
</blockquote>
<ul>
<li>如果在没有必要的调试信息的情况下编译了 code，Spring AOP 会尝试推断 binding 变量与参数的配对(对于 example，如果只有一个变量绑定在切入点表达式中，并且 advice 方法只接受一个参数，那么配对很明显)。如果给定可用信息，变量的 binding 是不明确的，则抛出<code>AmbiguousBindingException</code>。</li>
<li>如果上述所有策略都失败，则抛出<code>IllegalArgumentException</code>。</li>
</ul>
<h4 id="proceed参数"><a href="#proceed参数" class="headerlink" title="proceed参数"></a>proceed参数</h4><p>在args中把参数传入，之后调用proceed方法时传入该方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;execution(List&lt;Account&gt; find*(..)) &amp;&amp; &quot; +</span></span><br><span class="line"><span class="meta">        &quot;com.xyz.myapp.SystemArchitecture.inDataAccessLayer() &amp;&amp; &quot; +</span></span><br><span class="line"><span class="meta">        &quot;args(accountHolderNamePattern)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">preProcessQueryPattern</span><span class="params">(ProceedingJoinPoint pjp,</span></span></span><br><span class="line"><span class="function"><span class="params">        String accountHolderNamePattern)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    String newPattern = preProcess(accountHolderNamePattern);</span><br><span class="line">    <span class="keyword">return</span> pjp.proceed(<span class="keyword">new</span> Object[] &#123;newPattern&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通知顺序"><a href="#通知顺序" class="headerlink" title="通知顺序"></a>通知顺序</h4><p>当在一个连接点上定义了多个通知时，Spring AOP遵循与AspectJ相同的优先级规则来确定通知执行的顺序。order越小越先执行，但是最后执行结束。</p>
<h3 id="5-4-5-引入"><a href="#5-4-5-引入" class="headerlink" title="5.4.5.  引入"></a>5.4.5.  引入</h3><p>引入（Introduction）允许一个切面声明一个实现指定接口的通知对象，并且提供了一个接口实现类来代表这些对象。</p>
<p>使用@DeclareParents注解进行引入。该注解声明匹配类型具有新的父类。例如，给定一个声明为UsageTracked的接口和一个名为DefaultUsageTracked的实现类，以下切面声明服务接口的所有所有实现者也实现了UsageTracked接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsageTracking</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeclareParents(value=&quot;com.xzy.myapp.service.*+&quot;, defaultImpl=DefaultUsageTracked.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UsageTracked mixin;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;com.xyz.myapp.SystemArchitecture.businessService() &amp;&amp; this(usageTracked)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recordUsage</span><span class="params">(UsageTracked usageTracked)</span> </span>&#123;</span><br><span class="line">        usageTracked.incrementUseCount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-4-6-Aspect-Instantiation-Models"><a href="#5-4-6-Aspect-Instantiation-Models" class="headerlink" title="5.4.6.  Aspect Instantiation Models"></a>5.4.6.  Aspect Instantiation Models</h3><p>schema-defined aspects只支持singleton model，即 基于配置文件的aspects只支持单例模式</p>
<h3 id="5-4-7-AOP-Example"><a href="#5-4-7-AOP-Example" class="headerlink" title="5.4.7.  AOP Example"></a>5.4.7.  AOP Example</h3><p>使用环绕通知来实现多次重试操作。</p>
<h2 id="5-5-Schema-based-AOP支持"><a href="#5-5-Schema-based-AOP支持" class="headerlink" title="5.5.  Schema-based AOP支持"></a>5.5.  Schema-based AOP支持</h2><p>Spring也可以使用xml来配置使用AOP，支持使用@AspectJ样式完全相同的切入点表达式和通知类型。</p>
<p>在xml中使用aop命名空间标记，需要导入spring-aop。</p>
<p>在Spring配置中，所有的aspect和advisor元素必须放在&lt;aop:config&gt;。其中可以包含切入点，通知和切面元素。</p>
<h3 id="5-5-1-声明Aspect"><a href="#5-5-1-声明Aspect" class="headerlink" title="5.5.1.  声明Aspect"></a>5.5.1.  声明Aspect</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;myAspect&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;aBean&quot;</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;aBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-5-2-声明切入点"><a href="#5-5-2-声明切入点" class="headerlink" title="5.5.2.  声明切入点"></a>5.5.2.  声明切入点</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;businessService&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">expression</span>=<span class="string">&quot;execution(* com.xyz.myapp.service.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>请注意，切入点表达式本身使用与<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-autoproxy">@AspectJ 支持</a>中描述的相同的 AspectJ 切入点表达式语言。如果使用基于 schema 的声明样式，则可以引用切入点表达式中类型(@Aspects)中定义的命名切入点。定义上述切入点的另一种方法如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;businessService&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">expression</span>=<span class="string">&quot;com.xyz.myapp.SystemArchitecture.businessService()&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>假设您有一个<code>SystemArchitecture</code> aspect，如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-ataspectj">共享 Common 切入点定义</a>中所述。</p>
<p>然后在 aspect 中声明切入点与声明 top-level 切入点非常相似，如下面的 example 所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;myAspect&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;aBean&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;businessService&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">expression</span>=<span class="string">&quot;execution(* com.xyz.myapp.service.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>组合切入点 sub-expressions 时，<code>&amp;&amp;</code>在 XML 文档中很难处理，因此您可以分别使用<code>and</code>，<code>or</code>和<code>not</code>关键字代替<code>&amp;&amp;</code>，<code>||</code>和<code>!</code>。例如，可以更好地编写上一个切入点，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;myAspect&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;aBean&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;businessService&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">expression</span>=<span class="string">&quot;execution(* com.xyz.myapp.service..(..)) and this(service)&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;businessService&quot;</span> <span class="attr">method</span>=<span class="string">&quot;monitor&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-5-3-声明通知"><a href="#5-5-3-声明通知" class="headerlink" title="5.5.3.  声明通知"></a>5.5.3.  声明通知</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;beforeExample&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;aBean&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:before</span></span></span><br><span class="line"><span class="tag">        <span class="attr">pointcut-ref</span>=<span class="string">&quot;dataAccessOperation&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">method</span>=<span class="string">&quot;doAccessCheck&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里，<code>dataAccessOperation</code>是在顶部(<code>&lt;aop:config&gt;</code>)level 定义的切入点的<code>id</code>。要改为内联切入点，请将<code>pointcut-ref</code>属性替换为<code>pointcut</code>属性，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;beforeExample&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;aBean&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:before</span></span></span><br><span class="line"><span class="tag">        <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.xyz.myapp.dao.*.*(..))&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">method</span>=<span class="string">&quot;doAccessCheck&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>抛出异常通知中需要声明抛出的异常的参数名：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;afterThrowingExample&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;aBean&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after-throwing</span></span></span><br><span class="line"><span class="tag">        <span class="attr">pointcut-ref</span>=<span class="string">&quot;dataAccessOperation&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">throwing</span>=<span class="string">&quot;dataAccessEx&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">method</span>=<span class="string">&quot;doRecoveryActions&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>doRecoveryActions</code>方法必须声明一个名为<code>dataAccessEx</code>的参数。此参数的类型以与<code>@AfterThrowing</code>描述的相同方式约束匹配。对于 example，方法签名可以声明如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRecoveryActions</span><span class="params">(DataAccessException dataAccessEx)</span> </span>&#123;...</span><br></pre></td></tr></table></figure>

<p>通知参数通过arg-names属性来实现。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:before</span></span></span><br><span class="line"><span class="tag">    <span class="attr">pointcut</span>=<span class="string">&quot;com.xyz.lib.Pointcuts.anyPublicMethod() and @annotation(auditable)&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">method</span>=<span class="string">&quot;audit&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">arg-names</span>=<span class="string">&quot;auditable&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-5-4-引入"><a href="#5-5-4-引入" class="headerlink" title="5.5.4.  引入"></a>5.5.4.  引入</h3><p>使用<code>aop:aspect</code>中的<code>aop:declare-parents</code>元素进行引入。您可以使用<code>aop:declare-parents</code>元素声明匹配类型具有新的父类。例如，给定名为<code>UsageTracked</code>的接口和名为<code>DefaultUsageTracked</code>的接口实现类，以下 aspect 声明服务接口的所有实现者也实现<code>UsageTracked</code>接口。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;usageTrackerAspect&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;usageTracking&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:declare-parents</span></span></span><br><span class="line"><span class="tag">        <span class="attr">types-matching</span>=<span class="string">&quot;com.xzy.myapp.service.*+&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">implement-interface</span>=<span class="string">&quot;com.xyz.myapp.service.tracking.UsageTracked&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">default-impl</span>=<span class="string">&quot;com.xyz.myapp.service.tracking.DefaultUsageTracked&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:before</span></span></span><br><span class="line"><span class="tag">        <span class="attr">pointcut</span>=<span class="string">&quot;com.xyz.myapp.SystemArchitecture.businessService()</span></span></span><br><span class="line"><span class="tag"><span class="string">            and this(usageTracked)&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">method</span>=<span class="string">&quot;recordUsage&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>就相当于是给满足切入点的bean声明了一个DefaultUsageTracked的父类，那么这些bean都可以向上转型，然后执行父类中的方法。</p>
<p>要实现的接口由<code>implement-interface</code>属性确定。 <code>types-matching</code>属性的 value 是 AspectJ 类型 pattern。匹配类型的任何 bean 都实现<code>UsageTracked</code>接口。</p>
<h3 id="5-5-5-Aspect-Instantiation-Models"><a href="#5-5-5-Aspect-Instantiation-Models" class="headerlink" title="5.5.5.  Aspect Instantiation Models"></a>5.5.5.  Aspect Instantiation Models</h3><p>schema-defined 方面唯一支持的实例化 model 是 singleton model。未来的版本可能支持其他实例化模型。</p>
<h3 id="5-5-6-Advisor"><a href="#5-5-6-Advisor" class="headerlink" title="5.5.6.  Advisor"></a>5.5.6.  Advisor</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;businessService&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">expression</span>=<span class="string">&quot;execution(* com.xyz.myapp.service.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span></span></span><br><span class="line"><span class="tag">        <span class="attr">pointcut-ref</span>=<span class="string">&quot;businessService&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">advice-ref</span>=<span class="string">&quot;tx-advice&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;tx-advice&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>除了前面的 example 中使用的<code>pointcut-ref</code>属性之外，您还可以使用<code>pointcut</code>属性来内联定义切入点表达式。</p>
<p>要定义顾问程序的优先级以便建议可以参与 ordering，请使用<code>order</code>属性来定义顾问程序的<code>Ordered</code> value。</p>
<h2 id="5-8-代理机制"><a href="#5-8-代理机制" class="headerlink" title="5.8.  代理机制"></a>5.8.  代理机制</h2><p>Spring AOP使用JDK动态代理或CGLIB为给定的目标对象创建代理。</p>
<p>如果要代理的目标对象实现至少一个接口，则使用JDK动态代理。目标类型实现的多有接口都是代理的。如果目标对象没有实现任何接口，则会创建CGLIB代理。</p>
<p>如果要强制使用CGLIB代理（例如，代理目标为对象定义的每个方法，而不仅仅是由接口实现的方法），需要考虑以下问题：</p>
<ul>
<li>无法通知<code>final</code>方法，因为它们无法被覆盖。</li>
<li>从 Spring 3.2 开始，不再需要将 CGLIB 添加到项目 classpath 中，因为 CGLIB classes 在<code>org.springframework</code>下重新打包并直接包含在 spring-core JAR 中。这意味着 CGLIB-based 代理支持“正常工作”，就像 JDK 动态代理一样。</li>
<li>从 Spring 4.0 开始，代理 object 的构造函数不再被调用两次，因为 CGLIB 代理实例是通过 Objenesis 创建的。只有当您的 JVM 不允许构造函数绕过时，您才可以从 Spring 的 AOP 支持中看到 两次调用和相应的debug log条目。</li>
</ul>
<p>要强制使用 CGLIB 代理，请将<code>&lt;aop:config&gt;</code>元素的<code>proxy-target-class</code>属性的 value 设置为 true，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- other beans defined here... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>要在使用 @AspectJ auto-proxy 支持时强制 CGLIB 代理，请将<code>&lt;aop:aspectj-autoproxy&gt;</code>元素的<code>proxy-target-class</code>属性设置为<code>true</code>，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>需要明确的是，在<code>&lt;tx:annotation-driven/&gt;</code>，<code>&lt;aop:aspectj-autoproxy/&gt;</code>或<code>&lt;aop:config/&gt;</code>元素上使用<code>proxy-target-class=&quot;true&quot;</code>会强制对所有这三个元素使用 CGLIB 代理。</p>
<h3 id="5-8-1-了解AOP代理"><a href="#5-8-1-了解AOP代理" class="headerlink" title="5.8.1.  了解AOP代理"></a>5.8.1.  了解AOP代理</h3><p>Spring AOP是基于代理的。</p>
<h2 id="5-9-程序化创建-AspectJ代理"><a href="#5-9-程序化创建-AspectJ代理" class="headerlink" title="5.9.  程序化创建@AspectJ代理"></a>5.9.  程序化创建@AspectJ代理</h2><p>您可以使用<code>org.springframework.aop.aspectj.annotation.AspectJProxyFactory</code> class 为一个或多个 @AspectJ 方面建议的目标 object 创建代理。这个 class 的基本用法非常简单，如下面的示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a factory that can generate a proxy for the given target object</span></span><br><span class="line">AspectJProxyFactory factory = <span class="keyword">new</span> AspectJProxyFactory(targetObject);</span><br><span class="line"></span><br><span class="line"><span class="comment">// add an aspect, the class must be an @AspectJ aspect</span></span><br><span class="line"><span class="comment">// you can call this as many times as you need with different aspects</span></span><br><span class="line">factory.addAspect(SecurityManager.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// you can also add existing aspect instances, the type of the object supplied must be an @AspectJ aspect</span></span><br><span class="line">factory.addAspect(usageTracker);</span><br><span class="line"></span><br><span class="line"><span class="comment">// now get the proxy object...</span></span><br><span class="line">MyInterfaceType proxy = factory.getProxy();</span><br></pre></td></tr></table></figure>

<h2 id="5-10-将AspectJ与Spring-Applicaitons一起使用"><a href="#5-10-将AspectJ与Spring-Applicaitons一起使用" class="headerlink" title="5.10.  将AspectJ与Spring Applicaitons一起使用"></a>5.10.  将AspectJ与Spring Applicaitons一起使用</h2><p><code>@Configurable</code> annotation 将 class 标记为符合 Spring-driven configuration 的条件。在最简单的情况下，您可以纯粹使用它作为标记 annotation，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xyz.myapp.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Configurable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configurable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Configurable(preConstruction = true)</code> 这个注解的作用是：<br>告诉<code>Spring</code>在构造函数运行之前将依赖注入到对象中。</p>
<p>如果要显式指定要使用的原型 bean 定义的 name，可以直接在 annotation 中执行此操作，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xyz.myapp.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Configurable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configurable(&quot;account&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用自动装配来避免必须指定专用的 bean 定义。要让 Spring 应用自动装配，请使用<code>@Configurable</code> 注释的<code>autowire</code> property。您可以分别按类型或 name 指定<code>@Configurable(autowire=Autowire.BY_TYPE)</code>或<code>@Configurable(autowire=Autowire.BY_NAME</code>进行自动装配。作为替代，从 Spring 2.5 开始，最好通过在字段或方法 level 上使用<code>@Autowired</code>或<code>@Inject</code>为<code>@Configurable</code> beans 指定显式的 annotation-driven 依赖注入(有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-aj-ltw">Annotation-based Container Configuration</a>)。</p>
<p>最后，您可以使用<code>dependencyCheck</code>属性(对于 example，<code>@Configurable(autowire=Autowire.BY_NAME,dependencyCheck=true)</code>)为新创建和配置的 object 中的 object references 启用 Spring 依赖性检查。如果此属性设置为<code>true</code>，则 Spring 会在 configuration 之后验证是否已设置所有 properties(不是 primitives 或集合)。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://crazystrome.github.io/2020/10/14/Redis%E8%BF%90%E7%BB%B4-%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="crazyStrome">
      <meta itemprop="description" content="啥都写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="crazyStrome的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/14/Redis%E8%BF%90%E7%BB%B4-%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-14 18:23:20" itemprop="dateCreated datePublished" datetime="2020-10-14T18:23:20+08:00">2020-10-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-25 16:05:05" itemprop="dateModified" datetime="2020-03-25T16:05:05+08:00">2020-03-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- TOC -->

<ul>
<li><a href="#%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88">有序集合</a><ul>
<li><a href="#%E5%91%BD%E4%BB%A4">命令</a><ul>
<li><a href="#%E9%9B%86%E5%90%88%E5%86%85">集合内</a></li>
<li><a href="#%E9%9B%86%E5%90%88%E9%97%B4%E7%9A%84%E6%93%8D%E4%BD%9C">集合间的操作</a></li>
</ul>
</li>
<li><a href="#%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81">内部编码</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">使用场景</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h2 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h2><p>有序集合保留了集合不能有重复元素的特性，但是有序集合的元素可以排序。它给每一个元素设置一个分数（score）作为排序依据。有序集合提供了获取指定分数和元素范围查询、计算成员排名等功能。</p>
<p><img src="https://i.loli.net/2020/03/22/OemUrSLFuQf5JXR.png" alt="1584772059341"></p>
<p>有序集合中的元素不能重复，但是score可以重复。</p>
<p><img src="https://i.loli.net/2020/03/22/8GF9lUvbphHysTA.png" alt="1584772195575"></p>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><h4 id="集合内"><a href="#集合内" class="headerlink" title="集合内"></a>集合内</h4><ul>
<li>添加成员：<code>zadd key score member [score member...]</code></li>
<li>计算成员个数：<code>zcard key</code></li>
<li>计算某个成员的分数：<code>zscore key member</code>，如果成员不存在，返回nil</li>
<li>计算成员的排名：<code>zrank key member</code>，<code>zrank</code>是分数从低到高排，<code>zrevrank</code>反之，排名从0开始</li>
<li>删除成员：<code>zrem key member [member...]</code>，返回成功删除的个数</li>
<li>返回指定排名范围的成员：<code>zrange key start end [withscores]</code>、<code>zrevrange key start end [withscores]</code>，如果加上withscore选项，则会同时返回成员的数据</li>
<li>返回指定分数范围的成员：<code>zrangebyscore key min max [withscore] [limit offset count]</code>，分数从低到高，<code>zrevrangebyscore</code>反之，[limit offset count]选项可以限制输出的起始位置和个数，max和min还支持开区间和闭区间，-inf和+inf代表无限小和无限大</li>
<li>返回指定分数范围成员个数：<code>zcount key min max</code></li>
<li>删除指定排名内的升序元素：<code>zremrangebyrank key start end</code></li>
<li>删除指定分数范围内的成员：<code>zremrangebyscore key min max</code></li>
</ul>
<h4 id="集合间的操作"><a href="#集合间的操作" class="headerlink" title="集合间的操作"></a>集合间的操作</h4><ul>
<li>交集：<code>zinterstore des numkeys key [key...] [weights weight [weight ...]] [aggregate sum|min|max]</code>；des：交集结果保存的位置；numkeys：需要做交集的键的个数；key：做交集的键；weights weight[weight…]：每个键的权重，在交集时，每个建中的member会将自己分数乘以这个权重，每个键的权重默认为1；aggreget sum|min|max：计算成员交集后，分值可以按照sum、min、max做汇总，默认是sum</li>
<li>并集：<code>zunionstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max]</code></li>
</ul>
<h3 id="内部编码"><a href="#内部编码" class="headerlink" title="内部编码"></a>内部编码</h3><p>有序集合的内部编码有两种：</p>
<ul>
<li>ziplist：当有序集合个数小于<code>zset-max-ziplist-entries</code>的配置（默认128个），同时每个元素的值都小于<code>zset-max-ziplist-value</code>配置（默认64字节）时，Redis使用ziplist作为内部实现</li>
<li>skiplist：当ziplist不满足条件时，使用skiplist</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>添加用户赞数：<code>zadd user name count</code>、<code>zincrby user name</code></li>
<li>取消用户攒数：<code>zrem user name</code></li>
<li>展示获取赞数最多的是个用户：<code>zrevrangebyrank user 0 9</code></li>
<li>展示用户信息以及用户分数：<code>zscore user name</code>、<code>zrank user name</code></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://crazystrome.github.io/2020/10/14/Redis%E8%BF%90%E7%BB%B4-%E5%B0%8F%E5%8A%9F%E8%83%BD%E5%A4%A7%E7%94%A8%E5%A4%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="crazyStrome">
      <meta itemprop="description" content="啥都写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="crazyStrome的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/14/Redis%E8%BF%90%E7%BB%B4-%E5%B0%8F%E5%8A%9F%E8%83%BD%E5%A4%A7%E7%94%A8%E5%A4%84/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-14 18:23:20" itemprop="dateCreated datePublished" datetime="2020-10-14T18:23:20+08:00">2020-10-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-26 21:46:07" itemprop="dateModified" datetime="2020-04-26T21:46:07+08:00">2020-04-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="3-小功能大用处"><a href="#3-小功能大用处" class="headerlink" title="3  小功能大用处"></a>3  小功能大用处</h2><h2 id="3-1-慢查询分析"><a href="#3-1-慢查询分析" class="headerlink" title="3.1  慢查询分析"></a>3.1  慢查询分析</h2><p>慢查询日志就是系统在命令执行前后计算每条命令的执行时间，当超过预设阈值，就将这条命令的相关信息（发生时间，耗时，命令的详细信息）记录下来。</p>
<p><img src="https://i.loli.net/2020/04/26/eJgD3PrUATRO1Bc.png"></p>
<p>慢查询值统计步骤3的时间，所以没有慢查询不代表客户端没有超时时间。</p>
<h3 id="3-1-1-慢查询的两个配置参数"><a href="#3-1-1-慢查询的两个配置参数" class="headerlink" title="3.1.1  慢查询的两个配置参数"></a>3.1.1  慢查询的两个配置参数</h3><p>slowlog-log-slower-than就是预设的阈值，单位是微妙，默认值是10000。</p>
<p>redis使用了一个列表来储存慢查询日志，slowlog-max-len就是列表的最大长度。</p>
<p>在Redis中有两种修改配置的方法，一种是修改配置文件，另一种就是使用config set命令动态修改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config set slowlog-log-slower-than 20000</span><br><span class="line">config set slowlog-max-len 1000</span><br><span class="line">config rewrite</span><br></pre></td></tr></table></figure>

<h4 id="1-获取慢查询日志"><a href="#1-获取慢查询日志" class="headerlink" title="1  获取慢查询日志"></a>1  获取慢查询日志</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slowlog get [n]</span><br></pre></td></tr></table></figure>

<p>参数n可以指定条数。</p>
<p><img src="https://i.loli.net/2020/04/26/ZLanzuBV8yotIYm.png"></p>
<h4 id="2-获取慢查询日志列表的当前长度"><a href="#2-获取慢查询日志列表的当前长度" class="headerlink" title="2  获取慢查询日志列表的当前长度"></a>2  获取慢查询日志列表的当前长度</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slowlog len</span><br></pre></td></tr></table></figure>

<h4 id="3-慢查询日志重置"><a href="#3-慢查询日志重置" class="headerlink" title="3  慢查询日志重置"></a>3  慢查询日志重置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slowlog reset</span><br></pre></td></tr></table></figure>

<h3 id="3-1-2-最佳实践"><a href="#3-1-2-最佳实践" class="headerlink" title="3.1.2  最佳实践"></a>3.1.2  最佳实践</h3><p>slowlog-man-len：线上建议调大慢查询列表</p>
<p>slowlog-log-slower-than：默认值超过10毫秒判定为慢查询，高OPS场景的Redis建议设置为1毫秒。</p>
<p>慢查询只记录命令执行时间，并不包含命令排队和网络传输时间。因此当客户端出现超时，需要检查对应的时间点是否有对应的慢查询，从而分析是否为慢查询导致的命令级联阻塞。</p>
<p>慢查询日志是一个队列，如果慢查询较多，可以定期执行<code>slow get</code>将慢查询日志持久化到其他存储中。</p>
<h2 id="3-2-Redis-Shell"><a href="#3-2-Redis-Shell" class="headerlink" title="3.2  Redis Shell"></a>3.2  Redis Shell</h2><h3 id="3-2-1-redis-cli详解"><a href="#3-2-1-redis-cli详解" class="headerlink" title="3.2.1  redis-cli详解"></a>3.2.1  redis-cli详解</h3><h4 id="1-r"><a href="#1-r" class="headerlink" title="1  -r"></a>1  -r</h4><p>-r表示将命令执行多次</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -r 3 ping</span><br></pre></td></tr></table></figure>

<h4 id="2-i"><a href="#2-i" class="headerlink" title="2 -i"></a>2 -i</h4><p>-i代表每隔几秒种执行一次命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -r 5 -i 1 ping</span><br></pre></td></tr></table></figure>

<h4 id="3-x"><a href="#3-x" class="headerlink" title="3  -x"></a>3  -x</h4><p>-x表示从标准输入读取数据作为redis-cli的最后一个参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;world&quot; | redis-cli -x set hello</span><br></pre></td></tr></table></figure>

<h4 id="4-c"><a href="#4-c" class="headerlink" title="4  -c"></a>4  -c</h4><p>-c可以防止moved和ask异常。</p>
<h4 id="5-a"><a href="#5-a" class="headerlink" title="5  -a"></a>5  -a</h4><p>如果Redis配置了密码，可以用-a选项。</p>
<h4 id="6-–scan和–parttern"><a href="#6-–scan和–parttern" class="headerlink" title="6  –scan和–parttern"></a>6  –scan和–parttern</h4><p>扫描指定模式的键</p>
<h4 id="7-–slave"><a href="#7-–slave" class="headerlink" title="7  –slave"></a>7  –slave</h4><p>–slave选项吧当前客户端模拟成当前Redis节点的从节点，可以用来获取当前Redis节点的更新操作。</p>
<p>PING命令是由于主从幅值产生的。</p>
<h4 id="8-–rdb"><a href="#8-–rdb" class="headerlink" title="8  –rdb"></a>8  –rdb</h4><p>请求Redis实例生成并发送RDB持久化文件，保存在本地。</p>
<h4 id="9-–pipe"><a href="#9-–pipe" class="headerlink" title="9  –pipe"></a>9  –pipe</h4><p>将命令封装成Redis通信协议定义的数据格式，批量发送给Redis执行。</p>
<h4 id="10-–bigkeys"><a href="#10-–bigkeys" class="headerlink" title="10  –bigkeys"></a>10  –bigkeys</h4><p>使用scan命令对Redis的键进行采样，从中找到内存占用比较大的键值。</p>
<h4 id="11-–eval"><a href="#11-–eval" class="headerlink" title="11  –eval"></a>11  –eval</h4><p>执行指定Lua脚本</p>
<h4 id="12-–latency"><a href="#12-–latency" class="headerlink" title="12  –latency"></a>12  –latency</h4><p>网络延迟统计</p>
<h3 id="3-2-2-redis-server详解"><a href="#3-2-2-redis-server详解" class="headerlink" title="3.2.2  redis-server详解"></a>3.2.2  redis-server详解</h3><p>redis-server除了启动Redis外，还有一个–test-memory选项。可以用来检测当前操作系统能否稳定地分配指定容量的内存给Redis。</p>
<h3 id="redis-benchmark"><a href="#redis-benchmark" class="headerlink" title="redis-benchmark"></a>redis-benchmark</h3><h2 id="3-3-Pipeline"><a href="#3-3-Pipeline" class="headerlink" title="3.3  Pipeline"></a>3.3  Pipeline</h2><h3 id="3-3-1-Pipline概念"><a href="#3-3-1-Pipline概念" class="headerlink" title="3.3.1  Pipline概念"></a>3.3.1  Pipline概念</h3><p>RTT（Round Trip Time）往返时间。</p>
<p>Pipeline将一组Redis命令进行组装，铜鼓一次RTT传输给Redis，再将这组Redis命令的执行结果按顺序返回给客户端。</p>
<h3 id="3-3-2-性能测试"><a href="#3-3-2-性能测试" class="headerlink" title="3.3.2  性能测试"></a>3.3.2  性能测试</h3><p>pipeline执行速度一般比逐条执行要快。</p>
<p>客户端和服务器的网络延时越大，pipeline的效果越明显。</p>
<h3 id="3-3-3-原生批量命令和pipeline对比"><a href="#3-3-3-原生批量命令和pipeline对比" class="headerlink" title="3.3.3  原生批量命令和pipeline对比"></a>3.3.3  原生批量命令和pipeline对比</h3><p>原生批量命令是原子的，pipeline是非原子的</p>
<p>原生批量命令是一个命令对应多个key，pipeline支持多个命令。</p>
<p>原生批量命令是Redis服务端支持实现的，而pipeline需要服务端和客户端的共同实现。</p>
<h2 id="3-4-事务与Lua"><a href="#3-4-事务与Lua" class="headerlink" title="3.4   事务与Lua"></a>3.4   事务与Lua</h2><p>简单的事务功能和集成脚本来保证多条命令组合的原子性。</p>
<h3 id="3-4-1-事务"><a href="#3-4-1-事务" class="headerlink" title="3.4.1  事务"></a>3.4.1  事务</h3><p>Redis提供了简单的事务，将一组需要一起执行的命令放到multi和exec两个命令之间。</p>
<p>如果要停止事务的执行，使用discard。</p>
<h2 id="3-5-Bitmaps"><a href="#3-5-Bitmaps" class="headerlink" title="3.5  Bitmaps"></a>3.5  Bitmaps</h2><h3 id="3-5-1-数据结构模型"><a href="#3-5-1-数据结构模型" class="headerlink" title="3.5.1  数据结构模型"></a>3.5.1  数据结构模型</h3><p>Redis提供了Bitmaps可以实现对位的操作。</p>
<p>Bitmaps本身不是一种数据结构，实际上它就是字符串，但是它可以对字符串的位进行操作。</p>
<p>Bitmaps单独提供了一套命令，所以在Redis中使用Bitmaps和使用字符串的方法不太相同。可以吧Bitmaps想象成一个以位为单位的数组，数组的每个单元智能存储0和1，数组的下标在Bitmaps中叫做偏移量。</p>
<h3 id="3-5-2-命令"><a href="#3-5-2-命令" class="headerlink" title="3.5.2  命令"></a>3.5.2  命令</h3><h4 id="1-设置值"><a href="#1-设置值" class="headerlink" title="1  设置值"></a>1  设置值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setbit key offset value</span><br></pre></td></tr></table></figure>

<h4 id="2-获取值"><a href="#2-获取值" class="headerlink" title="2  获取值"></a>2  获取值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getbit key offset</span><br></pre></td></tr></table></figure>

<h4 id="3-获取Bitmaps指定范围内值为1的个数"><a href="#3-获取Bitmaps指定范围内值为1的个数" class="headerlink" title="3  获取Bitmaps指定范围内值为1的个数"></a>3  获取Bitmaps指定范围内值为1的个数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitcount [start] [end]</span><br></pre></td></tr></table></figure>

<h4 id="4-Bitmaps之间的运算"><a href="#4-Bitmaps之间的运算" class="headerlink" title="4  Bitmaps之间的运算"></a>4  Bitmaps之间的运算</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitop op destkey key[key...]</span><br></pre></td></tr></table></figure>

<h4 id="5-计算Bitmaps中第一个值为targetBit的偏移量"><a href="#5-计算Bitmaps中第一个值为targetBit的偏移量" class="headerlink" title="5  计算Bitmaps中第一个值为targetBit的偏移量"></a>5  计算Bitmaps中第一个值为targetBit的偏移量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitpos key targetBit [start] [end]</span><br></pre></td></tr></table></figure>

<h3 id="3-5-3-Bitmaps分析"><a href="#3-5-3-Bitmaps分析" class="headerlink" title="3.5.3  Bitmaps分析"></a>3.5.3  Bitmaps分析</h3><p>当用户量多时，使用Bitmaps可以节省内存。</p>
<h2 id="3-6-HyperLogLog"><a href="#3-6-HyperLogLog" class="headerlink" title="3.6  HyperLogLog"></a>3.6  HyperLogLog</h2><p>HyperLogLog并不是一种新的数据结构，而是一种基数算法，通过HyperLogLog可以利用极小的内存空间完成独立总数的统计，数据集可以是IP、Email、ID等。HyperLogLog提供3个命令：pfadd、pfcount、pfmerge。</p>
<h2 id="3-7-发布订阅"><a href="#3-7-发布订阅" class="headerlink" title="3.7  发布订阅"></a>3.7  发布订阅</h2><p>Redis提供发布订阅模式的消息机制，这种模式下，消息发布者和订阅者不进行直接通信，发布者客户端向指定的频道发布消息，订阅该频道的每个客户都可以接收到该信息。</p>
<p><img src="https://i.loli.net/2020/04/26/6VqLBfur175jMY2.png"></p>
<h3 id="3-7-1-命令"><a href="#3-7-1-命令" class="headerlink" title="3.7.1  命令"></a>3.7.1  命令</h3><h4 id="1-发布消息"><a href="#1-发布消息" class="headerlink" title="1  发布消息"></a>1  发布消息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">publish channel message</span><br></pre></td></tr></table></figure>

<h4 id="2-订阅消息"><a href="#2-订阅消息" class="headerlink" title="2  订阅消息"></a>2  订阅消息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subscribe channel</span><br></pre></td></tr></table></figure>

<p>新开启的订阅客户端，无法收到该频道之前的消息，因为Redis不会对<br>发布的消息进行持久化。</p>
<h4 id="3-取消订阅"><a href="#3-取消订阅" class="headerlink" title="3  取消订阅"></a>3  取消订阅</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unsubscribe [channel] [channel...]</span><br></pre></td></tr></table></figure>

<h4 id="4-按照模式订阅和取消订阅"><a href="#4-按照模式订阅和取消订阅" class="headerlink" title="4  按照模式订阅和取消订阅"></a>4  按照模式订阅和取消订阅</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">psubscribe pattern [pattern...]</span><br><span class="line">punsubscribe [pattern [pattern ...]]</span><br></pre></td></tr></table></figure>

<h4 id="5-查询订阅"><a href="#5-查询订阅" class="headerlink" title="5  查询订阅"></a>5  查询订阅</h4><ul>
<li><p>查看活跃的频道</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pubsub channels [pattern]</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看频道订阅数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pubsub numsub [channel ...]</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看模式订阅数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pubsub numpat</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3-7-2-使用场景"><a href="#3-7-2-使用场景" class="headerlink" title="3.7.2  使用场景"></a>3.7.2  使用场景</h3><p>聊天室、公告牌、服务之间利用消息解耦都可以使用发布订阅模式。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://crazystrome.github.io/2020/10/14/Redis%E8%BF%90%E7%BB%B4-%E5%AE%A2%E6%88%B7%E7%AB%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="crazyStrome">
      <meta itemprop="description" content="啥都写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="crazyStrome的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/14/Redis%E8%BF%90%E7%BB%B4-%E5%AE%A2%E6%88%B7%E7%AB%AF/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-14 18:23:20" itemprop="dateCreated datePublished" datetime="2020-10-14T18:23:20+08:00">2020-10-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-27 09:40:28" itemprop="dateModified" datetime="2020-04-27T09:40:28+08:00">2020-04-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="4-客户端"><a href="#4-客户端" class="headerlink" title="4.  客户端"></a>4.  客户端</h1><h2 id="4-1-客户端通信协议"><a href="#4-1-客户端通信协议" class="headerlink" title="4.1.  客户端通信协议"></a>4.1.  客户端通信协议</h2><p><img src="https://i.loli.net/2020/04/27/LlZpBCaA4E9Mk8y.png"></p>
<h2 id="4-2-Java客户端Jedis"><a href="#4-2-Java客户端Jedis" class="headerlink" title="4.2.  Java客户端Jedis"></a>4.2.  Java客户端Jedis</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://crazystrome.github.io/2020/10/14/Redis%E8%BF%90%E7%BB%B4-%E9%94%AE%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="crazyStrome">
      <meta itemprop="description" content="啥都写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="crazyStrome的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/14/Redis%E8%BF%90%E7%BB%B4-%E9%94%AE%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-14 18:23:20" itemprop="dateCreated datePublished" datetime="2020-10-14T18:23:20+08:00">2020-10-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-04 09:11:35" itemprop="dateModified" datetime="2020-04-04T09:11:35+08:00">2020-04-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- TOC -->

<ul>
<li><a href="#%E9%94%AE%E7%AE%A1%E7%90%86">键管理</a><ul>
<li><a href="#%E5%8D%95%E4%B8%AA%E9%94%AE%E7%AE%A1%E7%90%86">单个键管理</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h1 id="键管理"><a href="#键管理" class="headerlink" title="键管理"></a>键管理</h1><h2 id="单个键管理"><a href="#单个键管理" class="headerlink" title="单个键管理"></a>单个键管理</h2><p>针对单个键的命令</p>
<ul>
<li><p>键重命名。<code>rename key newkey</code>,<code>renamenx</code>只有在newkey不存在的时候才被覆盖。</p>
</li>
<li><p>随机返回一个键。<code>randomkey</code></p>
</li>
<li><p>键过期。除了expire、ttl命令外，Redis还提供了expireat、pexpire、pexpireat、pttl、persist等一系列命令。</p>
<ul>
<li><p><code>expire key second</code>：键在second秒后过期</p>
</li>
<li><p><code>expireat key timestamp</code>：键在秒级时间戳timestap后过期，</p>
</li>
<li><p>ttl和pttl都可以查询键的剩余过期时间，但是pttl精度更高可以达到毫秒级别，有3中种返回值：</p>
<ul>
<li>大于等于0的整数：键剩余过期时间</li>
<li>-1：键没有设置过期时间</li>
<li>-2：键不存在</li>
</ul>
<p>expireat命令可以设置键的秒级过期时间戳。<br>使用Redis相关过期指令时需要注意：</p>
</li>
<li><p>如果expire key的键不存在，返回结果为0</p>
</li>
<li><p>如果过期时间为负值，键会立即被删除。</p>
</li>
<li><p>persist命令可以将键的过期时间清除</p>
</li>
<li><p>对于字符串类型键，执行set命令会去掉过期时间</p>
</li>
<li><p>Redis不支持二级数据结构内部元素的过期功能，例如不能对列表类型的一个元素做过期时间设置</p>
</li>
<li><p>setex命令作为set+expire的组合，不但是原子操作，同时减少了一次网络通讯的时间</p>
</li>
</ul>
</li>
<li><p>迁移键<br>Redis发展历程中提供了move、dump+restore、migrate三组迁移键的方法</p>
<ul>
<li><p>move<br>move命令用于在Redis内部进行数据迁移，Redis内部可以有多个数据库。<br><img src="https://i.loli.net/2020/03/26/UM75dlfIPcEWY8H.png" alt="move"></p>
</li>
<li><p>dump+restore</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dump key</span><br><span class="line">restore key ttl value</span><br></pre></td></tr></table></figure>
<p>dump+restore可以实现在不同的Redis实例之间进行数据迁移的功能：</p>
<ul>
<li>在源Redis上，dump命令会将键值序列化，格式采用的是RDB格式</li>
<li>在目标Redis上，restore命令将上面序列化的值进行复原，其中ttl参数代表过期时间，如果ttl为0则表示没有过期时间</li>
</ul>
<p>整个迁移过程并非原子性的，而是通过客户端分布完成的。迁移过程是开启了两个客户端连接，所以dump的结果不是在源Redis和目标Redis之间进行传输</p>
</li>
<li><p>migrate<br>migrate命令也是用于在Redis实例之间进行数据迁移的，实际上migrate命令就是将dump、restore、del三个命令进行组合，从而简化操作流程。</p>
</li>
</ul>
</li>
<li><p>遍历键<br>Redis提供了两个命令遍历所有的键，分别是keys和scan</p>
<ol>
<li>全量遍历键：<code>keys pattern</code>，支持正则表达式</li>
<li></li>
</ol>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://crazystrome.github.io/2020/10/14/Redis%E8%BF%90%E7%BB%B4-%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="crazyStrome">
      <meta itemprop="description" content="啥都写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="crazyStrome的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/14/Redis%E8%BF%90%E7%BB%B4-%E9%9B%86%E5%90%88/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-14 18:23:20" itemprop="dateCreated datePublished" datetime="2020-10-14T18:23:20+08:00">2020-10-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-25 16:04:08" itemprop="dateModified" datetime="2020-03-25T16:04:08+08:00">2020-03-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- TOC -->

<ul>
<li><a href="#%E9%9B%86%E5%90%88">集合</a><ul>
<li><a href="#%E5%91%BD%E4%BB%A4">命令</a><ul>
<li><a href="#%E9%9B%86%E5%90%88%E5%86%85%E6%93%8D%E4%BD%9C">集合内操作</a></li>
<li><a href="#%E9%9B%86%E5%90%88%E9%97%B4%E6%93%8D%E4%BD%9C">集合间操作</a></li>
</ul>
</li>
<li><a href="#%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81">内部编码</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">使用场景</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合类型中不允许有重复元素。</p>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><h4 id="集合内操作"><a href="#集合内操作" class="headerlink" title="集合内操作"></a>集合内操作</h4><ul>
<li>添加元素：<code>sadd key element [element...]</code>，返回添加成功的元素的个数</li>
<li>删除元素：<code>srem key element [element...]</code>，返回成功删除的元素个数</li>
<li>计算元素个数：<code>scard key</code>，时间复杂度o(1)，它不会遍历集合所有元素，而是直接使用Redis内部的变量</li>
<li>判断元素是否在集合中：<code>sismember key element</code>；</li>
<li>随机从集合中返回指定个数元素：<code>srandmember key [count]</code>；count是可选参数，如果不选默认为1</li>
<li>从集合中随机弹出元素：<code>spop key</code></li>
<li>获取所有元素：<code>smembers key</code>，<code>smembers</code>和<code>lrange</code>、<code>hgetall</code>都属于比较重的命令，如果元素过多存在阻塞Redis的可能性</li>
</ul>
<h4 id="集合间操作"><a href="#集合间操作" class="headerlink" title="集合间操作"></a>集合间操作</h4><ul>
<li>求多个集合的交集：<code>sinter key [key...]</code></li>
<li>求多个集合的并集：<code>sunion key [key...]</code></li>
<li>求多个集合的差集：<code>sdiff key [key...]</code></li>
</ul>
<p><img src="https://i.loli.net/2020/03/22/xSVAwQnaLh4kT1R.png" alt="1584771291231"></p>
<ul>
<li>将交集、并集、差集的结果保存：<code>sinterstore des key [key...]</code>、<code>sunionstore des key [key...]</code>、<code>sdiffstore des key [key...]</code>，结果保存在des中</li>
</ul>
<h3 id="内部编码"><a href="#内部编码" class="headerlink" title="内部编码"></a>内部编码</h3><p>集合类型的内部编码有两种：</p>
<ul>
<li>intset：当集合中的元素都是整数且元素个数小于<code>set-max-intset-entries</code>配置（默认512个）时，Redis会选用intset来实现集合</li>
<li>当集合类型无法满足intset的条件时，Redis会使用hashtable作为内部实现</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>给用户添加标签：<code>sadd user tag</code></li>
<li>给标签添加用户：<code>sadd tag user</code></li>
<li>删除用户下的标签：<code>srem user tag</code></li>
<li>删除标签下的用户：<code>srem tag user</code></li>
<li>计算用户共同感兴趣的标签：<code>sinter user1 user2</code></li>
<li>生成随机数（抽奖）：<code>srandmember/spop</code></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://crazystrome.github.io/2020/10/14/Redis%E8%BF%90%E7%BB%B4-%E6%8C%81%E4%B9%85%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="crazyStrome">
      <meta itemprop="description" content="啥都写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="crazyStrome的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/14/Redis%E8%BF%90%E7%BB%B4-%E6%8C%81%E4%B9%85%E5%8C%96/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-14 18:23:20" itemprop="dateCreated datePublished" datetime="2020-10-14T18:23:20+08:00">2020-10-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-27 14:53:44" itemprop="dateModified" datetime="2020-04-27T14:53:44+08:00">2020-04-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="5-持久化"><a href="#5-持久化" class="headerlink" title="5  持久化"></a>5  持久化</h1><p>持久化功能有效地避免因进程退出而造成的数据丢失问题。</p>
<h2 id="5-1-RDB"><a href="#5-1-RDB" class="headerlink" title="5.1  RDB"></a>5.1  RDB</h2><p>RDB持久化是把当前进程数据生成快照保存到硬盘的过程，触发RDB持久化过程分为手动触发和自动触发。</p>
<h3 id="5-1-1-触发机制"><a href="#5-1-1-触发机制" class="headerlink" title="5.1.1  触发机制"></a>5.1.1  触发机制</h3><p>手动触发分别对应save和bgsave命令：</p>
<p>save命令：阻塞当前Redis服务器，直到RDB过程完成为止，对于内存比较大的实例会造成长时间的阻塞，线上环境不建议用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DB saved on disk</span><br></pre></td></tr></table></figure>

<p>bgsave命令：Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。</p>
<p>Redis内部所有的涉及RDB的操作都采用bgsave的方式，而save命令已经废弃。</p>
<p>Redis内部还存在自动触发RDB的持久化机制。</p>
<ol>
<li>使用save相关配置，如<code>save m n</code>。表示m秒内数据集存在n次修改时，自动触发bgsave。</li>
<li>如果从节点执行全量复制操作，主节点自动执行bgsave生成RDB文件并发给从节点。</li>
<li>执行<code>debug reload</code>命令重新加载Redis时，也会自动触发save操作。</li>
<li>默认情况下执行shutdown命令时，如果没有开启AOF持久化功能则自动执行bgsave。</li>
</ol>
<h3 id="5-1-2-流程说明"><a href="#5-1-2-流程说明" class="headerlink" title="5.1.2  流程说明"></a>5.1.2  流程说明</h3><p><img src="https://i.loli.net/2020/04/27/mgyivOI2MhKVNR9.png"></p>
<h3 id="5-1-3-RDB文件的处理"><a href="#5-1-3-RDB文件的处理" class="headerlink" title="5.1.3  RDB文件的处理"></a>5.1.3  RDB文件的处理</h3><p>保存：保存在配置指定的目录下，文件名通过dbfilename配置指定。</p>
<p>压缩：默认使用LZF算法对RDB文件进行压缩处理，压缩后的文件远远小于内存大小。</p>
<p>校验：如果Redis加载损坏的RDB文件时拒绝启动。</p>
<h3 id="5-1-4-RDB的优缺点"><a href="#5-1-4-RDB的优缺点" class="headerlink" title="5.1.4  RDB的优缺点"></a>5.1.4  RDB的优缺点</h3><p>优点：</p>
<ol>
<li>RDB是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的数据快照。非常适用于备份，全量复制的场景。</li>
<li>Redis加载RDB恢复数据远远快于AOF</li>
</ol>
<p>缺点：</p>
<ol>
<li>RDB方式数据没办法做到实时持久化/秒级持久化。因为bgsave每次运行都要执行fork操作创建子进程，属于重量级操作，频繁执行成本太高。</li>
<li>RDB文件使用特定二进制格式保存，Redis演进过程中有多个格式的RDB版本，存在老版本Redis服务无法兼容新版RDB格式的问题</li>
</ol>
<h2 id="5-2-AOF"><a href="#5-2-AOF" class="headerlink" title="5.2  AOF"></a>5.2  AOF</h2><p>AOF（Append Of File）持久化：以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中的命令达到恢复数据的目的。AOF的主要作用是解决了数据持久化的实时性，目前是Redis持久化额主流方式。</p>
<h3 id="5-2-1-使用AOF"><a href="#5-2-1-使用AOF" class="headerlink" title="5.2.1  使用AOF"></a>5.2.1  使用AOF</h3><p>开启AOF功能需要设置配置：appendonly yes，默认不开启。AOF文件名通过appendfilename配置设置，默认文件名是appendonly.aof。</p>
<p>AOF的工作流程操作：命令写入（Append）、文件同步（Sync）、文件重写（rewrite）、重启加载（load）。</p>
<p><img src="https://i.loli.net/2020/04/27/behf38gvKjQL9zO.png"></p>
<ol>
<li>所有的写入命令会追加到aof_buf中</li>
<li>AOF缓冲区根据对应策略向硬盘做同步操作</li>
<li>随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的。</li>
<li>当Redis服务重启时，可以加载AOF文件进行数据恢复。</li>
</ol>
<h3 id="5-2-2-命令写入"><a href="#5-2-2-命令写入" class="headerlink" title="5.2.2  命令写入"></a>5.2.2  命令写入</h3><p>AOF命令写入ed内容直接是文本协议格式。</p>
<ol>
<li>文本协议格式具有很好的兼容性</li>
<li>开启AOF后，所有的写入命令都包含追加操作，直接采用协议格式，避免了二次处理开销</li>
<li>文本协议具有可读性，方便直接修改和处理。</li>
</ol>
<p>AOF把命令追加到缓冲区：Redis使用单线程响应命令，如果每次写AOF文件命令都直接追加到硬盘，那么性能完全取决于当前硬盘的负载。先写入缓冲区aof_buf中，还有一个好处，Redis可以提供多种缓冲区同步硬盘的策略，在性能和安全性方面做出平衡。</p>
<h3 id="5-2-3-文件同步"><a href="#5-2-3-文件同步" class="headerlink" title="5.2.3  文件同步"></a>5.2.3  文件同步</h3><p><img src="https://i.loli.net/2020/04/27/3z4I9S6FciYBnkg.png"></p>
<p>系统调用write和fsync的说明：</p>
<ul>
<li>write操作会触发延迟写机制。Linux在内核提供页缓冲区用来提高磁盘IO性能。write操作在写入系统缓冲区后直接返回。同步磁盘操作依赖于系统调度机制。</li>
<li>fsync针对单个文件操作，做强制磁盘同步，fsync将阻塞直到写入硬盘完成后返回，保证数据持久化。</li>
</ul>
<p>配置为always时，每次写入都要同步AOF</p>
<p>配置为no时，由操作系统控制AOF的更新</p>
<p>配置为everysec，是建议的同步策略，做到兼顾性能和数据安全性。</p>
<h3 id="5-2-4-重写机制"><a href="#5-2-4-重写机制" class="headerlink" title="5.2.4  重写机制"></a>5.2.4  重写机制</h3><p>Redis引入AOF重写机制压缩文件体积。AOF文件重写是把Redis进程内的数据转化为写命令同步到新AOF文件的过程。</p>
<p>重写后AOF文件变小的原因：</p>
<ol>
<li>进程内已经超时的数据不再写入文件</li>
<li>旧的AOF文件含有无效命令，例如删除命令。重写使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令。</li>
<li>多条写命令可以合并为一个。</li>
</ol>
<p>AOF重写降低了文件占用空间，可以更快的被Redis加载。</p>
<p>AOF重写可以手动触发和自动触发。</p>
<p>手动触发调用bgrewriteaof命令。</p>
<p>自动触发：根据auto-aof-rewrite-min-size和auto-aof-rewrite-percentage参<br>数确定自动触发时机。</p>
<p><img src="https://i.loli.net/2020/04/27/DzTuVjr5Lk8eSsm.png"></p>
<h3 id="5-2-5-重启加载"><a href="#5-2-5-重启加载" class="headerlink" title="5.2.5  重启加载"></a>5.2.5  重启加载</h3><p><img src="https://i.loli.net/2020/04/27/lijGV2bxICFwBzt.png"></p>
<h2 id="5-3-问题定位与优化"><a href="#5-3-问题定位与优化" class="headerlink" title="5.3  问题定位与优化"></a>5.3  问题定位与优化</h2><h3 id="5-3-1-fork操作"><a href="#5-3-1-fork操作" class="headerlink" title="5.3.1  fork操作"></a>5.3.1  fork操作</h3><p>fork创建的子进程不需要拷贝父进程的物理内存空间，但是会复制父进程的空间内存页表。所以会耗时。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://crazystrome.github.io/2020/10/14/OnJava8%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="crazyStrome">
      <meta itemprop="description" content="啥都写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="crazyStrome的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/14/OnJava8%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-14 18:23:20" itemprop="dateCreated datePublished" datetime="2020-10-14T18:23:20+08:00">2020-10-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-20 13:36:34" itemprop="dateModified" datetime="2020-05-20T13:36:34+08:00">2020-05-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h1 id="CH14-流式编程"><a href="#CH14-流式编程" class="headerlink" title="CH14  流式编程"></a>CH14  流式编程</h1><p>流式编程就是把一系列对象看成是一条数据流，像是流水线一样，开发者可以在这条流水线上进行替换，读取，剔除等操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// streams/Randoms.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Randoms</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Random(<span class="number">47</span>)</span><br><span class="line">            .ints(<span class="number">5</span>, <span class="number">20</span>)</span><br><span class="line">            .distinct()</span><br><span class="line">            .limit(<span class="number">7</span>)</span><br><span class="line">            .sorted()</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>中间流操作：</p>
<ul>
<li>distinct()用来获取非重复的元素。</li>
<li>limit()方法获取一定数量的元素。</li>
<li>sorted()排序。</li>
<li>forEach()遍历对每个元素进行操作。</li>
</ul>
<p>流式编程使用内部迭代，这种机制使得编写的代码可读性更强。</p>
<p>流是懒加载的，这代表它只在绝对必要时才计算。</p>
<h2 id="流支持"><a href="#流支持" class="headerlink" title="流支持"></a>流支持</h2><p>接口增加默认方法的极具说服力的理由是它允许在不破坏已使用接口的代码的情况下，在接口中增加新的方法。默认方法有时也被称为<em>守卫方法</em>或<em>虚拟扩展方法</em>。</p>
<p>Java8在接口中添加被 <code>default</code>（<code>默认</code>）修饰的方法。通过这种方案，设计者们可以将流式（<em>stream</em>）方法平滑地嵌入到现有类中。</p>
<p>流操作的类型有三种：创建流、修改流（中间操作）、消费流操作。</p>
<h2 id="流创建"><a href="#流创建" class="headerlink" title="流创建"></a>流创建</h2><p>通过Stream.of()可以将一组元素转化为流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// streams/StreamOf.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamOf</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream.of(<span class="keyword">new</span> Bubble(<span class="number">1</span>), <span class="keyword">new</span> Bubble(<span class="number">2</span>), <span class="keyword">new</span> Bubble(<span class="number">3</span>))</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">        Stream.of(<span class="string">&quot;It&#x27;s &quot;</span>, <span class="string">&quot;a &quot;</span>, <span class="string">&quot;wonderful &quot;</span>, <span class="string">&quot;day &quot;</span>, <span class="string">&quot;for &quot;</span>, <span class="string">&quot;pie!&quot;</span>)</span><br><span class="line">            .forEach(System.out::print);</span><br><span class="line">        System.out.println();</span><br><span class="line">        Stream.of(<span class="number">3.14159</span>, <span class="number">2.718</span>, <span class="number">1.618</span>)</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>每个集合都可以通过调用stream()方法来产生一个流。</p>
<p><code>mapToInt()</code> 方法将一个对象流（object stream）转换成为包含整型数字的 <code>IntStream</code>。</p>
<p><code>boxed()</code> 流操作将会自动地把基本类型包装成为对应的装箱类型。</p>
<p><code>IntStream</code> 类提供了 <code>range()</code> 方法用于生成整型序列的流。编写循环时，这个方法会更加便利：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// streams/Ranges.java</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.IntStream.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ranges</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 传统方法:</span></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">            result += i;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="comment">// for-in 循环:</span></span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : range(<span class="number">10</span>, <span class="number">20</span>).toArray())</span><br><span class="line">            result += i;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="comment">// 使用流:</span></span><br><span class="line">        System.out.println(range(<span class="number">10</span>, <span class="number">20</span>).sum());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>generate()是用来生成一个序列的，需要传入一个Supplier<T>接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// streams/Generator.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generator</span> <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">char</span>[] letters = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>.toCharArray();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span> + letters[rand.nextInt(letters.length)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String word = Stream.generate(<span class="keyword">new</span> Generator())</span><br><span class="line">                            .limit(<span class="number">30</span>)</span><br><span class="line">                            .collect(Collectors.joining());</span><br><span class="line">        System.out.println(word);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>Stream.</strong><code>iterate()</code> 以种子（第一个参数）开头，并将其传给方法（第二个参数）。方法的结果将添加到流，并存储作为第一个参数用于下次调用 <code>iterate()</code></p>
<p><code>skip()</code> 操作根据参数丢弃指定数量的流元素。</p>
<h2 id="流的建造者模式"><a href="#流的建造者模式" class="headerlink" title="流的建造者模式"></a>流的建造者模式</h2><p>builder()可以构建一个stream</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// streams/FileToWordsBuilder.java</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileToWordsBuilder</span> </span>&#123;</span><br><span class="line">    Stream.Builder&lt;String&gt; builder = Stream.builder();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileToWordsBuilder</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Files.lines(Paths.get(filePath))</span><br><span class="line">             .skip(<span class="number">1</span>) <span class="comment">// 略过开头的注释行</span></span><br><span class="line">             .forEach(line -&gt; &#123;</span><br><span class="line">                  <span class="keyword">for</span> (String w : line.split(<span class="string">&quot;[ .?,]+&quot;</span>))</span><br><span class="line">                      builder.add(w);</span><br><span class="line">              &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Stream&lt;String&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> builder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> FileToWordsBuilder(<span class="string">&quot;Cheese.dat&quot;</span>)</span><br><span class="line">            .stream()</span><br><span class="line">            .limit(<span class="number">7</span>)</span><br><span class="line">            .map(w -&gt; w + <span class="string">&quot; &quot;</span>)</span><br><span class="line">            .forEach(System.out::print);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p><code>Arrays</code> 类中含有一个名为 <code>stream()</code> 的静态方法用于把数组转换成为流。</p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>Java 8 在 <code>java.util.regex.Pattern</code> 中增加了一个新的方法 <code>splitAsStream()</code>。这个方法可以根据传入的公式将字符序列转化为流。但是有一个限制，输入只能是 <strong>CharSequence</strong>，因此不能将流作为 <code>splitAsStream()</code> 的参数。</p>
<p>现在，当你调用 <code>stream()</code> 的时候，可以像往常一样获取一个流，但这次你可以多次调用 <code>stream()</code> 在已存储的字符串中创建一个新的流。这里有个限制，整个文件必须存储在内存中；在大多数情况下这并不是什么问题，但是这损失了流操作非常重要的优势：</p>
<ol>
<li>流“不需要存储”。当然它们需要一些内部存储，但是这只是序列的一小部分，和持有整个序列并不相同。</li>
<li>它们是懒加载计算的。</li>
</ol>
<h2 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h2><p>中间操作用于从一个流中获取对象，并将对象作为另一个流从后端输出，以连接到其他操作。</p>
<h3 id="跟踪和调试"><a href="#跟踪和调试" class="headerlink" title="跟踪和调试"></a>跟踪和调试</h3><p>peek()可以无修改地查看流中的元素。</p>
<h3 id="流元素排序"><a href="#流元素排序" class="headerlink" title="流元素排序"></a>流元素排序</h3><p>在sorted()中传入一个Comparator参数可以可以定义排序规则。</p>
<h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h3><p>distinct()用于消除重复的元素。</p>
<p>filter(Predicate)用来过滤结果为true的元素。</p>
<h3 id="应用函数到元素"><a href="#应用函数到元素" class="headerlink" title="应用函数到元素"></a>应用函数到元素</h3><ul>
<li><code>map(Function)</code>：将函数操作应用在输入流的元素中，并将返回值传递到输出流中。</li>
<li><code>mapToInt(ToIntFunction)</code>：操作同上，但结果是 <strong>IntStream</strong>。</li>
<li><code>mapToLong(ToLongFunction)</code>：操作同上，但结果是 <strong>LongStream</strong>。</li>
<li><code>mapToDouble(ToDoubleFunction)</code>：操作同上，但结果是 <strong>DoubleStream</strong>。</li>
</ul>
<h3 id="在map-中组合流"><a href="#在map-中组合流" class="headerlink" title="在map()中组合流"></a>在map()中组合流</h3><p>假设我们现在有了一个传入的元素流，并且打算对流元素使用 <code>map()</code> 函数。现在你已经找到了一些可爱并独一无二的函数功能，但是问题来了：这个函数功能是产生一个流。我们想要产生一个元素流，而实际却产生了一个元素流的流。</p>
<p><code>flatMap()</code> 做了两件事：将产生流的函数应用在每个元素上（与 <code>map()</code> 所做的相同），然后将每个流都扁平化为元素，因而最终产生的仅仅是元素。</p>
<p><code>flatMap(Function)</code>：当 <code>Function</code> 产生流时使用。</p>
<p><code>flatMapToInt(Function)</code>：当 <code>Function</code> 产生 <code>IntStream</code> 时使用。</p>
<p><code>flatMapToLong(Function)</code>：当 <code>Function</code> 产生 <code>LongStream</code> 时使用。</p>
<p><code>flatMapToDouble(Function)</code>：当 <code>Function</code> 产生 <code>DoubleStream</code> 时使用。</p>
<p>为了弄清它的工作原理，我们从传入一个刻意设计的函数给 <code>map()</code> 开始。该函数接受一个整数并产生一个字符串流：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// streams/StreamOfStreams.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamOfStreams</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">        .map(i -&gt; Stream.of(<span class="string">&quot;Gonzo&quot;</span>, <span class="string">&quot;Kermit&quot;</span>, <span class="string">&quot;Beaker&quot;</span>))</span><br><span class="line">        .map(e-&gt; e.getClass().getName())</span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.util.stream.ReferencePipeline$Head</span><br><span class="line">java.util.stream.ReferencePipeline$Head</span><br><span class="line">java.util.stream.ReferencePipeline$Head</span><br></pre></td></tr></table></figure>

<p>使用flatMap()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// streams/FlatMap.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlatMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">        .flatMap(i -&gt; Stream.of(<span class="string">&quot;Gonzo&quot;</span>, <span class="string">&quot;Fozzie&quot;</span>, <span class="string">&quot;Beaker&quot;</span>))</span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Gonzo</span><br><span class="line">Fozzie</span><br><span class="line">Beaker</span><br><span class="line">Gonzo</span><br><span class="line">Fozzie</span><br><span class="line">Beaker</span><br><span class="line">Gonzo</span><br><span class="line">Fozzie</span><br><span class="line">Beaker</span><br></pre></td></tr></table></figure>

<p>IntStream.concat()以参数顺序组合两个流。</p>
<h2 id="Optinal类"><a href="#Optinal类" class="headerlink" title="Optinal类"></a>Optinal类</h2><p>Optinal类在流到达结尾时会提示。</p>
<ul>
<li><p><code>findFirst()</code> 返回一个包含第一个元素的 <strong>Optional</strong> 对象，如果流为空则返回 <strong>Optional.empty</strong></p>
</li>
<li><p><code>findAny()</code> 返回包含任意元素的 <strong>Optional</strong> 对象，如果流为空则返回 <strong>Optional.empty</strong></p>
</li>
<li><p><code>max()</code> 和 <code>min()</code> 返回一个包含最大值或者最小值的 <strong>Optional</strong> 对象，如果流为空则返回 <strong>Optional.empty</strong></p>
<p><code>reduce()</code> 不再以 <code>identity</code> 形式开头，而是将其返回值包装在 <strong>Optional</strong> 中。（<code>identity</code> 对象成为其他形式的 <code>reduce()</code> 的默认结果，因此不存在空结果的风险）</p>
</li>
</ul>
<p>对于数字流 <strong>IntStream</strong>、<strong>LongStream</strong> 和 <strong>DoubleStream</strong>，<code>average()</code> 会将结果包装在 <strong>Optional</strong> 以防止流为空。</p>
<h3 id="便利函数"><a href="#便利函数" class="headerlink" title="便利函数"></a>便利函数</h3><ul>
<li><code>ifPresent(Consumer)</code>：当值存在时调用 <strong>Consumer</strong>，否则什么也不做。</li>
<li><code>orElse(otherObject)</code>：如果值存在则直接返回，否则生成 <strong>otherObject</strong>。</li>
<li><code>orElseGet(Supplier)</code>：如果值存在则直接返回，否则使用 <strong>Supplier</strong> 函数生成一个可替代对象。</li>
<li><code>orElseThrow(Supplier)</code>：如果值存在直接返回，否则使用 <strong>Supplier</strong> 函数生成一个异常。</li>
</ul>
<h3 id="创建Optional"><a href="#创建Optional" class="headerlink" title="创建Optional"></a>创建Optional</h3><p>当我们在自己的代码中加入 <strong>Optional</strong> 时，可以使用下面 3 个静态方法：</p>
<ul>
<li><code>empty()</code>：生成一个空 <strong>Optional</strong>。</li>
<li><code>of(value)</code>：将一个非空值包装到 <strong>Optional</strong> 里。</li>
<li><code>ofNullable(value)</code>：针对一个可能为空的值，为空时自动生成 <strong>Optional.empty</strong>，否则将值包装在 <strong>Optional</strong> 中。</li>
</ul>
<h3 id="Optional对象操作"><a href="#Optional对象操作" class="headerlink" title="Optional对象操作"></a>Optional对象操作</h3><p>当我们的流管道生成了 <strong>Optional</strong> 对象，下面 3 个方法可使得 <strong>Optional</strong> 的后续能做更多的操作：</p>
<ul>
<li><code>filter(Predicate)</code>：将 <strong>Predicate</strong> 应用于 <strong>Optional</strong> 中的内容并返回结果。当 <strong>Optional</strong> 不满足 <strong>Predicate</strong> 时返回空。如果 <strong>Optional</strong> 为空，则直接返回。</li>
<li><code>map(Function)</code>：如果 <strong>Optional</strong> 不为空，应用 <strong>Function</strong> 于 <strong>Optional</strong> 中的内容，并返回结果。否则直接返回 <strong>Optional.empty</strong>。</li>
<li><code>flatMap(Function)</code>：同 <code>map()</code>，但是提供的映射函数将结果包装在 <strong>Optional</strong> 对象中，因此 <code>flatMap()</code> 不会在最后进行任何包装。</li>
</ul>
<p>以上方法都不适用于数值型 <strong>Optional</strong>。一般来说，流的 <code>filter()</code> 会在 <strong>Predicate</strong> 返回 <code>false</code> 时移除流元素。而 <code>Optional.filter()</code> 在失败时不会删除 <strong>Optional</strong>，而是将其保留下来，并转化为空。</p>
<h2 id="终端操作"><a href="#终端操作" class="headerlink" title="终端操作"></a>终端操作</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul>
<li><code>toArray()</code>：将流转换成适当类型的数组。</li>
<li><code>toArray(generator)</code>：在特殊情况下，生成自定义类型的数组。</li>
</ul>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><ul>
<li><code>forEach(Consumer)</code>常见如 <code>System.out::println</code> 作为 <strong>Consumer</strong> 函数。</li>
<li><code>forEachOrdered(Consumer)</code>： 保证 <code>forEach</code> 按照原始流顺序操作。</li>
</ul>
<p><code>parallel()</code>：可实现多处理器并行操作。实现原理为将流分割为多个（通常数目为 CPU 核心数）并在不同处理器上分别执行操作。</p>
<p>同时使用了 <code>parallel()</code> 和 <code>forEachOrdered()</code> 来强制保持原始流顺序。</p>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><ul>
<li><code>collect(Collector)</code>：使用 <strong>Collector</strong> 收集流元素到结果集合中。</li>
<li><code>collect(Supplier, BiConsumer, BiConsumer)</code>：同上，第一个参数 <strong>Supplier</strong> 创建了一个新结果集合，第二个参数 <strong>BiConsumer</strong> 将下一个元素包含到结果中，第三个参数 <strong>BiConsumer</strong> 用于将两个值组合起来。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// streams/TreeSetOfWords.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetOfWords</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">    main(String[] args) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Set&lt;String&gt; words2 =</span><br><span class="line">                Files.lines(Paths.get(<span class="string">&quot;TreeSetOfWords.java&quot;</span>))</span><br><span class="line">                        .flatMap(s -&gt; Arrays.stream(s.split(<span class="string">&quot;\\W+&quot;</span>)))</span><br><span class="line">                        .filter(s -&gt; !s.matches(<span class="string">&quot;\\d+&quot;</span>)) <span class="comment">// No numbers</span></span><br><span class="line">                        .map(String::trim)</span><br><span class="line">                        .filter(s -&gt; s.length() &gt; <span class="number">2</span>)</span><br><span class="line">                        .limit(<span class="number">100</span>)</span><br><span class="line">                        .collect(Collectors.toCollection(TreeSet::<span class="keyword">new</span>));</span><br><span class="line">        System.out.println(words2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// streams/MapCollector.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Character c;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Integer i;</span><br><span class="line">    Pair(Character c, Integer i) &#123;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Character <span class="title">getC</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getI</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Pair(&quot;</span> + c + <span class="string">&quot;, &quot;</span> + i + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomPair</span> </span>&#123;</span><br><span class="line">    Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="comment">// An infinite iterator of random capital letters:</span></span><br><span class="line">    Iterator&lt;Character&gt; capChars = rand.ints(<span class="number">65</span>,<span class="number">91</span>)</span><br><span class="line">            .mapToObj(i -&gt; (<span class="keyword">char</span>)i)</span><br><span class="line">            .iterator();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Stream&lt;Pair&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rand.ints(<span class="number">100</span>, <span class="number">1000</span>).distinct()</span><br><span class="line">                .mapToObj(i -&gt; <span class="keyword">new</span> Pair(capChars.next(), i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapCollector</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Character&gt; map =</span><br><span class="line">                <span class="keyword">new</span> RandomPair().stream()</span><br><span class="line">                        .limit(<span class="number">8</span>)</span><br><span class="line">                        .collect(</span><br><span class="line">                                Collectors.toMap(Pair::getI, Pair::getC));</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><ul>
<li><code>reduce(BinaryOperator)</code>：使用 <strong>BinaryOperator</strong> 来组合所有流中的元素。因为流可能为空，其返回值为 <strong>Optional</strong>。</li>
<li><code>reduce(identity, BinaryOperator)</code>：功能同上，但是使用 <strong>identity</strong> 作为其组合的初始值。因此如果流为空，<strong>identity</strong> 就是结果。</li>
<li><code>reduce(identity, BiFunction, BinaryOperator)</code>：更复杂的使用形式（暂不介绍），这里把它包含在内，因为它可以提高效率。通常，我们可以显式地组合 <code>map()</code> 和 <code>reduce()</code> 来更简单的表达它。</li>
</ul>
<h3 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h3><ul>
<li><code>allMatch(Predicate)</code> ：如果流的每个元素根据提供的 <strong>Predicate</strong> 都返回 true 时，结果返回为 true。在第一个 false 时，则停止执行计算。</li>
<li><code>anyMatch(Predicate)</code>：如果流中的任意一个元素根据提供的 <strong>Predicate</strong> 返回 true 时，结果返回为 true。在第一个 false 是停止执行计算。</li>
<li><code>noneMatch(Predicate)</code>：如果流的每个元素根据提供的 <strong>Predicate</strong> 都返回 false 时，结果返回为 true。在第一个 true 时停止执行计算。</li>
</ul>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><ul>
<li><code>findFirst()</code>：返回第一个流元素的 <strong>Optional</strong>，如果流为空返回 <strong>Optional.empty</strong>。</li>
<li><code>findAny(</code>：返回含有任意流元素的 <strong>Optional</strong>，如果流为空返回 <strong>Optional.empty</strong></li>
</ul>
<h3 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h3><ul>
<li><code>count()</code>：流中的元素个数。</li>
<li><code>max(Comparator)</code>：根据所传入的 <strong>Comparator</strong> 所决定的“最大”元素。</li>
<li><code>min(Comparator)</code>：根据所传入的 <strong>Comparator</strong> 所决定的“最小”元素。</li>
</ul>
<h3 id="数字流信息"><a href="#数字流信息" class="headerlink" title="数字流信息"></a>数字流信息</h3><ul>
<li><code>average()</code> ：求取流元素平均值。</li>
<li><code>max()</code> 和 <code>min()</code>：数值流操作无需 <strong>Comparator</strong>。</li>
<li><code>sum()</code>：对所有流元素进行求和。</li>
<li><code>summaryStatistics()</code>：生成可能有用的数据。目前并不太清楚这个方法存在的必要性，因为我们其实可以用更直接的方法获得需要的数据。</li>
</ul>
<h1 id="CH15-异常"><a href="#CH15-异常" class="headerlink" title="CH15 异常"></a>CH15 异常</h1><h2 id="异常概念"><a href="#异常概念" class="headerlink" title="异常概念"></a>异常概念</h2><p>异常有助于程序的健壮性。</p>
<h2 id="基本异常"><a href="#基本异常" class="headerlink" title="基本异常"></a>基本异常</h2><p>异常情形（exceptional condition）是指阻止当前方法或作用域继续执行的问题。</p>
<h2 id="异常参数"><a href="#异常参数" class="headerlink" title="异常参数"></a>异常参数</h2><p>所有标准异常类都有两个构造器：一个是无参构造器；另一个是接受字符串作为参数，以便能把相关信息放入异常对象的构造器</p>
<p><strong>Throwable</strong> 对象，它是异常类型的根类。</p>
<h2 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h2><p>监控区域：一段可能产生异常的代码，并且后面跟着处理这些异常的代码。</p>
<h3 id="try语句块"><a href="#try语句块" class="headerlink" title="try语句块"></a>try语句块</h3><h3 id="异常处理程序"><a href="#异常处理程序" class="headerlink" title="异常处理程序"></a>异常处理程序</h3><p>catch</p>
<h3 id="终止与恢复"><a href="#终止与恢复" class="headerlink" title="终止与恢复"></a>终止与恢复</h3><p>Java 支持终止模型（它是 Java 和 C++所支持的模型）。在这种模型中，将假设错误非常严重，以至于程序无法返回到异常发生的地方继续执行。一旦异常被抛出，就表明错误已无法挽回，也不能回来继续执行。</p>
<p>另一种称为恢复模型。意思是异常处理程序的工作是修正错误，然后重新尝试调用出问题的方法，并认为第二次能成功。对于恢复模型，通常希望异常被处理之后能继续执行程序。如果想要用 Java 实现类似恢复的行为，那么在遇见错误时就不能抛出异常，而是调用方法来修正该错误。或者，把 try 块放在 while 循环里，这样就不断地进入 try 块，直到得到满意的结果。</p>
<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>要自己定义异常类，必须从已有的异常类继承，最好是选择意思相近的异常类继承（不过这样的异常并不容易找）。</p>
<p>继承Exception类或者子类</p>
<h3 id="异常与记录日志"><a href="#异常与记录日志" class="headerlink" title="异常与记录日志"></a>异常与记录日志</h3><p>静态的 Logger.getLogger() 方法创建了一个 String 参数相关联的 Logger 对象（通常与错误相关的包名和类名），这个 Logger 对象会将其输出发送到 System.err。</p>
<h3 id="异常声明"><a href="#异常声明" class="headerlink" title="异常声明"></a>异常声明</h3><p>异常说明使用了附加的关键字 throws，后面接一个所有潜在异常类型的列表</p>
<h2 id="捕获所有的异常"><a href="#捕获所有的异常" class="headerlink" title="捕获所有的异常"></a>捕获所有的异常</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exceptions/ExceptionMethods.java</span></span><br><span class="line"><span class="comment">// Demonstrating the Exception Methods</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionMethods</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;My Exception&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Caught Exception&quot;</span>);</span><br><span class="line">            System.out.println(</span><br><span class="line">                    <span class="string">&quot;getMessage():&quot;</span> + e.getMessage());</span><br><span class="line">            System.out.println(<span class="string">&quot;getLocalizedMessage():&quot;</span> +</span><br><span class="line">                    e.getLocalizedMessage());</span><br><span class="line">            System.out.println(<span class="string">&quot;toString():&quot;</span> + e);</span><br><span class="line">            System.out.println(<span class="string">&quot;printStackTrace():&quot;</span>);</span><br><span class="line">            e.printStackTrace(System.out);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多重捕获"><a href="#多重捕获" class="headerlink" title="多重捕获"></a>多重捕获</h3><p>使用多个catch语句，不过包括的异常要从小到大。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exceptions/MultiCatch.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiCatch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">x</span><span class="params">()</span> <span class="keyword">throws</span> Except1, Except2, Except3, Except4 </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            x();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span>(Except1 | Except2 | Except3 | Except4 e) &#123;</span><br><span class="line">            process();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="栈轨迹"><a href="#栈轨迹" class="headerlink" title="栈轨迹"></a>栈轨迹</h3><p>printStackTrace() 方法所提供的信息可以通过 getStackTrace() 方法来直接访问，这个方法将返回一个由栈轨迹中的元素所构成的数组，其中每一个元素都表示栈中的一桢。元素 0 是栈顶元素，并且是调用序列中的最后一个方法调用（这个 Throwable 被创建和抛出之处）。数组中的最后一个元素和栈底是调用序列中的第一个方法调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exceptions/WhoCalled.java</span></span><br><span class="line"><span class="comment">// Programmatic access to stack trace information</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhoCalled</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// Generate an exception to fill in the stack trace</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            <span class="keyword">for</span>(StackTraceElement ste : e.getStackTrace())</span><br><span class="line">                System.out.println(ste.getMethodName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; f(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123; g(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        f();</span><br><span class="line">        System.out.println(<span class="string">&quot;*******&quot;</span>);</span><br><span class="line">        g();</span><br><span class="line">        System.out.println(<span class="string">&quot;*******&quot;</span>);</span><br><span class="line">        h();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重新抛出异常"><a href="#重新抛出异常" class="headerlink" title="重新抛出异常"></a>重新抛出异常</h3><p>如果只是把当前异常对象重新抛出，那么 printStackTrace() 方法显示的将是原来异常抛出点的调用栈信息，而并非重新抛出点的信息。要想更新这个信息，可以调用 filInStackTrace() 方法，这将返回一个 Throwable 对象，它是通过把当前调用栈信息填入原来那个异常对象而建立的</p>
<p>调用 fillInStackTrace() 的那一行就成了异常的新发生地了。</p>
<h3 id="异常链"><a href="#异常链" class="headerlink" title="异常链"></a>异常链</h3><p>常常会想要在捕获一个异常后抛出另一个异常，并且希望把原始异常的信息保存下来，这被称为异常链。</p>
<p>在 JDK1.4 以前，程序员必须自己编写代码来保存原始异常的信息。现在所有 Throwable 的子类在构造器中都可以接受一个 cause（因由）对象作为参数。这个 cause 就用来表示原始异常，这样通过把原始异常传递给新的异常，使得即使在当前位置创建并抛出了新的异常，也能通过这个异常链追踪到异常最初发生的位置。</p>
<p>有趣的是，在 Throwable 的子类中，只有三种基本的异常类提供了带 cause 参数的构造器。它们是 Error（用于 Java 虚拟机报告系统错误）、Exception 以及 RuntimeException。</p>
<h2 id="Java标准异常"><a href="#Java标准异常" class="headerlink" title="Java标准异常"></a>Java标准异常</h2><p>Throwable 这个 Java 类被用来表示任何可以作为异常被抛出的类。Throwable 对象可分为两种类型（指从 Throwable 继承而得到的类型）：Error 用来表示编译时和系统错误（除特殊情况外，一般不用你关心）；Exception 是可以被抛出的基本类型，在 Java 类库、用户方法以及运行时故障中都可能抛出 Exception 型异常。所以 Java 程序员关心的基类型通常是 Exception。</p>
<h3 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h3><p>RuntimeException 代表的是编程错误：</p>
<ol>
<li>无法预料的错误。比如从你控制范围之外传递进来的 null 引用。</li>
<li>作为程序员，应该在代码中进行检查的错误。（比如对于 ArrayIndexOutOfBoundsException，就得注意一下数组的大小了。）在一个地方发生的异常，常常会在另一个地方导致错误。</li>
</ol>
<h2 id="Finally"><a href="#Finally" class="headerlink" title="Finally"></a>Finally</h2><p>有一些代码片段，可能会希望无论 try 块中的异常是否抛出，它们都能得到执行。这通常适用于内存回收之外的情况（因为回收由垃圾回收器完成），为了达到这个效果，可以在异常处理程序后面加上 finally 子句。</p>
<h3 id="在return中使用finally"><a href="#在return中使用finally" class="headerlink" title="在return中使用finally"></a>在return中使用finally</h3><p>因为 finally 子句总是会执行，所以可以从一个方法内的多个点返回，仍然能保证重要的清理工作会执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exceptions/MultipleReturns.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultipleReturns</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        System.out.println(</span><br><span class="line">                <span class="string">&quot;Initialization that requires cleanup&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Point 1&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;Point 2&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;Point 3&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">3</span>) <span class="keyword">return</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;End&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Performing cleanup&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++)</span><br><span class="line">            f(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异常限制"><a href="#异常限制" class="headerlink" title="异常限制"></a>异常限制</h2><p>当覆盖方法的时候，只能抛出在基类方法的异常说明里列出的那些异常。这个限制很有用，因为这意味着，若当基类使用的代码应用到其派生类对象的时候，一样能够工作（当然，这是面向对象的基本概念），异常也不例外。</p>
<h2 id="构造器异常"><a href="#构造器异常" class="headerlink" title="构造器异常"></a>构造器异常</h2><h2 id="Try-With-Resource用法"><a href="#Try-With-Resource用法" class="headerlink" title="Try-With-Resource用法"></a>Try-With-Resource用法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exceptions/TryWithResources.java</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryWithResources</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">                InputStream in = <span class="keyword">new</span> FileInputStream(</span><br><span class="line">                        <span class="keyword">new</span> File(<span class="string">&quot;TryWithResources.java&quot;</span>))</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">int</span> contents = in.read();</span><br><span class="line">            <span class="comment">// Process contents</span></span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">            <span class="comment">// Handle the error</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 try-with-resources 定义子句中创建的对象（在括号内）必须实现 java.lang.AutoCloseable 接口，这个接口有一个方法：close()。当在 Java 7 中引入 AutoCloseable 时，许多接口和类被修改以实现它；</p>
<h3 id="揭示细节"><a href="#揭示细节" class="headerlink" title="揭示细节"></a>揭示细节</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exceptions/AutoCloseableDetails.java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reporter</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line">    String name = getClass().getSimpleName();</span><br><span class="line">    Reporter() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Creating &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Closing &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">First</span> <span class="keyword">extends</span> <span class="title">Reporter</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Second</span> <span class="keyword">extends</span> <span class="title">Reporter</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoCloseableDetails</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">                First f = <span class="keyword">new</span> First();</span><br><span class="line">                Second s = <span class="keyword">new</span> Second()</span><br><span class="line">        ) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Creating First</span><br><span class="line">Creating Second</span><br><span class="line">Closing Second</span><br><span class="line">Closing First</span><br></pre></td></tr></table></figure>

<p>退出 try 块会调用两个对象的 close() 方法，并以与创建顺序相反的顺序关闭它们。</p>
<h1 id="CH16-代码校验"><a href="#CH16-代码校验" class="headerlink" title="CH16  代码校验"></a>CH16  代码校验</h1><h2 id="JUnit"><a href="#JUnit" class="headerlink" title="JUnit"></a>JUnit</h2><p>在 JUnit 最简单的使用中，使用 <strong>@Test</strong> 注解标记表示测试的每个方法。JUnit 将这些方法标识为单独的测试，并一次设置和运行一个测试，采取措施避免测试之间的副作用。</p>
<p><strong>@BeforeAll</strong> 注解是在任何其他测试操作之前运行一次的方法。 <strong>@AfterAll</strong> 是所有其他测试操作之后只运行一次的方法。两个方法都必须是静态的。</p>
<p><strong>@BeforeEach</strong>注解是通常用于创建和初始化公共对象的方法，并在每次测试前运行。可以将所有这样的初始化放在测试类的构造函数中，尽管我认为 <strong>@BeforeEach</strong> 更加清晰。JUnit为每个测试创建一个对象，确保测试运行之间没有副作用。然而，所有测试的所有对象都是同时创建的(而不是在测试之前创建对象)，所以使用 <strong>@BeforeEach</strong> 和构造函数之间的唯一区别是 <strong>@BeforeEach</strong> 在测试前直接调用。在大多数情况下，这不是问题，如果你愿意，可以使用构造函数方法。</p>
<p>如果你必须在每次测试后执行清理（如果修改了需要恢复的静态文件，打开文件需要关闭，打开数据库或者网络连接，etc），那就用注解 <strong>@AfterEach</strong>。</p>
<p>每个测试创建一个新的 <strong>CountedListTest</strong> 对象，任何非静态成员变量也会在同一时间创建。然后为每个测试调用 <strong>initialize()</strong> ，于是 list 被赋值为一个新的用字符串“0”、“1” 和 “2” 初始化的 <strong>CountedList</strong> 对象。观察 <strong>@BeforeEach</strong> 和 <strong>@AfterEach</strong> 的行为，这些方法在初始化和清理测试时显示有关测试的信息。</p>
<h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><p>前置条件的概念来自于契约式设计(<strong>Design By Contract, DbC</strong>), 利用断言机制实现。</p>
<h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>断言通过验证在程序执行期间满足某些条件，从而增加了程序的健壮性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// validating/Assert1.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Non-informative style of assert</span></span><br><span class="line"><span class="comment">// Must run using -ea flag:</span></span><br><span class="line"><span class="comment">// &#123;java -ea Assert1&#125;</span></span><br><span class="line"><span class="comment">// &#123;ThrowsException&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Assert1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">___[ Error Output ]___</span></span><br><span class="line"><span class="comment">Exception in thread &quot;main&quot; java.lang.AssertionError</span></span><br><span class="line"><span class="comment">at Assert1.main(Assert1.java:9)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>如果你正常运行程序，没有任何特殊的断言标志，则不会发生任何事情。你需要在运行程序时显式启用断言。一种简单的方法是使用 <strong>-ea</strong> 标志， 它也可以表示为: <strong>-enableassertion</strong>， 这将运行程序并执行任何断言语句。</p>
<p>输出中并没有包含多少有用的信息。另一方面，如果你使用 <strong>information-expression</strong> ， 将生成一条有用的消息作为异常堆栈跟踪的一部分。最有用的 <strong>information-expression</strong> 通常是一串针对程序员的文本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// validating/Assert2.java</span></span><br><span class="line"><span class="comment">// Assert with an information-expression</span></span><br><span class="line"><span class="comment">// &#123;java Assert2 -ea&#125;</span></span><br><span class="line"><span class="comment">// &#123;ThrowsException&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Assert2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> <span class="keyword">false</span>:</span><br><span class="line">    <span class="string">&quot;Here&#x27;s a message saying what happened&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">___[ Error Output ]___</span></span><br><span class="line"><span class="comment">Exception in thread &quot;main&quot; java.lang.AssertionError:</span></span><br><span class="line"><span class="comment">Here&#x27;s a message saying what happened</span></span><br><span class="line"><span class="comment">at Assert2.main(Assert2.java:8)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="Ch17-文件"><a href="#Ch17-文件" class="headerlink" title="Ch17 文件"></a>Ch17 文件</h1><p>我们将看一下文件操作的两个基本组件：</p>
<ol>
<li>文件或者目录的路径；</li>
<li>文件本身。</li>
</ol>
<h2 id="文件和目录路径"><a href="#文件和目录路径" class="headerlink" title="文件和目录路径"></a>文件和目录路径</h2><p>一个 <strong>Path</strong> 对象表示一个文件或者目录的路径，是一个跨操作系统（OS）和文件系统的抽象，目的是在构造路径时不必关注底层操作系统，代码可以在不进行修改的情况下运行在不同的操作系统上。<strong>java.nio.file.Paths</strong> 类包含一个重载方法 <strong>static get()**，该方法接受一系列 **String</strong> 字符串或一个<em>统一资源标识符</em>(URI)作为参数，并且进行转换返回一个 <strong>Path</strong> 对象</p>
<h3 id="选取路径部分片段"><a href="#选取路径部分片段" class="headerlink" title="选取路径部分片段"></a>选取路径部分片段</h3><p>可以通过 <strong>getName()</strong> 来索引 <strong>Path</strong> 的各个部分，直到达到上限 <strong>getNameCount()**。</strong>Path** 也实现了 <strong>Iterable</strong> 接口，因此我们也可以通过增强的 for-each 进行遍历。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Paths.get(<span class="string">&quot;src/main/text.txt&quot;</span>).toAbsolutePath()</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line"><span class="comment">//        System.out.println(path.toString());</span></span><br><span class="line"><span class="comment">//        Files.readAllLines(path).forEach(System.out::println);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="路径分析"><a href="#路径分析" class="headerlink" title="路径分析"></a>路径分析</h3><p><strong>Files</strong> 工具类包含一系列完整的方法用于获得 <strong>Path</strong> 相关的信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// files/PathAnalysis.java</span></span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathAnalysis</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String id, Object result)</span> </span>&#123;</span><br><span class="line">        System.out.print(id + <span class="string">&quot;: &quot;</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(System.getProperty(<span class="string">&quot;os.name&quot;</span>));</span><br><span class="line">        Path p = Paths.get(<span class="string">&quot;PathAnalysis.java&quot;</span>).toAbsolutePath();</span><br><span class="line">        say(<span class="string">&quot;Exists&quot;</span>, Files.exists(p));</span><br><span class="line">        say(<span class="string">&quot;Directory&quot;</span>, Files.isDirectory(p));</span><br><span class="line">        say(<span class="string">&quot;Executable&quot;</span>, Files.isExecutable(p));</span><br><span class="line">        say(<span class="string">&quot;Readable&quot;</span>, Files.isReadable(p));</span><br><span class="line">        say(<span class="string">&quot;RegularFile&quot;</span>, Files.isRegularFile(p));</span><br><span class="line">        say(<span class="string">&quot;Writable&quot;</span>, Files.isWritable(p));</span><br><span class="line">        say(<span class="string">&quot;notExists&quot;</span>, Files.notExists(p));</span><br><span class="line">        say(<span class="string">&quot;Hidden&quot;</span>, Files.isHidden(p));</span><br><span class="line">        say(<span class="string">&quot;size&quot;</span>, Files.size(p));</span><br><span class="line">        say(<span class="string">&quot;FileStore&quot;</span>, Files.getFileStore(p));</span><br><span class="line">        say(<span class="string">&quot;LastModified: &quot;</span>, Files.getLastModifiedTime(p));</span><br><span class="line">        say(<span class="string">&quot;Owner&quot;</span>, Files.getOwner(p));</span><br><span class="line">        say(<span class="string">&quot;ContentType&quot;</span>, Files.probeContentType(p));</span><br><span class="line">        say(<span class="string">&quot;SymbolicLink&quot;</span>, Files.isSymbolicLink(p));</span><br><span class="line">        <span class="keyword">if</span>(Files.isSymbolicLink(p))</span><br><span class="line">            say(<span class="string">&quot;SymbolicLink&quot;</span>, Files.readSymbolicLink(p));</span><br><span class="line">        <span class="keyword">if</span>(FileSystems.getDefault().supportedFileAttributeViews().contains(<span class="string">&quot;posix&quot;</span>))</span><br><span class="line">            say(<span class="string">&quot;PosixFilePermissions&quot;</span>,</span><br><span class="line">        Files.getPosixFilePermissions(p));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出:</span></span><br><span class="line"><span class="comment">Windows 10</span></span><br><span class="line"><span class="comment">Exists: true</span></span><br><span class="line"><span class="comment">Directory: false</span></span><br><span class="line"><span class="comment">Executable: true</span></span><br><span class="line"><span class="comment">Readable: true</span></span><br><span class="line"><span class="comment">RegularFile: true</span></span><br><span class="line"><span class="comment">Writable: true</span></span><br><span class="line"><span class="comment">notExists: false</span></span><br><span class="line"><span class="comment">Hidden: false</span></span><br><span class="line"><span class="comment">size: 1631</span></span><br><span class="line"><span class="comment">FileStore: SSD (C:)</span></span><br><span class="line"><span class="comment">LastModified: : 2017-05-09T12:07:00.428366Z</span></span><br><span class="line"><span class="comment">Owner: MINDVIEWTOSHIBA\Bruce (User)</span></span><br><span class="line"><span class="comment">ContentType: null</span></span><br><span class="line"><span class="comment">SymbolicLink: false</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="Paths的增删修改"><a href="#Paths的增删修改" class="headerlink" title="Paths的增删修改"></a>Paths的增删修改</h3><p>我们必须能通过对 <strong>Path</strong> 对象增加或者删除一部分来构造一个新的 <strong>Path</strong> 对象。我们使用 <strong>relativize()</strong> 移除 <strong>Path</strong> 的根路径，使用 <strong>resolve()</strong> 添加 <strong>Path</strong> 的尾路径(不一定是“可发现”的名称)。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>删除目录树：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onjava/RmDir.java</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.attribute.BasicFileAttributes;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RmDir</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rmdir</span><span class="params">(Path dir)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Files.walkFileTree(dir, <span class="keyword">new</span> SimpleFileVisitor&lt;Path&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                Files.delete(file);</span><br><span class="line">                <span class="keyword">return</span> FileVisitResult.CONTINUE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">postVisitDirectory</span><span class="params">(Path dir, IOException exc)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                Files.delete(dir);</span><br><span class="line">                <span class="keyword">return</span> FileVisitResult.CONTINUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除目录树的方法实现依赖于 <strong>Files.walkFileTree()*<em>，”walking” 目录树意味着遍历每个子目录和文件。</em>Visitor* 设计模式提供了一种标准机制来访问集合中的每个对象，然后你需要提供在每个对象上执行的操作。 此操作的定义取决于实现的 **FileVisitor</strong> 的四个抽象方法，包括：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>  **preVisitDirectory()**：在访问目录中条目之前在目录上运行。 </span><br><span class="line"><span class="number">2.</span>  **visitFile()**：运行目录中的每一个文件。  </span><br><span class="line"><span class="number">3.</span>  **visitFileFailed()**：调用无法访问的文件。   </span><br><span class="line"><span class="number">4.</span>  **postVisitDirectory()**：在访问目录中条目之后在目录上运行，包括所有的子目录</span><br></pre></td></tr></table></figure>

<p>为了简化，<strong>java.nio.file.SimpleFileVisitor</strong> 提供了所有方法的默认实现。这样，在我们的匿名内部类中，我们只需要重写非标准行为的方法：<strong>visitFile()</strong> 和 <strong>postVisitDirectory()</strong> 实现删除文件和删除目录。两者都应该返回标志位决定是否继续访问(这样就可以继续访问，直到找到所需要的)。</p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>为了完整起见，我们需要一种方法查找文件系统相关的其他信息。在这里，我们使用静态的 <strong>FileSystems</strong> 工具类获取”默认”的文件系统，但你同样也可以在 <strong>Path</strong> 对象上调用 <strong>getFileSystem()</strong> 以获取创建该 <strong>Path</strong> 的文件系统。你可以获得给定 <em>URI</em> 的文件系统，还可以构建新的文件系统(对于支持它的操作系统)。</p>
<p>一个 <strong>FileSystem</strong> 对象也能生成 <strong>WatchService</strong> 和 <strong>PathMatcher</strong> 对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// files/FileSystemDemo.java</span></span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSystemDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String id, Object o)</span> </span>&#123;</span><br><span class="line">        System.out.println(id + <span class="string">&quot;: &quot;</span> + o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(System.getProperty(<span class="string">&quot;os.name&quot;</span>));</span><br><span class="line">        FileSystem fsys = FileSystems.getDefault();</span><br><span class="line">        <span class="keyword">for</span>(FileStore fs : fsys.getFileStores())</span><br><span class="line">            show(<span class="string">&quot;File Store&quot;</span>, fs);</span><br><span class="line">        <span class="keyword">for</span>(Path rd : fsys.getRootDirectories())</span><br><span class="line">            show(<span class="string">&quot;Root Directory&quot;</span>, rd);</span><br><span class="line">        show(<span class="string">&quot;Separator&quot;</span>, fsys.getSeparator());</span><br><span class="line">        show(<span class="string">&quot;UserPrincipalLookupService&quot;</span>,</span><br><span class="line">            fsys.getUserPrincipalLookupService());</span><br><span class="line">        show(<span class="string">&quot;isOpen&quot;</span>, fsys.isOpen());</span><br><span class="line">        show(<span class="string">&quot;isReadOnly&quot;</span>, fsys.isReadOnly());</span><br><span class="line">        show(<span class="string">&quot;FileSystemProvider&quot;</span>, fsys.provider());</span><br><span class="line">        show(<span class="string">&quot;File Attribute Views&quot;</span>,</span><br><span class="line">        fsys.supportedFileAttributeViews());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出:</span></span><br><span class="line"><span class="comment">Windows 10</span></span><br><span class="line"><span class="comment">File Store: SSD (C:)</span></span><br><span class="line"><span class="comment">Root Directory: C:\</span></span><br><span class="line"><span class="comment">Root Directory: D:\</span></span><br><span class="line"><span class="comment">Separator: \</span></span><br><span class="line"><span class="comment">UserPrincipalLookupService:</span></span><br><span class="line"><span class="comment">sun.nio.fs.WindowsFileSystem$LookupService$1@15db9742</span></span><br><span class="line"><span class="comment">isOpen: true</span></span><br><span class="line"><span class="comment">isReadOnly: false</span></span><br><span class="line"><span class="comment">FileSystemProvider:</span></span><br><span class="line"><span class="comment">sun.nio.fs.WindowsFileSystemProvider@6d06d69c</span></span><br><span class="line"><span class="comment">File Attribute Views: [owner, dos, acl, basic, user]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="路径监听"><a href="#路径监听" class="headerlink" title="路径监听"></a>路径监听</h2><p>通过 <strong>WatchService</strong> 可以设置一个进程对目录中的更改做出响应。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException</span>&#123;</span><br><span class="line">        Path path = Paths.get(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        WatchService service = FileSystems.getDefault().newWatchService();</span><br><span class="line">        path.register(service, StandardWatchEventKinds.ENTRY_CREATE);</span><br><span class="line">        WatchKey key = service.take();</span><br><span class="line">        <span class="keyword">for</span> (WatchEvent event: key.pollEvents()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;event.context(): &quot;</span> + event.context()</span><br><span class="line">            + <span class="string">&quot;\nevent.count(): &quot;</span> + event.count()</span><br><span class="line">            + <span class="string">&quot;\nevent.kind(): &quot;</span> + event.kind());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只会监视给定的目录，而不是下面的所有内容。如果需要监视整个树目录，必须在整个树的每个子目录上放置一个 <strong>Watchservice</strong>。</p>
<h2 id="文件查找"><a href="#文件查找" class="headerlink" title="文件查找"></a>文件查找</h2><p>通过在 <code>FileSystem</code> 对象上调用 <code>getPathMatcher()</code> 获得一个 <code>PathMatcher</code>，然后传入您感兴趣的模式。模式有两个选项：<code>glob</code> 和 <code>regex</code>。<code>glob</code> 比较简单，实际上功能非常强大，因此您可以使用 <code>glob</code> 解决许多问题。如果您的问题更复杂，可以使用 <code>regex</code>，这将在接下来的 <code>Strings</code> 一章中解释。</p>
<p>在这里，我们使用 <code>glob</code> 查找以 <code>.java 或 </code>.txt<code>结尾的所有</code>Path`：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, InterruptedException&#123;</span><br><span class="line">        Path path &#x3D; Paths.get(&quot;.&quot;);</span><br><span class="line">        PathMatcher matcher &#x3D; FileSystems.getDefault()</span><br><span class="line">                .getPathMatcher(&quot;glob:**&#x2F;*.&#123;java,txt&#125;&quot;);</span><br><span class="line">        Files.walk(path)</span><br><span class="line">                .filter(matcher::matches)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>matcher</code> 中，<code>glob</code> 表达式开头的 <code>**/</code> 表示“当前目录及所有子目录”，这在当你不仅仅要匹配当前目录下特定结尾的 <code>Path</code> 时非常有用。单 <code>*</code> 表示“任何东西”，然后是一个点，然后大括号表示一系列的可能性</p>
<h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><p>此时，我们可以对路径和目录做任何事情。 现在让我们看一下操纵文件本身的内容。</p>
<p>如果一个文件很“小”，也就是说“它运行得足够快且占用内存小”，那么 <code>java.nio.file.Files</code> 类中的实用程序将帮助你轻松读写文本和二进制文件。</p>
<p><code>Files.readAllLines()</code> 一次读取整个文件（因此，“小”文件很有必要），产生一个<code>List</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// files/ListOfLines.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListOfLines</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Files.readAllLines(</span><br><span class="line">        Paths.get(<span class="string">&quot;../streams/Cheese.dat&quot;</span>))</span><br><span class="line">        .stream()</span><br><span class="line">        .filter(line -&gt; !line.startsWith(<span class="string">&quot;//&quot;</span>))</span><br><span class="line">        .map(line -&gt;</span><br><span class="line">            line.substring(<span class="number">0</span>, line.length()/<span class="number">2</span>))</span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Not much of a cheese</span></span><br><span class="line"><span class="comment">Finest in the</span></span><br><span class="line"><span class="comment">And what leads you</span></span><br><span class="line"><span class="comment">Well, it&#x27;s</span></span><br><span class="line"><span class="comment">It&#x27;s certainly uncon</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><code>Files.write()</code> 被重载以写入 <code>byte</code> 数组或任何 <code>Iterable</code> 对象（它也有 <code>Charset</code> 选项）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// files/Writing.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Writing</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// Write bytes to a file:</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[SIZE];</span><br><span class="line">        rand.nextBytes(bytes);</span><br><span class="line">        Files.write(Paths.get(<span class="string">&quot;bytes.dat&quot;</span>), bytes);</span><br><span class="line">        System.out.println(<span class="string">&quot;bytes.dat: &quot;</span> + Files.size(Paths.get(<span class="string">&quot;bytes.dat&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write an iterable to a file:</span></span><br><span class="line">        List&lt;String&gt; lines = Files.readAllLines(</span><br><span class="line">          Paths.get(<span class="string">&quot;../streams/Cheese.dat&quot;</span>));</span><br><span class="line">        Files.write(Paths.get(<span class="string">&quot;Cheese.txt&quot;</span>), lines);</span><br><span class="line">        System.out.println(<span class="string">&quot;Cheese.txt: &quot;</span> + Files.size(Paths.get(<span class="string">&quot;Cheese.txt&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">bytes.dat: 1000</span></span><br><span class="line"><span class="comment">Cheese.txt: 199</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>如果文件大小有问题怎么办？ 比如说：</p>
<ol>
<li>文件太大，如果你一次性读完整个文件，你可能会耗尽内存。</li>
<li>您只需要在文件的中途工作以获得所需的结果，因此读取整个文件会浪费时间。</li>
</ol>
<p><code>Files.lines()</code> 方便地将文件转换为行的 <code>Stream</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// files/ReadLineStream.java</span></span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLineStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Files.lines(Paths.get(<span class="string">&quot;PathInfo.java&quot;</span>))</span><br><span class="line">          .skip(<span class="number">13</span>)</span><br><span class="line">          .findFirst()</span><br><span class="line">          .ifPresent(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">    show(&quot;RegularFile&quot;, Files.isRegularFile(p));</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://crazystrome.github.io/2020/10/14/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="crazyStrome">
      <meta itemprop="description" content="啥都写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="crazyStrome的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/14/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-14 18:23:20" itemprop="dateCreated datePublished" datetime="2020-10-14T18:23:20+08:00">2020-10-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-06 11:51:35" itemprop="dateModified" datetime="2020-05-06T11:51:35+08:00">2020-05-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h1 id="1-MySQL体系结构和存储引擎"><a href="#1-MySQL体系结构和存储引擎" class="headerlink" title="1.  MySQL体系结构和存储引擎"></a>1.  MySQL体系结构和存储引擎</h1><h2 id="1-1-定义数据库和实例"><a href="#1-1-定义数据库和实例" class="headerlink" title="1.1.  定义数据库和实例"></a>1.1.  定义数据库和实例</h2><p>数据库：物理操作系统文件或其他形式文件类型的集合。</p>
<p>实例：MySQL数据库由后台线程以及一个共享内存区组成。共享内存可以被运行的后台线程所共享。数据库实例才是真正用于操作数据库文件的。</p>
<p>MySQL被设计成一个单进程多线程架构的数据库。MySQL数据库实例在系统上的表现就是一个进程。</p>
<h2 id="1-2-MySQL体系结构"><a href="#1-2-MySQL体系结构" class="headerlink" title="1.2.  MySQL体系结构"></a>1.2.  MySQL体系结构</h2><p>从概念上来说，数据库是文件的集合，是依照某种数据模型组织起来并存放于二级存储器中的数据集合：数据库实例是程序，是位于用户与操作系统之间的一层数据管理软件，用户对数据库数据的任何操作，包括数据库定义、数据库查询、数据维护、数据库运行控制等都是在数据库实例下进行的，应用程序只有通过数据库实例才能和数据库打交道。</p>
<p>数据库是由一个个文件组成（一般来说都是二进制文件），要对这些文件执行诸如SELECT、INSERT、UPDATE和DELETE之类的操作是不能通过简单的操作文件来更改数据库的内容，需要通过数据库实例来完成对数据库的操作。</p>
<p><img src="https://i.loli.net/2020/04/29/UxIWHj1GQEXgSaq.png"></p>
<p>MySQL由一下几部分组成：</p>
<ul>
<li>连接池组件</li>
<li>管理服务和工具组件</li>
<li>SQL接口组件</li>
<li>查询分析器组件</li>
<li>优化器组件</li>
<li>缓冲组件</li>
<li>插件式存储引擎</li>
<li>物理文件</li>
</ul>
<p>MySQL数据库区别于其他数据库的最重要的一个特点就是其插件式的表存储引擎。</p>
<p>存储引擎是基于表的，而不是数据库。</p>
<h2 id="1-3-MySQL存储引擎"><a href="#1-3-MySQL存储引擎" class="headerlink" title="1.3.  MySQL存储引擎"></a>1.3.  MySQL存储引擎</h2><p>存储引擎是MySQL区别于其他数据库的一个重要特性。存储引擎的好处是，每个存储引擎都有各自的特点，能够根据具体的应用建立不同存储引擎表。</p>
<h3 id="1-3-1-InnoDB存储引擎"><a href="#1-3-1-InnoDB存储引擎" class="headerlink" title="1.3.1.  InnoDB存储引擎"></a>1.3.1.  InnoDB存储引擎</h3><p>InnoDB存储引擎支持事务，其设计目标主要面向在线事务处理（OLTP）的应用，其特点是行锁设计、支持外键，并支持类似于Oracle的非锁定读，即默认读取操作不会产生锁。</p>
<p>InnoDB存储引擎将数据放在一个逻辑的表空间中，这个表空间就像黑盒一样由InnoDB存储引擎自身进行管理。</p>
<p>InnoDB使用多版本并发控制来获得高并发性，并且实现了SQL标准的四种隔离级别，默认为REPEATABLE级别。同时，使用一种称为next-key locking的策略来避免幻读现象的产生。除此之外，InnoDB存储引擎还提供了插入缓冲、二次写、自适应哈希索引、预读等高性能和高可用的功能。</p>
<p>对于表中数据的存储，InnoDB存储引擎使用了聚集的方式，因此每张表的存储都是按照主键的顺序进行存放。如果没有显示地在表定义的时候指定主键，InnoDB存储引擎会为每一行生成一个6字节的ROWID，并以此作为主键。</p>
<h3 id="1-3-2-MyISAM存储引擎"><a href="#1-3-2-MyISAM存储引擎" class="headerlink" title="1.3.2.  MyISAM存储引擎"></a>1.3.2.  MyISAM存储引擎</h3><p>MyISAM存储引擎不支持事务、表锁设计，支持全文索引，主要面向一些OLAP数据库应用。数据库系统与文件系统很大的一个不同之处在与对事务的支持，然而MyISAM存储引擎是不支持事务的。其缓冲池只缓存索引文件，而不缓冲数据文件。</p>
<p>MyISAM存储引擎由MYD和MYI组成，MYD用来存放数据文件，MYI用来存放索引文件。可以通过使用myisampack工具进一步压缩数据。</p>
<h2 id="1-4-各存储引擎之间的比较"><a href="#1-4-各存储引擎之间的比较" class="headerlink" title="1.4.  各存储引擎之间的比较"></a>1.4.  各存储引擎之间的比较</h2><p><img src="https://i.loli.net/2020/04/29/yCMnVu2adWxROtv.png"></p>
<h2 id="1-5-连接MySQL"><a href="#1-5-连接MySQL" class="headerlink" title="1.5.  连接MySQL"></a>1.5.  连接MySQL</h2><p>连接MySQL操作是一个连接进程和MySQL数据库实例进行通信。常用的进程通信方式有管道、命名管道、共享内存、套接字、消息队列、信号量。</p>
<h1 id="2-InnoDB存储引擎"><a href="#2-InnoDB存储引擎" class="headerlink" title="2.  InnoDB存储引擎"></a>2.  InnoDB存储引擎</h1><p><img src="https://i.loli.net/2020/04/29/am2NSvtTfnhgBdU.png"></p>
<p>InnoDB存储引擎由多个内存块，可以认为这些内存块组成了一个大的内存池，负责如下工作：</p>
<ul>
<li>维护所有进程/线程需要访问的多个内部数据结构</li>
<li>缓存磁盘上的数据，方便快速地读取，同时在对磁盘文件的数据修改之前在这里缓存</li>
<li>重做日志（redo log）缓冲</li>
<li>。。。。</li>
</ul>
<p>后台线程的主要作用是负责刷新内存池的数据，保证缓存池中的内存缓存是最近的数据。此外将已修改的数据文件刷新到磁盘文件，同时保证在数据库发生异常的情况下，InnoDB能恢复到正常状态。</p>
<h3 id="2-3-1-后台线程"><a href="#2-3-1-后台线程" class="headerlink" title="2.3.1.  后台线程"></a>2.3.1.  后台线程</h3><p>InnoDB是多线程的模型，因此后台有多个不同的后台线程，负责处理不同的任务。</p>
<ol>
<li>Master Thread</li>
</ol>
<p>Master Thread是一个非常核心的后台线程，主要负责将缓冲池的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲、UNDO页的回收等。</p>
<ol start="2">
<li>IO Thread</li>
</ol>
<p>在InnoDB中使用了大量的AIO来处理写IO请求，这样可以极大提高数据库的性能。而IO Thread的工作主要是负责这些IO请求的回调处理。</p>
<ol start="3">
<li>Purge Thread</li>
</ol>
<p>事务被提交后，其所使用的undolog可能不再需要，因此需要Purge Thread来回收已经使用并分配的undo页。</p>
<ol start="4">
<li>Page Cleaner Thread</li>
</ol>
<p>Page Cleaner Thread作用是将之前版本中脏页的刷新操作都放入到单独的线程中来完成。其目的是为了减轻元Master Thread的工作以及对于用户查询线程的阻塞，进一步提高InnoDB存储引擎的性能。</p>
<h3 id="2-3-2-内存"><a href="#2-3-2-内存" class="headerlink" title="2.3.2.  内存"></a>2.3.2.  内存</h3><p><img src="upload%5Cimage-20200429172042048.png" alt="image-20200429172042048"></p>
<ol>
<li>缓冲池</li>
</ol>
<p>InnoDB是基于磁盘存储的，并将其中的记录按照页的方式进行管理。基于磁盘的数据库系统通常使用缓冲池技术来提高数据库的整体性能。</p>
<p>缓冲池其实就是一块内存区域，通过内存的速度来弥补磁盘速度较慢对数据库性能的影响。在数据库中进行读取页的操作，首先将从磁盘读到的页存放在缓冲池中，这个过程称为将页“FIX”在缓冲池中。下一次再读相同的页时，首先判断该页是否在缓冲池中。若在缓冲池中，称该页在缓冲池中被命中，直接读取该页。否则，读取磁盘上的页。</p>
<p>对于数据库中页的修改操作，首先修改在缓冲池中的页，然后再以一定的频率刷新到磁盘中。这里需要注意的是，页从缓冲池刷新回磁盘的操作并不是在每次页发生更新时触发，而是通过一种称为Checkpoint的机制刷新回磁盘。</p>
<p>缓冲池中缓存的数据页类型有：索引页、数据页、undo页、插入缓冲、自适应哈希索引、InnoDB存储的锁信息、数据字典信息等。</p>
<ol start="2">
<li>LRU List、Free List和Flush List</li>
</ol>
<p>数据库的缓冲池是通过LRU（Least Recent Used，最近最少使用）算法来进行管理的，即最频繁使用的页在LRU列表的前端，而最少使用的页在LRU列表的尾端。当缓冲池不能存放新读取到的页时，将首先释放LRU列表中尾端的页。</p>
<p>InnoDB对传统的LRU算法做了一些优化，在InnoDB的存储引擎中，LRU列表还加入了midpoint位置。新读取到的页，虽然是最新访问的页，但并不是直接放入到LRU列表的首部，而是放入到LRU列表的midpoint位置。这个算法在InnoDB下成为midpoint insertion strategy。在默认配置下，该位置在LRU列表长度的5/8处。</p>
<p>在InnoDB中，midpoint之后的列表成为old列表，之前的列表成为new列表。可以认为new列表都是活跃的数据。</p>
<p>如果直接将读取到的页放入到LRU的首部，那么某些SQL操作可能会使缓冲池中的页被刷新出，从而影响缓冲池效率。常见的操作为索引或者数据的扫描操作。这类操作会访问许多页，这些页可能只是在此次查询操作中需要，并不是活跃的热点数据。如果页被放入到LRU列表的首部，那么非常可能将所需要的热点数据页从LRU列表中移除，而在下一次需要读取该页时，InnoDB可能需要再次访问磁盘。</p>
<p>为了解决这个问题，InnoDB引入了innodb_old_blocks_time来进一步管理LRU列表。用于表示页读取到mid位置后需要等待多久才会被放入到LRU列表的热端。</p>
<p>LRU用来管理已经读取的页，当数据库刚启动时，LRU列表时空的，即没有任何的页。这时，页都存放在free列表中。当需要从缓冲池中分页时，首先从Free列表中查找是否有可用的空闲页，若有，则将改页从free列表中删除，放入到LRU列表中。否则，根据LRU算法，淘汰LRU列表末尾的页，将该内存空间分配给新的页。当页从LRU列表的old部分加入到new部分时，称此时发生的操作为page made young，而因为innodb_old_blocks_time的设置而导致页没有从old部分移动到new部分的操作称为page not made young。可以通过<code>SHOW ENGINE INNODB STATUS</code>来观察LRU列表以及Free列表的使用情况和运行状态。</p>
<ol start="3">
<li>重做日志缓冲</li>
</ol>
<p>InnoDB首先将重做日志信息放入到这个缓冲区，然后按照一定频率将其刷新到重做日志文件。重做日志缓冲一般不需要设置得很大，因为一般情况下每一秒钟会将重做日志缓冲刷新到日志文件，因此用户只需要保证每秒产生的事务量在这个缓冲大小之内即可。</p>
<ol start="4">
<li>额外的内存池</li>
</ol>
<p>在InnoDB中，对内存的管理是通过内存堆进行的。在对一些数据结构本身的内存进行分配时，需要从额外的内存池中进行申请，当该区域的内存不够时，会从缓冲池进行申请。</p>
<h2 id="2-4-Checkpoint技术"><a href="#2-4-Checkpoint技术" class="headerlink" title="2.4.  Checkpoint技术"></a>2.4.  Checkpoint技术</h2><p>如果在从缓冲池中将页的新版本刷新到磁盘时发生了宕机，那么数据就不能恢复了。为了避免发生数据丢失的问题，当前事务数据库系统普遍采用了Write Ahead Log策略，即当事务提交时，先写重做日志，再修改页。当由于宕机而导致数据丢失时，通过重做日志来完成数据的恢复。这也是ACID中D的要求。</p>
<p>Checkpoint技术的目的是解决一下问题：</p>
<ul>
<li>缩短数据库的恢复时间</li>
<li>缓冲池不够用时，将脏页刷新到磁盘</li>
<li>重做日志不可用时，刷新脏页</li>
</ul>
<p>当数据库发生宕机时，数据库不需要重做所有日志，因为checkpoint之前的页都已经刷新回磁盘。所以数据库只需对checkpoint后的重做日志进行恢复。</p>
<p>当缓冲池不够用时，根据LRU算法会溢出最近最少使用的页，若此页为脏页，那么需要强制执行checkpoint，将脏页也就是页的新版本刷新回磁盘。</p>
<p>InnoDB是通过LSN（Log Sequence Number）来标记版本的。LSN是8字节的数字。每个页有LSN，重做日志也有LSN，Checkpoint也有LSN。</p>
<p>在InnoDB中，有两种Checkpoint，分别为：</p>
<ul>
<li>Sharp Checkpoint</li>
<li>Fuzzy Checkpoint</li>
</ul>
<p>Sharp Checkpoint发生在数据库关闭时将所有的脏页都刷新回磁盘。</p>
<p>InnoDB内部使用Fuzzy Checkpoint进行页的刷新，即只刷新一部分脏页，而不是刷新所有的脏页回磁盘。</p>
<p>在InnoDB中可能发生如下几种情况的Fuzzy Checkpoint：</p>
<ul>
<li>Master Thread Checkpoint</li>
<li>FLUSH_LRU_LIST Checkpoint</li>
<li>Async/Sync Flush Checkpoint</li>
<li>Dirty Page too much Checkpoint</li>
</ul>
<p>对于Master Thread发生的Checkpoint。差不多以每十秒或者每一秒的速度从缓冲池的脏页列表中刷新一定比例的页回磁盘。这个过程是异步的，即此时的InnoDB存储引擎可以进行其他操作，用户查询线程不会阻塞。</p>
<p>FLUSH_LRU_LIST Checkpoint是因为InnoDB需要保证LRU列表中需要有差不多100个空闲页可以使用。</p>
<p>Async/Sync Flush Checkpoint指的是重做日志文件不可用的情况，这是需要强制将一些页刷新回磁盘，而此时脏页是从脏页列表中选取的。</p>
<p>Dirty Page too much，即脏页的数量太多，导致InnoDB强制进行Checkpoint。</p>
<h2 id="2-5-Master-Thread-工作方式"><a href="#2-5-Master-Thread-工作方式" class="headerlink" title="2.5.  Master Thread 工作方式"></a>2.5.  Master Thread 工作方式</h2><p>InnoDB的主要工作都是在一个单独的后台线程Master Thread中完成的。</p>
<h3 id="2-5-1-InnoDB-1-0-x版本之前的Master-Thread"><a href="#2-5-1-InnoDB-1-0-x版本之前的Master-Thread" class="headerlink" title="2.5.1.  InnoDB 1.0.x版本之前的Master Thread"></a>2.5.1.  InnoDB 1.0.x版本之前的Master Thread</h3><p>Master Thread具有最高的线程优先级别。其内部由多个循环组成：主循环（Loop）、后台循环（Backgroup loop）、刷新循环（flush loop）、暂停循环（suspend loop）。Master Thread会根据数据库运行的状态在loop、background loop、flush loop和suspend loop中进行切换。</p>
<p>loop称为主循环，大多数操作是在这个循环中。其中有两大部分的操作–每秒钟的操作和每十秒钟的操作。</p>
<p>每秒一次的操作包括：</p>
<ul>
<li>日志缓冲刷新到磁盘，即使这个事务还没有提交</li>
<li>合并插入缓冲</li>
<li>之多刷新100个InnoDB的缓冲池中的脏页到磁盘</li>
<li>如果当前没有用户活动，则切换到background loop</li>
</ul>
<p>每十秒的操作包括：</p>
<ul>
<li>刷新100个脏页到磁盘</li>
<li>合并至多五个插入缓冲</li>
<li>将日志缓冲刷新到磁盘</li>
<li>删除无用的Undo页</li>
<li>刷新100个或者10个脏页到磁盘</li>
</ul>
<p>若当前没有用户活动或者数据库关闭，就会切换到background loop。执行以下操作：</p>
<ul>
<li>删除无用的Undo页</li>
<li>合并20个插入缓冲</li>
<li>跳回到主循环</li>
<li>不断刷新100个页直到符合条件</li>
</ul>
<p>如果flush loop没有事情做，InnoDB引擎会切换到suspend loop，将Master Thread挂起，等待事件的发生。若用户启用了InnoDB，却没有任何InnoDB的表使用，那么Master Thread总是处于挂起的状态。</p>
<h3 id="2-5-2-InnoDB1-2-x版本之前的Master-Thread"><a href="#2-5-2-InnoDB1-2-x版本之前的Master-Thread" class="headerlink" title="2.5.2.  InnoDB1.2.x版本之前的Master Thread"></a>2.5.2.  InnoDB1.2.x版本之前的Master Thread</h3><p>提高磁盘的IO</p>
<h2 id="2-6-InnoDB的关键特性"><a href="#2-6-InnoDB的关键特性" class="headerlink" title="2.6.  InnoDB的关键特性"></a>2.6.  InnoDB的关键特性</h2><p>InnoDB的关键特性包括：</p>
<ul>
<li>插入缓冲</li>
<li>两次写</li>
<li>自适应哈希索引</li>
<li>异步IO</li>
<li>刷新邻接页</li>
</ul>
<h3 id="2-6-1-插入缓冲"><a href="#2-6-1-插入缓冲" class="headerlink" title="2.6.1.  插入缓冲"></a>2.6.1.  插入缓冲</h3><ol>
<li>Insert Buffer</li>
</ol>
<p>Insert Buffer和数据页一样，也是物理页的一个组成部分。</p>
<p>插入聚集索引一般是顺序的，不需要磁盘的随机读取。</p>
<p>当一张表上有非聚集的辅助索引时，在进行插入操作时，数据页的存放还是按主键进行顺序存放的，但是对于非聚集索引叶子节点的插入不再是顺序的了，需要离散地访问非聚集索引页，由于随机读取的存在而导致了插入操作性能下降。这是因为B+树的特性决定了非聚集索引插入的离散性。</p>
<p>在InnoDB中使用了Insert Buffer，对于非聚集索引的插入或者更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，若在，则直接插入；若不在，则先放入到一个Insert Buffer对象中，好像在欺骗数据库这个非聚集的索引已经插到了叶子节点中，而实际没有，只是存放在另一个位置。然后再以一定的频率和情况进行Insert Buffer和辅助索引页子节点的merge操作。</p>
<p>使用Insert Buffer需要满足一下两个条件：</p>
<ul>
<li>索引是辅助索引</li>
<li>索引不是唯一的</li>
</ul>
<ol start="2">
<li>Change Buffer</li>
</ol>
<p>InnoDB可以对DML操作-INSERT、DELETE、UPDATE都进行缓冲，分别是：Insert Buffer、Delete Buffer、Purge Buffer。</p>
<ol start="3">
<li>Insert Buffer的内部实现</li>
</ol>
<p>Insert Buffer的数据结构是一颗B+树。非叶子节点存放的是查询的search key。</p>
<p><img src="https://i.loli.net/2020/05/02/QA2GYbDgZsjN9Rm.png"></p>
<p>search key一共占用9个字节，其中space表示插入记录所在表的表空间id，在InnoDB中，每个表有一个唯一的space id，可以通过space id查询得知是哪张表。space占用4个字节。marker占用1字节，它使用来兼容老版本的Insert Buffer。offset表示所在页的偏移量，占用4个字节。</p>
<ol start="4">
<li>Merge Insert Buffer</li>
</ol>
<p>Merge Insert Buffer的操作可能发生在以下几种情况下：</p>
<ul>
<li>辅助索引页被读取到缓冲池</li>
<li>Insert Buffer Bitmap页追踪到该辅助索引页已无可用空间</li>
<li>Master Thread</li>
</ul>
<h3 id="2-6-2-两次写"><a href="#2-6-2-两次写" class="headerlink" title="2.6.2  两次写"></a>2.6.2  两次写</h3><p>doublewrite给InnoDB带来数据页的可靠性。</p>
<p>当发生数据库宕机时，存储引擎正在写入某个页到表中，而这个页只写了一部分，这种情况称为部分写失效。</p>
<p>在应用重做日志的时候，需要一个页的副本，当写入时效时，先通过页的副本来还原该页，再进行重做，这就是两次写。</p>
<h3 id="2-6-3-自适应哈希索引"><a href="#2-6-3-自适应哈希索引" class="headerlink" title="2.6.3  自适应哈希索引"></a>2.6.3  自适应哈希索引</h3><p>哈希的查找时间复杂度为o(1)。</p>
<p>InnoDB会监控对表上的各索引页的查询。如果观察到建立哈希索引可以带来速度提升，则建立哈希索引，称之为自适应哈希索引（Adaptive Hash Index，AHI）。AHI是通过缓冲池的B+树页构造而来的，因此建立的速度很快，而且不需要对整张表建立哈希索引。InnoDB会根据访问的频率和模式来自动地为某些热点页建立哈希索引。</p>
<h3 id="2-6-4-异步IO"><a href="#2-6-4-异步IO" class="headerlink" title="2.6.4  异步IO"></a>2.6.4  异步IO</h3><p>AIO可以同时发出多个IO请求。</p>
<p>AIO可以进行IO merge操作，就是把多个IO合并成一个IO，这样可以提高IOPS的性能。</p>
<h3 id="2-6-5-刷新邻接页"><a href="#2-6-5-刷新邻接页" class="headerlink" title="2.6.5  刷新邻接页"></a>2.6.5  刷新邻接页</h3><p>当刷新一个脏页时，InnoDB会检测该页所在区的所有页，如果是脏页，那么一起刷新。</p>
<h1 id="5-索引与算法"><a href="#5-索引与算法" class="headerlink" title="5  索引与算法"></a>5  索引与算法</h1><h2 id="5-1-InnoDB存储引擎索引概述"><a href="#5-1-InnoDB存储引擎索引概述" class="headerlink" title="5.1  InnoDB存储引擎索引概述"></a>5.1  InnoDB存储引擎索引概述</h2><p>InnoDB支持一下几种常见的索引：</p>
<ul>
<li>B+索引</li>
<li>全文索引</li>
<li>哈希索引</li>
</ul>
<p>InnoDB支持的哈希索引是自适应的，InnoDB存储引擎会根据表的使用情况自动生成哈希索引，不能人为干预是否在一张表中生成哈希索引。</p>
<p>B+树索引的构造类似于二叉树，根据键值快速找到数据。</p>
<p>B+树索引并不能找到一个给定键值的具体行。B+树索引能找到的只是被查找数据航所在的页，然后通过数据库把页读入到内存，再在内存中进行查找，最后得到要查找的数据。</p>
<h2 id="5-2-数据结构与算法"><a href="#5-2-数据结构与算法" class="headerlink" title="5.2  数据结构与算法"></a>5.2  数据结构与算法</h2><h3 id="5-2-1-二分查找法"><a href="#5-2-1-二分查找法" class="headerlink" title="5.2.1  二分查找法"></a>5.2.1  二分查找法</h3><p>将记录按有序化排列，在查找过程中采用跳跃式查找，即先以有序数列的中点位置为比较对象，如果要找的元素值小于该中点元素，则将待查序列缩小为左半部分，否则为右半部分。通过一次查找，将查找区间缩小一半。</p>
<h3 id="5-2-2-二叉查找树和平衡二叉树"><a href="#5-2-2-二叉查找树和平衡二叉树" class="headerlink" title="5.2.2  二叉查找树和平衡二叉树"></a>5.2.2  二叉查找树和平衡二叉树</h3><p>当二叉查找树单边增长时，可以使用平衡二叉树。</p>
<p>平衡二叉树满足任何节点的两个子树的高度最大差为1.</p>
<p>平衡二叉树的查询速度很快，但是维护一颗平衡二叉树的代价很大，需要进行多次的旋转来实现。</p>
<h2 id="5-3-B-树"><a href="#5-3-B-树" class="headerlink" title="5.3  B+树"></a>5.3  B+树</h2><p>B+树是为磁盘或其他直接存取辅助设备设计的平衡查找树。</p>
<h2 id="5-4-B-树索引"><a href="#5-4-B-树索引" class="headerlink" title="5.4  B+树索引"></a>5.4  B+树索引</h2><p>数据库中的B+树索引分为聚集索引和辅助索引，叶子节点存放所有数据。聚集索引和辅助索引不同的是，叶子节点存放的是否是一整行的信息。</p>
<h3 id="5-4-1-聚集索引"><a href="#5-4-1-聚集索引" class="headerlink" title="5.4.1  聚集索引"></a>5.4.1  聚集索引</h3><p>InnoDB存储引擎表的索引组织表，即表中数据按照主键顺序存放。而聚集索引就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的即为整张表的行记录数据，也将聚集索引的叶子节点称为数据页。聚集索引的这个特性决定了索引组织表中数据也是索引的一部分。同B+树数据结构一样，每个数据页否通过一个双向链表来进行链接。</p>
<p>每张表智能有一个聚集索引。聚集索引可以在B+树索引的叶子节点上直接找到数据，聚集索引可以很快地访问针对范围值的查询。</p>
<p>数据页上存放的是完整的每行的记录，而在非数据页的索引页中，存放的仅仅是键值及指向数据页的偏移量，而不是一个完整的行记录。</p>
<p>聚集索引存储并不是物理上连续的，而是逻辑上连续的。页通过双向链表链接，页按照主键的顺序排列；页中的记录也是通过双向链表进行维护的，物理存储上可以同样不按照主键存储。</p>
<p>聚集索引的好处：对于主键的排序查找和范围查找速度非常快。叶子节点的数据就是用户所要查询的数据。</p>
<h3 id="5-4-2-辅助索引"><a href="#5-4-2-辅助索引" class="headerlink" title="5.4.2  辅助索引"></a>5.4.2  辅助索引</h3><p>辅助索引也称非聚集性索引，叶子节点不包含行记录的全部数据。叶子节点除了包含键值以外，每个叶子节点中的索引行中还包含了一个书签。该书签用来告诉InnoDB哪里可以找到与索引对应的行数据。由于InnoDB存储引擎表是索引组织表，因此InnoDB存储引擎的辅助索引的书签就是相应行数据的聚集索引键。</p>
<p>辅助索引的存在并不影响数据在聚集索引中的组织，因此每张表可以有多个辅助索引。当通过辅助索引来寻找数据时，InnoDB会遍历辅助索引并通过叶级别的指针获得指向主键索引的主键，再通过主键索引来找到一个完整的行记录。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://crazystrome.github.io/2020/10/14/JVM%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="crazyStrome">
      <meta itemprop="description" content="啥都写">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="crazyStrome的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/14/JVM%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-14 18:23:20" itemprop="dateCreated datePublished" datetime="2020-10-14T18:23:20+08:00">2020-10-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-22 14:59:07" itemprop="dateModified" datetime="2020-03-22T14:59:07+08:00">2020-03-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>JVM内存区域分为五个部分，分别是堆，方法区，虚拟机栈，本地方法栈，程序计数器。</p>
<p><img src="https://i.loli.net/2020/03/22/HIx6ugVmdNTRMwE.png" alt="img"></p>
<ul>
<li>堆。堆是Java对象的存储区域，任何用new字段分配的Java对象实例和数组，都被分配在堆上，Java堆可使用-Xms -Xmx进行内存控制，值得一提的是从JDK1.7版本之后，运行时常量池从方法区移到了堆上。</li>
<li>方法区。它用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据，方法区在JDK1.7版本及以前被称为永久代，从JDK1.8永久代被移除。</li>
<li>虚拟机栈。虚拟机中执行每个方法的时候，都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。</li>
<li>本地方法栈。与虚拟机栈发挥的作用相似，相比于虚拟机栈为Java方法服务，本地方法栈为虚拟机使用的Native方法服务，执行每个本地方法的时候，都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。</li>
<li>程序计数器。指示Java虚拟机下一条需要执行的字节码指令。 </li>
</ul>
<p>以上五个区域是Java虚拟机内存划分情况，其中方法区和堆被JVM中多个线程共享，比如类的静态常量就被存放在方法区，供类对象之间共享，虚拟机栈，本地方法栈，pc寄存器是每个线程独立拥有的，不会与其他线程共享。 </p>
<p>所以Java在通过new创建一个类对象实例的时候，一方面会在虚拟机栈中创建一个该对象的引用，另一方面会在堆上创建类对象的实例，然后将对象引用指向该对象的实例。对象引用存放在每一个方法对应的栈帧中。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">crazyStrome</p>
  <div class="site-description" itemprop="description">啥都写</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">null </a>
  </div>

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">crazyStrome</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  

  

    </div>
</body>
</html>
